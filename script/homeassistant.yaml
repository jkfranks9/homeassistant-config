#==========================#
#     Global Variables     #
#==========================#

# We keep a set of global variables in the trigger-based template sensor 'Variables'. Most/all of these are actually
# constants. They exist as entries in a dictionary under the 'variables' attribute, so are retrieved as follows:
#
# state_attr('sensor.variables', 'variables').<var name>

# Trigger-based template sensors are restored on HA start, so we only need to initialize the variables once, which 
# is the purpose of this script. As such, it only needs to be called when anything here is new, changed or deleted.
initialize_global_variables:
  alias: Initialize Global Variables
  
  sequence:
    
    # Rooms with lights are for voice control of lights in certain rooms.
    # NOTE: The next 2 variables are related and must be kept in sync.
    - event: set_variable
      event_data:
        key: light_rooms
        value: ['family_room', 'master_bedroom', 'office', 'penthouse', 'studio', 'theater']
    
    - event: set_variable
      event_data:
        key: light_rooms_lights
        value: ['light.family_room_lamp', 'light.master_bedroom_lamp', 'light.office_lamp', 'light.penthouse_bedroom', 'input_select.preferred_studio_lamps', 'light.theater_recessed']
    
    # Rooms with fans are for voice control of ceiling fans in certain rooms.
    - event: set_variable
      event_data:
        key: fan_rooms
        value: ['family_room', 'office', 'theater']
    
    # Calorie values for simple exercise types.
    - event: set_variable
      event_data:
        key: workout_calories_per_hour
        value: 200
    
    - event: set_variable
      event_data:
        key: yard_work_calories_per_hour
        value: 250
    
    - event: set_variable
      event_data:
        key: steps_calories_per_thousand
        value: 40.2
    
    - event: set_variable
      event_data:
        key: steps_daily_goal
        value: 2500
    
    # Recordable exercise minimums.
    - event: set_variable
      event_data:
        key: recordable_exercise_minimum_time
        value: 30
    
    - event: set_variable
      event_data:
        key: recordable_exercise_minimum_days_per_month
        value: 10
    
    # Mini todo list periodic cleaning time estimates.
    - event: set_variable
      event_data:
        key: mini_todo_cleaning_times
        value: { "{{ state_attr('input_datetime.periodic_cleaning_dining_foyer', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 45, 
                 "{{ state_attr('input_datetime.periodic_cleaning_family_room', 'friendly_name').split('Periodic Cleaning ')[-1] }}": [30, 60],
                 "{{ state_attr('input_datetime.periodic_cleaning_kitchen', 'friendly_name').split('Periodic Cleaning ')[-1] }}": [45, 30],
                 "{{ state_attr('input_datetime.periodic_cleaning_laundry_room', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 15,
                 "{{ state_attr('input_datetime.periodic_cleaning_master_bath', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 30,
                 "{{ state_attr('input_datetime.periodic_cleaning_master_bedroom', 'friendly_name').split('Periodic Cleaning ')[-1] }}": [45, 45],
                 "{{ state_attr('input_datetime.periodic_cleaning_office', 'friendly_name').split('Periodic Cleaning ')[-1] }}": [30, 50],
                 "{{ state_attr('input_datetime.periodic_cleaning_penthouse_bath', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 15,
                 "{{ state_attr('input_datetime.periodic_cleaning_penthouse_bedroom', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 25,
                 "{{ state_attr('input_datetime.periodic_cleaning_snack_bar', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 15,
                 "{{ state_attr('input_datetime.periodic_cleaning_studio_bath', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 20,
                 "{{ state_attr('input_datetime.periodic_cleaning_studio_bedroom', 'friendly_name').split('Periodic Cleaning ')[-1] }}": [15, 45],
                 "{{ state_attr('input_datetime.periodic_cleaning_theater', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 25,
                 "{{ state_attr('input_datetime.periodic_cleaning_utility', 'friendly_name').split('Periodic Cleaning ')[-1] }}": 15
               }
    
    # Mini todo list periodic yard work time estimates.
    - event: set_variable
      event_data:
        key: mini_todo_yard_work_times
        value: { "{{ state_attr('input_datetime.periodic_yard_mow_push', 'friendly_name').split('Periodic Yard ')[-1] }}": 25,
                 "{{ state_attr('input_datetime.periodic_yard_mow_tractor', 'friendly_name').split('Periodic Yard ')[-1] }}": 100, 
                 "{{ state_attr('input_datetime.periodic_yard_spray_back_pool_roadside', 'friendly_name').split('Periodic Yard ')[-1] }}": 50,
                 "{{ state_attr('input_datetime.periodic_yard_spray_edge_trees', 'friendly_name').split('Periodic Yard ')[-1] }}": 50,
                 "{{ state_attr('input_datetime.periodic_yard_spray_frontage_driveway', 'friendly_name').split('Periodic Yard ')[-1] }}": 45,
                 "{{ state_attr('input_datetime.periodic_yard_spray_sidewalk_front_side', 'friendly_name').split('Periodic Yard ')[-1] }}": 45,
                 "{{ state_attr('input_datetime.periodic_yard_trim_back', 'friendly_name').split('Periodic Yard ')[-1] }}": 60,
                 "{{ state_attr('input_datetime.periodic_yard_trim_courtyard', 'friendly_name').split('Periodic Yard ')[-1] }}": 60,
                 "{{ state_attr('input_datetime.periodic_yard_trim_edge_trees', 'friendly_name').split('Periodic Yard ')[-1] }}": 60,
                 "{{ state_attr('input_datetime.periodic_yard_trim_front', 'friendly_name').split('Periodic Yard ')[-1] }}": 120,
                 "{{ state_attr('input_datetime.periodic_yard_trim_frontage_east', 'friendly_name').split('Periodic Yard ')[-1] }}": 120,
                 "{{ state_attr('input_datetime.periodic_yard_trim_frontage_west', 'friendly_name').split('Periodic Yard ')[-1] }}": 90,
                 "{{ state_attr('input_datetime.periodic_yard_trim_pool', 'friendly_name').split('Periodic Yard ')[-1] }}": 40,
                 "{{ state_attr('input_datetime.periodic_yard_trim_roadside', 'friendly_name').split('Periodic Yard ')[-1] }}": 60,
                 "{{ state_attr('input_datetime.periodic_yard_trim_side', 'friendly_name').split('Periodic Yard ')[-1] }}": 50,
                 "{{ state_attr('input_datetime.periodic_yard_trim_sidewalk', 'friendly_name').split('Periodic Yard ')[-1] }}": 40
               }
    
    # Mini todo list periodic other time estimates.
    - event: set_variable
      event_data:
        key: mini_todo_other_times
        value: { "{{ state_attr('input_datetime.periodic_other_ear_drops', 'friendly_name').split('Periodic Other ')[-1] }}": 10, 
                 "{{ state_attr('input_datetime.periodic_other_haircut', 'friendly_name').split('Periodic Other ')[-1] }}": 15,
                 "{{ state_attr('input_datetime.periodic_other_trash', 'friendly_name').split('Periodic Other ')[-1] }}": 40
               }
    
    # ESPHome update all assistance (see Assist ESPHome Update All automation) ...
    
    # ... number of total devices being updated within a short period to indicate this is an update all operation.
    - event: set_variable
      event_data:
        key: esphome_update_all_target_device_count
        value: 3
    
    # ... number of devices alphabetically before the battery device.
    - event: set_variable
      event_data:
        key: esphome_update_all_prior_device_count
        value: 6
    
    # ... battery device update cycle in seconds. This must match the deep_sleep configuration in the battery device (total of sleep and run durations).
    - event: set_variable
      event_data:
        key: esphome_update_all_battery_device_cycle_seconds
        value: 600
    
    # Mobile notification tags to be sent to Sarah in addition to Jon.
    - event: set_variable
      event_data:
        key: sarah_notification_tags
        value: ['next_canes_game', 'test_notify_sarah']

#========================#
#     Mini ToDo List     #
#========================#

# Before we can attempt adding outdoor tasks to the mini todo list, we need to know if it's sensible and safe to work outdoors.
# We gather temperature and humidity for the hours between the daily start and end times, as well as precipitation probability
# and the UV index. The first 3 of these metrics are averaged over the time span, and we take the maximum UV index over the 
# same period. These are all placed in number helpers, and are input to the Outdoor Work Friendly sensor.
get_weather_metrics:
  alias: Get Weather Metrics
  
  sequence:    
    - variables:
        
        # The first and last hours of the daily time span. We use the normal time span but slide the window back one hour, so I can start earlier 
        # than the normal start during the hot summer, while also avoiding a bit of the late afternoon.
        first_hour: "{{ states('input_datetime.mini_todo_start_time').split(':')[0] | int(0) - 1 }}"
        last_hour: "{{ states('input_datetime.mini_todo_end_time').split(':')[0] | int(0) - 1 }}"
    
    # Calculate the weather metrics for the daily time span.
    - action: script.calculate_weather_metrics
      data:
        weather_entity: weather.openweathermap
        forecast_type: hourly
        first_hour: "{{ first_hour }}"
        last_hour: "{{ last_hour }}"
        metrics_list:
          - ['input_number.average_outdoor_temperature', 'temperature', 75, 0]
          - ['input_number.average_outdoor_humidity', 'humidity', 50, 0]
          - ['input_number.average_outdoor_precipitation_probability', 'precipitation_probability', 50, 0]
          - ['input_number.maximum_outdoor_uv_index', 'uv_index', 3, 0]
    
    - variables:
        average_temperature: "{{ states('input_number.average_outdoor_temperature') | float(75) }}"
        average_humidity: "{{ states('input_number.average_outdoor_humidity') | float(50) }}"
    
    # Calculate the apparent temperature, using the average temperature and humidity. The formula is from the National Weather Service:
    # https://www.weather.gov/media/epz/wxcalc/heatIndex.pdf
    #
    # However, this only works if the temperature and humidity are above certain thresholds.
    - if:
        - "{{ average_temperature >= 80 and average_humidity >= 40 }}"
      
      then:
        - action: input_number.set_value
          target:
            entity_id: input_number.apparent_outdoor_temperature
          data:
            value: >
              {% set T = average_temperature %}
              {% set H = average_humidity %}
              {% set c1 = 42.379 %}
              {% set c2 = 2.04901523 %}
              {% set c3 = 10.14333127 %}
              {% set c4 = 0.22475541 %}
              {% set c5 = 0.00683783 %}
              {% set c6 = 0.05481717 %}
              {% set c7 = 0.00122874 %}
              {% set c8 = 0.00085282 %}
              {% set c9 = 0.00000199 %}
              {{ (-c1 + (c2 * T) + (c3 * H) - (c4 * T * H) - (c5 * T**2) - (c6 * H**2) + (c7 * T**2 * H) + (c8 * T * H**2) - (c9 * T**2 * H**2)) | round(2) }}
      
      # Thresholds not met, so just use the average temperature.
      else:
        - action: input_number.set_value
          target:
            entity_id: input_number.apparent_outdoor_temperature
          data:
            value: "{{ average_temperature }}"        

# Front end to Generate Weekly Periodic List. That script should normally only be called once a week on Sunday. However, it
# seems like the various weekly periodic list sensors can become unknown for some unknown (haha) reason. So we also 
# regenerate the lists at HA startup if we detect such a case. Hence this script since I don't want to repeat this logic.
generate_periodic_lists:
  alias: Generate Periodic Lists
  
  fields:
    type:
      description: The type of list(s) to generate.
      selector:
        select:
          options:
            - cleaning
            - other
            - yard_work
            - all
    
    start_date:
      description: Starting date for list generation. This is the most recent Sunday.
      selector:
        date:
  
  sequence:
    - if:
        - "{{ type in ['all', 'cleaning'] }}"
    
      then:
        - service: script.generate_weekly_periodic_list
          data:
            type: cleaning
            start_date: "{{ start_date }}"
            generator_count: "{{ iif(states('input_boolean.mini_todo_generator_switch') == 'off', 3, 4) }}"
            date_entities: [
                            'input_datetime.periodic_cleaning_kitchen',
                            'input_datetime.periodic_cleaning_studio_bath',
                            'input_datetime.periodic_cleaning_master_bath',
                            'input_datetime.periodic_cleaning_family_room',
                            'input_datetime.periodic_cleaning_office',
                            'input_datetime.periodic_cleaning_master_bedroom',
                            'input_datetime.periodic_cleaning_theater',
                            'input_datetime.periodic_cleaning_penthouse_bath',
                            'input_datetime.periodic_cleaning_dining_foyer',
                            'input_datetime.periodic_cleaning_laundry_room',
                            'input_datetime.periodic_cleaning_snack_bar',
                            'input_datetime.periodic_cleaning_utility',
                            'input_datetime.periodic_cleaning_studio_bedroom',
                            'input_datetime.periodic_cleaning_penthouse_bedroom'
                           ]
    
    - if:
        - "{{ type in ['all', 'other'] }}"
    
      then:
        - service: script.generate_weekly_periodic_list
          data:
            type: other
            start_date: "{{ start_date }}"
            generator_count: 5
            date_entities: [
                            'input_datetime.periodic_other_ear_drops',
                            'input_datetime.periodic_other_haircut',
                            'input_datetime.periodic_other_trash'
                           ]
    
    # NOTE: The following is temporarily removed; add back when needed.
    #       'input_datetime.periodic_yard_trim_courtyard',
    - if:
        - "{{ type in ['all', 'yard_work'] }}"
    
      then:
        - service: script.generate_weekly_periodic_list
          data:
            type: yard_work
            start_date: "{{ start_date }}"
            generator_count: 3
            date_entities: [
                            'input_datetime.periodic_yard_spray_frontage_driveway',
                            'input_datetime.periodic_yard_spray_sidewalk_front_side',
                            'input_datetime.periodic_yard_spray_back_pool_roadside',
                            'input_datetime.periodic_yard_spray_edge_trees',
                            'input_datetime.periodic_yard_trim_frontage_east',
                            'input_datetime.periodic_yard_trim_frontage_west',
                            'input_datetime.periodic_yard_trim_sidewalk',
                            'input_datetime.periodic_yard_trim_front',
                            'input_datetime.periodic_yard_trim_side',
                            'input_datetime.periodic_yard_trim_back',
                            'input_datetime.periodic_yard_trim_pool',
                            'input_datetime.periodic_yard_trim_roadside',
                            'input_datetime.periodic_yard_trim_edge_trees',
                            'input_datetime.periodic_yard_mow_tractor',
                            'input_datetime.periodic_yard_mow_push'
                           ]

# This is an input to the daily mini-todo list logic. It is run once a week to generate a short list of periodic tasks 
# for the coming week (for cleaning, yard work and other types of items). The Create Daily Mini ToDo List automation then 
# picks one or two items of each type as needed throughout the week.
generate_weekly_periodic_list:
  alias: Generate Weekly Periodic List
  
  fields:
    type:
      description: The type of periodic items to consider.
      selector:
        select:
          options:
            - cleaning
            - yard_work
            - other
    
    start_date:
      description: Starting date for list generation. This is the most recent Sunday.
      selector:
        date:
    
    generator_count:
      description: Maximum items to generate for the week.
      selector:
        number:
          min: 1
          max: 10
    
    date_entities:
      description: Datetime entities for all the periodic items of a given type.
      selector:
        entity:
          multiple: true
          filter:
            - domain: input_datetime
  
  sequence:
    
    # Empty the Weekly Periodic List sensor.
    - action: script.send_mini_todo_event
      data:
        event_type: reset
        item_type: "{{ type }}"
    
    - variables:
        split_text: "{{ 'Periodic ' ~ type.split('_')[0] | title }}"
        times_var: "{{ 'mini_todo_' ~ type ~ '_times' }}"
        
        # List of actionable items (those overdue or due within a few days).
        actionable_entities: >
          {# Start with an empty list. #}
          {% set var = namespace(list = []) %}
          
          {# Walk through the input date entities. #}
          {% for entity in date_entities %}
            
            {# Add to the list if the entity is overdue or due within a few days. #}
            {% if as_timestamp(states(entity), 0) <= as_timestamp(as_datetime(start_date) + timedelta(days = 3), 0) %}
              {% set var.list = var.list + [entity] %}
            {% endif %}
          {% endfor %}
          
          {{ var.list }}
        
        # Randomizer, just for fun.
        randomizer: "{{ range(10) | random }}"
        
        # Walk through the list forwards or backwards randomly.
        loop_template: "{{ iif(randomizer is even, actionable_entities[0:generator_count], actionable_entities[0:generator_count] | reverse | list) }}"
    
    - repeat:
        for_each: "{{ loop_template }}"
        
        sequence:
          - variables:
              item_text: "{{ state_attr(repeat.item, 'friendly_name').split(split_text)[-1] }}"
              icon_tag: >
                {% if type == 'cleaning' %}
                  cl:
                {% elif type == 'yard_work' %}
                  {% set category = item_text.split()[0] %}
                  {{ iif(category == 'Spray', 'ys:', iif(category == 'Trim', 'yt:', 'ym:')) }}
                {% else %}
                  ot:
                {% endif %}
            
          # Add this item to the weekly sensor.
          - action: script.send_mini_todo_event
            data:
              event_type: add
              item_type: "{{ type }}"
              value: "{{ icon_tag ~ item_text }}"

# This is an input to the daily mini-todo list logic. It is run once a week to pick a few days for free time.
# This is represented as a bitmask, where the least significant bit represents Sunday.
generate_weekly_free_time_days:
  alias: Generate Weekly Free Time Days
  
  sequence:
    - variables:
        days: >
          {# We want either 2 or 3 days per week. #}
          {% set count = iif(now().day is odd, range(1, 3) | list, range(1, 4) | list) %}
          
          {# Initialize variables. #}
          {% set v = namespace(value = 0) %}
          {% set d = namespace(days = [0, 1, 2, 3, 4, 5, 6]) %}
          {% set l = namespace(len = d.days | length) %}
          
          {# Loop per the loop count. #}
          {% for iter in count %}
            
            {# Pick a random day and update the result. #}
            {% set idx = range(0, l.len) | random %}
            {% set day_on = 2 ** d.days[idx] %}
            {% set v.value = v.value | bitwise_or(day_on) %}
            
            {# Remove the day we just picked from the days list. #}
            {% set var = namespace(new = []) %}
            {% for item in d.days %}
              {% if loop.index0 != idx %}
                {% set var.new = var.new + [item] %}
              {% endif %}
            {% endfor %}
            {% set d.days = var.new %}
            
            {# Decrement the days length for the next iteration. #}
            {% set l.len = l.len - 1 %}
          {% endfor %}
          
          {{ v.value }}
          
    - service: input_number.set_value
      target:
        entity_id: input_number.mini_todo_weekly_free_time_days
      data:
        value: "{{ days }}"

# Helper script for sending mini todo list events. Looks like the event itself cannot be a template, and I don't want to keep
# multiple copies of choose logic everywhere.
send_mini_todo_event:
  alias: Send Mini ToDo Event
  
  fields:
    event_type:
      description: The type of event to be sent.
      selector:
        select:
          options:
            - add
            - remove
            - reset
    
    item_type:
      description: The type of periodic item.
      selector:
        select:
          options:
            - cleaning
            - yard_work
            - other
    
    value:
      description: Event data value.
  
  sequence:
    - choose:
      - conditions: "{{ event_type == 'add' }}"
        sequence:
          - choose:
            - conditions: "{{ item_type == 'cleaning' }}"
              sequence:
                - event: add_cleaning_item
                  event_data:
                    value: "{{ value }}"
            
            - conditions: "{{ item_type == 'yard_work' }}"
              sequence:
                - event: add_yard_work_item
                  event_data:
                    value: "{{ value }}"
          
            default:
              - event: add_other_item
                event_data:
                  value: "{{ value }}"
      
      - conditions: "{{ event_type == 'remove' }}"
        sequence:
          - choose:
            - conditions: "{{ item_type == 'cleaning' }}"
              sequence:
                - event: remove_cleaning_item
                  event_data:
                    value: "{{ value }}"
            
            - conditions: "{{ item_type == 'yard_work' }}"
              sequence:
                - event: remove_yard_work_item
                  event_data:
                    value: "{{ value }}"
          
            default:
              - event: remove_other_item
                event_data:
                  value: "{{ value }}"
      
      default:
        - choose:
          - conditions: "{{ item_type == 'cleaning' }}"
            sequence:
              - event: reset_cleaning_items
            
          - conditions: "{{ item_type == 'yard_work' }}"
            sequence:
              - event: reset_yard_work_items
          
          default:
            - event: reset_other_items

# Add any relevant calendar tasks to the mini todo list.
add_mini_todo_calendar_items:
  alias: Add Mini ToDo Calendar Items
  
  fields:
    window_lower_bound:
      description: Daily window lower bound time (HH:MM:SS).
      
    window_upper_bound:
      description: Daily window upper bound time (HH:MM:SS).
      
    start_time:
      description: Calendar start time (yy-mm-dd HH:MM:SS).
      
    end_time:
      description: Calendar end time (yy-mm-dd HH:MM:SS).
  
  sequence:
    
    # Get all events on the calendar for my normal available time period.
    - service: calendar.get_events
      target:
        entity_id: calendar.calendar
      data:
        start_date_time: "{{ start_time }}"
        end_date_time: "{{ end_time }}"
      response_variable: agenda
    
    # If I'm on an extended away, ignore everything.
    - if:
        - condition: state
          entity_id: input_boolean.extended_away_mode
          state: 'on'
      
      then:
        - service: input_number.set_value
          target:
            entity_id: input_number.mini_todo_available_minutes
          data:
            value: 0
      
        - stop: Extended away
        
        # Initialize the calendar all day type.
        - service: input_select.select_option
          target:
            entity_id: input_select.mini_todo_all_day_calendar_type
          data:
            option: none
        
    # Process each calendar event.
    - repeat:
        for_each: "{{ agenda['calendar.calendar'].events }}"
        
        sequence:
          - variables:
              summary: "{{ repeat.item.summary }}"
              extra_minutes: >
                {% if '(appt:' in summary %}
                  {{ (summary.split(':')[-1] | regex_replace("[^A-Za-z0-9]", "")) | int(0) }}
                {% else %}
                  {{ 0 }}
                {% endif %}
              
              start: "{{ as_timestamp(repeat.item.start) - extra_minutes * 60 }}"
              end: "{{ as_timestamp(repeat.item.end) + extra_minutes * 60 }}"
          
          - choose:
            
            # Handle an all day event, which means we won't add much to the mini todo list.
            - conditions: "{{ '(trip)' in summary or '(visit)' in summary }}"
            
              sequence:
                - if:
                    - "{{ (end - start) / 3600 % 24 == 0 }}"
                
                  then:
                    - variables:
                        all_day_type: "{{ iif('(visit)' in summary, 'visit', 'trip') }}"
                        cal_tag: "{{ '(' ~ all_day_type ~ ')' }}"
                    
                    # We need to note what type of all day event this is.
                    - if:
                        - "{{ all_day_type == 'visit' }}"
                      
                      then:
                        - service: input_select.select_option
                          target:
                            entity_id: input_select.mini_todo_all_day_calendar_type
                          data:
                            option: visit
                      
                      else:                    
                        - service: input_select.select_option
                          target:
                            entity_id: input_select.mini_todo_all_day_calendar_type
                          data:
                            option: trip
                    
                    - service: input_number.set_value
                      target:
                        entity_id: input_number.mini_todo_available_minutes
                      data:
                        value: 0
      
                    - event: add_mini_todo_item
                      event_data:
                        value: "{{ 'ca:' ~ summary.split(cal_tag)[0] ~ 'all day' }}"
                    
                    # Bump the tasks counter.
                    - service: counter.increment
                      target:
                        entity_id: counter.mini_todo_tasks
          
            # Handle a normal home or away event.
            - conditions: "{{ '(home)' in summary or '(appt' in summary }}"
            
              sequence:
                - variables:
                    cal_tag: "{{ iif('(home)' in summary, '(home)', '(appt') }}"
                    current_minutes: "{{ states('input_number.mini_todo_available_minutes') | int(0) }}"
                    calculated_minutes: >
                      {% set var = namespace(minutes = (end - start) / 60) %}
                      
                      {# Only count time that falls within the lower bound of the normal hours. #}
                      {% if as_datetime(start) < today_at('10:00:00') %}
                        {% set delta = ((as_timestamp(today_at(window_lower_bound)) - start) / 60) | int(0) %}
                        {% set var.minutes = var.minutes - delta %}
                      
                      {# Only count time that falls within the upper bound of the normal hours. #}
                      {% elif as_datetime(end) > today_at('16:00:00') %}
                        {% set delta = (end - (as_timestamp(today_at(window_upper_bound)))) / 60 | int(0) %}
                        {% set var.minutes = var.minutes - delta %}
                      {% endif %}
                      
                      {{ var.minutes }}
                
                # Subtract the calculated time for this event from the current available time.
                - service: input_number.set_value
                  target:
                    entity_id: input_number.mini_todo_available_minutes
                  data:
                    value: "{{ current_minutes - calculated_minutes }}"
      
                - event: add_mini_todo_item
                  event_data:
                    value: "{{ 'ca:' ~ summary.split(cal_tag)[0] }}"
                    
                # Bump the tasks counter.
                - service: counter.increment
                  target:
                    entity_id: counter.mini_todo_tasks

# Add a project from a (normal) todo list to the mini todo list.
add_mini_todo_project_item:
  alias: Add Mini ToDo Project Item
  
  mode: queued
  
  fields:
    type:
      description: The type of project todo list to query.
      selector:
        select:
          options:
            - minor
            - major
  
  sequence:
    - variables:
        project_todo_list: "{{ 'todo.' ~ type ~ '_projects' }}"
    
    # Get the list of items from the project todo list.
    - service: todo.get_items
      target:
        entity_id: "{{ project_todo_list }}"
      data:
        status: needs_action
      response_variable: mylist

    - variables:
        
        # This is a single project picked at random. First, we grab up to 2 each of internal and external items. These
        # are the highest priority since we're walking through the list from the top. Then, if we found anything, pick
        # one of those at random.
        project: >
          
          {# Initialize variables. #}
          {% set var = namespace(item = '', wtime = 0, time = 0, list = [], in_count = 0, ex_count = 0) %}
          
          {# Loop through the project todo list. #}
          {% for item in mylist[project_todo_list]['items'] %}
            
            {# The item description contains the type (internal or external) and time estimate. #}
            {% set desc = item.description %}
            {% set time = desc.split(', ')[0].split(':')[1] %}
            {% set type = desc.split(', ')[1].split(':')[1] %}
          
            {# Time is specified with a suffix (m, h or d) ... normalize it into minutes. #}
            {% set prefix = time[:((time | length) - 1)] %}
            {% set suffix = time[((time | length) - 1):] %}
            {% if suffix == 'd' %}
              {% set var.wtime = prefix | int(0) * 24 * 60 %}
            {% elif suffix == 'h' %}
              {% set var.wtime = prefix | int(0) * 60 %}
            {% else %}
              {% set var.wtime = prefix %}
            {% endif %}
            
            {# Grab up to 2 external items, but only if it seems OK to work outside. #}
            {% if type == 'external' and states('binary_sensor.outdoor_work_friendly') == 'on' and var.ex_count <= 1 %}
              {% set var.list = var.list + [item.summary ~ ':' ~ var.wtime] %}
              {% set var.ex_count = var.ex_count + 1 %}
            
            {# Grab up to 2 internal items. #}
            {% elif type == 'internal' and var.in_count <= 1 %}
              {% set var.list = var.list + [item.summary ~ ':' ~ var.wtime] %}
              {% set var.in_count = var.in_count + 1 %}
            {% endif %}
            
            {# Quit once we've grabbed 4 items. #}
            {% if var.ex_count + var.in_count >= 4 %}
              {% break %}
            {% endif %}
          {% endfor %}
          
          {# If we found any items to choose from, pick one at random. #}
          {% set len = var.list | length %}
          {% if len > 0 %}
            {% set var.item = var.list[range(len) | random] %}
          {% endif %}
          
          {{ var.item }}
          
    # Did we find anything?
    - if:
        - "{{ project | length > 0 }}"
      
      then:
        - variables:
            summary: "{{ project.split(':')[0] }}"
            value: "{{ type[0:2] ~ ':' ~ summary }}"
            est_minutes: "{{ project.split(':')[1] | int(0) }}"
        
        # Insert the selected item.
        - service: script.insert_mini_todo_item
          data:
            value: "{{ value }}"
            item_time: "{{ est_minutes }}"
            major: "{{ type == 'major' }}"

# Add a periodic task (cleaning, yard work, other) to the mini todo list. These are based on reminder datetimes, 
# and set up by the Generate Weekly Periodic List script above.
add_mini_todo_periodic_item:
  alias: Add Mini ToDo Periodic Item
  
  mode: queued
  
  fields:
    type:
      description: The type of periodic list sensor to use.
      selector:
        select:
          options:
            - cleaning
            - yard_work
            - other
  
  sequence:
    - variables:
        list_sensor: "{{ 'sensor.mini_todo_weekly_' ~ type ~ '_list' }}"
        list: "{{ state_attr(list_sensor, 'items') }}"

    # Does anything exist in the list?
    - if:
        - "{{ list | length > 0 }}"
    
      then:
        - variables:
            
            # Pick a random item from the list.
            item: "{{ list[range(0, list | length) | random] }}"
            
            # Extract the estimated time from the item. For the cleaning type, this is a list of 2 values for certain rooms: 
            # normal and deep clean times. All other rooms contain just the normal time as a single value.
            times_variable: "{{ 'mini_todo_' ~ type ~ '_times' }}"
            name: "{{ item.split(':')[1] }}"
            time: "{{ state_attr('sensor.variables', 'variables')[times_variable][name] }}"
            time_is_list: "{{ iif(time is list, true, false) }}"
            
            # For deep clean rooms, determine if the last deep clean was six months ago or more.
            deep_clean: >
              {% if time_is_list %}
                {% set last_deep_clean = states('input_datetime.last_deep_clean_' ~ name.replace(' ', '_') | lower) %}
                {% set delta_seconds = as_timestamp(now()) - as_timestamp(last_deep_clean) %}
                {% if delta_seconds / 3600 / 24 / 30.4167 >= 6 %}
                  true
                {% else %}
                  false
                {% endif %}
              {% else %}
                false
              {% endif %}
            
            # Use the normal or deep clean time as appropriate.
            est_minutes: >
              {% if time_is_list %}
                {% if deep_clean == true %}
                  {% set minutes = time | sum %}
                {% else %}
                  {% set minutes = time[0] %}
                {% endif %}
              {% else %}
                {% set minutes = time %}
              {% endif %}
              {{ minutes }}
            
            # Determine if it's OK to pick yard work items.
            outdoor_friendly: "{{ states('binary_sensor.outdoor_work_friendly') }}"
        
        # Insert the selected item, but skip yard work if it's not OK to work outside.
        - if:
            - "{{ type != 'yard_work' or outdoor_friendly == 'on' }}"
          
          then:
            - variables:
                
                # Indicate a deep clean item if appropriate.
                item: "{{ iif(deep_clean == true, item ~ ' (deep)', item) }}"
            
            - action: script.insert_mini_todo_item
              data:
                value: "{{ item }}"
                item_time: "{{ est_minutes }}"
                major: false

# Insert a selected item into the mini todo list. This is called by all the scripts that handle mini todo items, except
# Add Mini ToDo Calendar Items. Here we ensure the item is unique and that it fits in the available time. We also
# update the Mini ToDo Attempts counter to prevent an infinite loop in the Create Daily Mini ToDo List automation.
insert_mini_todo_item:
  alias: Insert Mini ToDo Item
  
  mode: queued
  
  fields:
    value:
      description: The item to be inserted.
    
    item_time:
      description: The amount of time the item consumes.
    
    major:
      description: True if this is a major item; these can be worked on in pieces - for example it can take days to complete.
  
  sequence:
    - variables:
        current_minutes: "{{ states('input_number.mini_todo_available_minutes') | int(0) }}"
        major_item: "{{ states('input_boolean.mini_todo_major_item_added') == 'off' and major == true and current_minutes >= 30 }}"
        tag: "{{ value.split(':')[0] }}"
        tag_allowed: >
          {% set var = namespace(allowed = true) %}
          {% set single_tags = ['yt', 'ys'] %}
          {% for item in state_attr('sensor.daily_mini_todo_list', 'items') %}
            {% set item_tag = item.split(':')[0] %}
            {% if(item_tag in single_tags and tag == item_tag) %}
              {% set var.allowed = false %}
            {% endif %}
          {% endfor %}
          {{ var.allowed }}
                    
    # Bump the attempts counter.
    - service: counter.increment
      target:
        entity_id: counter.mini_todo_attempts
        
    # Ensure this item is unique. Also, for certain types of items, we only want one max per day.
    - condition: template
      value_template: "{{ value not in state_attr('sensor.daily_mini_todo_list', 'items') and tag_allowed }}"
        
    # Add the selected item if it fits, or is major (with a minimum time limit).
    - if:
        - "{{ item_time <= current_minutes or major_item == true }}"
        
      then:
        - event: add_mini_todo_item
          event_data:
            value: "{{ value }}"
                    
        # Bump the tasks counter.
        - service: counter.increment
          target:
            entity_id: counter.mini_todo_tasks
                        
        # Subtract the estimated time for this event from the current available time.
        - service: input_number.set_value
          target:
            entity_id: input_number.mini_todo_available_minutes
          data:
            value: "{{ current_minutes - item_time }}"
        
        # Turn on the major item added toggle if we just added one.
        - if:
            - "{{ major_item }}"
          
          then:
            - service: input_boolean.turn_off
              data:
                entity_id: input_boolean.mini_todo_major_item_added
            

#===================#
#     Utilities     #
#===================#

# Concatenate a set of backup log files into one file for easier examination.
concat_log_files:
  alias: Concat Log Files
  sequence:
    - service: shell_command.concat_log_files

# Concatenate a set of automation/script log files into one file for easier examination.
concat_auto_scripts_log_files:
  alias: Concat Auto Scripts Log Files
  sequence:
    - service: shell_command.concat_auto_scripts_log_files

#===================#
#     Reminders     #
#===================#

# Front end to the various scripts below that set offset values in datetimes and numbers. This is called when any button on the 
# reminder dashboard is long pressed (meaning reset the item for the next interval). This happens in the next_event decluttering
# template, which is used by all the buttons on the reminder dashboard.
#
# Note that some of the items on the reminder dashboard are part of the reminder infrastructure. This sends a reminder to my phone
# when an item is due; the reminder is removed when the corresponding dashboard button is pressed, but that is handled elsewhere.
# Other items on the dashboard are part of the mini-todo list infrastructure. This places items on the daily mini-todo list, without
# a phone notification. In both cases we need to bump the datetime/number offset for the next interval, but for the mini-todo list
# we also need to remove a completed item from the appropriate weekly list that is generated on Sundays. If we don't, then we can
# get duplicate items on the mini-todo list during the week, since it uses the weekly list as input. Hope this makes sense.
handle_completed_reminder_or_periodic_item:
  alias: Handle Completed Reminder Or Periodic Item
  
  fields:
    entity:
      description: The entity that represents the interval for the completed item.
      selector:
        entity:
          domain:
            - input_datetime
            - input_number
    
    base_entity:
      description: The base entity to which the amount should be added. Only used when the input entity is a number.
      selector:
        entity:
          domain: input_number
    
    interval:
      description: The number of units defined by the input period.
      selector:
        number:
          min: 1
          max: 100000
    
    period:
      description: The interval period. Note that these can be singular or plural.
      selector:
        select:
          options:
            - days
            - weeks
            - months
            - miles
            - hours
    
    target_day:
      description: Target day of the month. If zero, new day is calculated based on current day + amount.
      selector:
        number:
          min: 0
          max: 31
    
    deep_clean:
      description: Whether or not a deep clean was performed for a cleaning item.
      selector:
        boolean:
  
  sequence:
    - variables:
        normalized_period: "{{ iif(period[-1] != 's', period ~ 's', period) }}"
        domain: "{{ states[entity].domain }}"
        entity_name: "{{ entity.split('.')[-1] }}"
        
        # This is the input to the datetime offset script. For days and weeks offsets it includes just the datetime entity
        # and the amount. But for months offset it also includes a target day. This allows us to set the next interval
        # using 2 methods:
        #
        # 1) Target day = 0: This is the normal method, where the next interval is the same day of the month as today, in
        #    the month determined by the input amount.
        # 2) Target day != 0: This is used for things we want to happen on a specific day of the month, such as the first.
        #    So if we execute the item say, on the ninth of the month because we're lazy, the next interval will be the first
        #    (or whatever target day) of the month determined by the input amount.
        datetime_offset_data: >
          {% set ns = namespace(val = {'entity': entity, 'amount': interval}) %}
          {% if normalized_period == 'months' %}
            {% set day = {'target_day': target_day} %}
            {{ dict(ns.val, **day) }}
          {% else %}
            {{ ns.val }}
          {% endif %}
    
    # Call one of the datetime offset scripts (per the period), or the number offset script.
    - if:
        - "{{ domain == 'input_datetime' }}"
      
      then:
        - action: "{{ 'script.set_datetime_offset_' ~ normalized_period }}"
          data: "{{ datetime_offset_data }}"
      
      else:
        - action: script.set_number_offset
          data:
            entity: "{{ entity }}"
            base_entity: "{{ base_entity }}"
            amount: "{{ interval }}"
    
    # If the input is a periodic item, remove it from the appropriate weekly sensor if it exists.
    - if:
        - "{{ iif(entity_name.split('_')[0] == 'periodic', true, false) }}"
      
      then:
        - variables:
            name_type: "{{ entity_name.split('_')[1] }}"
            type: "{{ iif(name_type == 'yard', 'yard_work', name_type) }}"
            category: "{{ entity_name.split('_')[2] }}"
            list_entity: "{{ 'sensor.mini_todo_weekly_' ~ type ~ '_list' }}"
            icon_tag: >
              {% if name_type == 'cleaning' %}
                cl:
              {% elif name_type == 'yard' %}
                {{ iif(category == 'spray', 'ys:', iif(category == 'trim', 'yt:', 'ym:')) }}
              {% else %}
                ot:
              {% endif %}
            item_name: "{{ icon_tag ~ state_attr(entity, 'friendly_name') | replace('Periodic ' ~ name_type | title ~ ' ', '') }}"
        
        # Remove the item from the weekly sensor.
        - if:
            - "{{ item_name in state_attr(list_entity, 'items') }}"
          
          then:        
            - action: script.send_mini_todo_event
              data:
                event_type: remove
                item_type: "{{ type }}"
                value: "{{ item_name }}"
        
        # If we just performed a deep clean on a room, update the last deep clean timestamp.
        - if:
            - "{{ deep_clean == true }}"
          
          then:
            - action: input_datetime.set_datetime
              target:
                entity_id: input_datetime.last_deep_clean_{{ entity_name.replace('periodic_cleaning_', '') }}
              data:
                timestamp: "{{ now().timestamp() }}"
    
# Set an input datetime entity with an offset in days.
set_datetime_offset_days:
  alias: Set Datetime Offset Days
  
  fields:
    entity:
      description: The entity to be updated.
      selector:
        entity:
          domain: input_datetime
    
    amount:
      description: The amount by which to update the entity.
      selector:
        number:
          min: 1
          max: 100
  
  sequence:
    - service: input_datetime.set_datetime
      data:
        entity_id: "{{ entity }}"
        datetime: "{{ now().today().replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days = amount) }}"

# Set an input datetime entity with an offset in weeks.
set_datetime_offset_weeks:
  alias: Set Datetime Offset Weeks
  
  fields:
    entity:
      description: The entity to be updated.
      selector:
        entity:
          domain: input_datetime
    
    amount:
      description: The amount by which to update the entity.
      selector:
        number:
          min: 1
          max: 52
  
  sequence:
    - service: input_datetime.set_datetime
      data:
        entity_id: "{{ entity }}"
        datetime: "{{ now().today().replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(weeks = amount) }}"

# Set an input datetime entity with an offset in months.
set_datetime_offset_months:
  alias: Set Datetime Offset Months
  
  fields:
    entity:
      description: The entity to be updated.
      selector:
        entity:
          domain: input_datetime
    
    amount:
      description: The amount by which to update the entity.
      selector:
        number:
          min: 1
          max: 24
    
    target_day:
      description: Target day of the month. If zero, new day is calculated based on current day + amount.
      selector:
        number:
          min: 0
          max: 31
  
  sequence:
    - service: input_datetime.set_datetime
      data:
        entity_id: '{{ entity }}'
        datetime: >
          {% set dtobj=now().today().replace(hour=0, minute=0, second=0, microsecond=0) %} 
          {% set sub_months=((dtobj.year * 12) + (dtobj.month + amount - 1)) %}
          {% set new_months=((sub_months) % 12) + 1 %}
          {% set new_year=((sub_months - new_months + 1) / 12) | int(0) %}
          {% set new_day = dtobj.day %}
          {% if target_day != 0 %}
            {% set new_day = target_day %}
          {% elif new_day == 31 and new_months in [9, 4, 6, 11] or new_months == 2 and new_day > 28 %}
            {% set new_months = new_months + 1 %}
            {% set new_day = 1 %}
          {% endif %}
          {{ dtobj.replace(day=new_day, month=new_months, year=new_year) }}

# Set an input number entity with an offset value.
set_number_offset:
  alias: Set Number Offset
  
  fields:
    entity:
      description: The entity to be updated.
      selector:
        entity:
          domain: input_number
    
    base_entity:
      description: The base entity to which the amount should be added.
      selector:
        entity:
          domain: input_number
    
    amount:
      description: The amount by which to update the entity.
      selector:
        number:
          min: 1
          max: 6000
  
  sequence:
    - service: input_number.set_value
      data:
        entity_id: "{{ entity }}"
        value: "{{ states(base_entity) | int(0) + amount }}"

#========================#
#     MQTT Discovery     #
#========================#

# Publish state & attributes for MQTT last changed sensors.
publish_mqtt_automated_states:
  alias: Publish MQTT Automated States
  mode: parallel
  
  fields: 
    <<: &mqtt_fields
      domain:
        description: The entity domain.
        selector:
          text:
            type: text
      
      unique_id:
        description: The entity ID.
        selector:
          text:
            type: text
    
    state:
      description: The entity state.
      selector:
        text:
          type: text
    
    attributes:
      description: The entity attributes.
      example: A dictionary {} in yaml
      selector:
        object:
  
  variables: 
    <<: &mqtt_variables
      root: "homeassistant"
      
      topic_root: >
        {%- if domain is not defined or unique_id is not defined %}
          {{- [ root, 'error'] | join('/') }}
        {%- else %}
          {{- [ root, domain, unique_id ] | join('/') }}
        {%- endif %}
    
    service_data: >
      {{ {
        'topic': topic_root ~ '/state',
        'payload': '' ~ { 'state': state, 'attributes': attributes | default({}) } | tojson,
        'retain': retain | default('true')
      } }}

  sequence:
    - service: mqtt.publish
      data: "{{ service_data }}"
  
    - service: system_log.write
      data:
        message: "Publish MQTT state: {{ service_data }}"
        level: debug

# Set up MQTT discovery sensors to keep track of the last changed time for interesting entities.
set_up_mqtt_automated_config:
  alias: Set Up MQTT Automated Config
  mode: parallel
  
  fields: 
    <<: *mqtt_fields
    device_class: 
      description: The entity device class.
      selector:
        text:
          type: text
  
  variables:
    name: >
      {{ unique_id | default('') | replace('_', ' ') | title }}
    
    <<: *mqtt_variables
    
    service_data: >
      {%- set items = [
        ( "name", name),
        ( "unique_id", unique_id | default(none)),
        ( "state_topic", topic_root ~ "/state"),
        ( "value_template", "{{ value_json.state }}"),
        ( "json_attributes_topic", topic_root ~ "/state"),
        ( "json_attributes_template", "{{ value_json.attributes | tojson }}"),
        ( "device_class", device_class | default(none) ),
      ] %}
      {% set payload = dict.from_keys(items | rejectattr('1', 'none') | list) %}
      {{ {
        'topic': topic_root ~ '/config',
        'payload': '' ~ payload | tojson,
      } }}
  
  sequence:
    - service: mqtt.publish
      data: "{{ service_data }}"

#=======================#
#     Debug Logging     #
#=======================#

# Log laundry events to assist with debugging.
log_laundry_event:
  alias: Log Laundry Event
  
  mode: queued
  
  fields:
    event_type:
      description: The type of event to be logged.
      selector:
        select:
          options:
            - basic
            - metric
            - fill_plus_load
            - timer
    
    prefix:
      description: The message prefix that indicates a washer or dryer event.
    
    message:
      description: The message to be logged.
    
    entity_id_1:
      description: The first entity required (if any) for the message.
    
    entity_id_2:
      description: The second entity required (if any) for the message.
  
  sequence:
    - variables:
        timestamp: "{{ as_timestamp(now()) | timestamp_custom('%b %d %Y %X') }}:"
    
    # Take action based on the event type.
    - choose:
      
      # A basic message just has a text component.
      - conditions: "{{ event_type == 'basic' }}"
        
        sequence:
          - action: notify.send_message
            target:
              entity_id: notify.laundry_events
            data:
              message: "{{ timestamp }} {{ prefix }} {{ message }}"
          
          # Write a separator in the log for stopped messages.
          - if:
              - "{{ message == 'stopped' }}"
            
            then:
              - action: notify.send_message
                target:
                  entity_id: notify.laundry_events
                data:
                  message: '--------------------'
    
      # A metric message adds a single metric, such as a temperature or humidity.
      - conditions: "{{ event_type == 'metric' }}"
        
        sequence:
          - action: notify.send_message
            target:
              entity_id: notify.laundry_events
            data:
              message: "{{ timestamp }} {{ prefix }} {{ message }} ({{ states(entity_id_1) }})"
    
      # A fill plus load message includes both the washer fill seconds and calculated load size.
      - conditions: "{{ event_type == 'fill_plus_load' }}"
        
        sequence:
          - action: notify.send_message
            target:
              entity_id: notify.laundry_events
            data:
              message: "{{ timestamp }} {{ prefix }} {{ message }}: {{ states(entity_id_1) }}, {{ states(entity_id_2) }}"
    
      # A timer message indicates the name of the timer.
      - conditions: "{{ event_type == 'timer' }}"
        
        sequence:
          - action: notify.send_message
            target:
              entity_id: notify.laundry_events
            data:
              message: "{{ timestamp }} {{ prefix }} {{ message }}: {{ state_attr(entity_id_1, 'friendly_name') }}"
            
      # Should not occur.
      default:
          
        - action: system_log.write
          data:
            message: "Event type invalid value ({{ event_type }})"
            level: error

#============================#
#     Reminder Lookahead     #
#============================#

gather_upcoming_reminders:
  alias: Gather Upcoming Reminders
  
  variables:
    
    # List of all reminder datetimes of interest.
    reminder_dates: >
      {% set reminder_dates = [
                               'input_datetime.reminder_payment_amazon',
                               'input_datetime.reminder_payment_creditunion',
                               'input_datetime.reminder_payment_disney',
                               'input_datetime.reminder_payment_mortgage',
                               'input_datetime.reminder_payment_randolph',
                               'input_datetime.reminder_medication_eliquis',
                               'input_datetime.reminder_medication_metoprolol',
                               'input_datetime.reminder_medication_rosuvastatin'
                              ] %}
       
       {{ reminder_dates }}
  
  sequence:
          
    # Set the appropriate items in the result dropdown.
    - action: input_select.set_options
      target:
        entity_id: input_select.reminder_lookahead_items
      data:
        options: >
          {% set vars = namespace(items = []) %}
          {% set days = (states('input_number.reminder_lookahead_days') | int(0)) %}
          
          {% if days > 0 %}
            {% for date in reminder_dates %}
              {% if (now().date() + timedelta(days=days)) | string >= states(date) %}
                {% set vars.items = vars.items + [ state_attr(date, 'friendly_name') ]  %}
              {% endif %}
            {% endfor %}
          
          {% else %}
            {% set vars.items = vars.items + [ 'Empty' ]  %}
          {% endif %}
          
          {{ vars.items }}

#=======================#
#     Exercise Days     #
#=======================#

modify_current_exercise_day:
  alias: Modify Current Exercise Day
  
  fields:
    exercise_types:
      description: List of exercise types.
    
    operation:
      description: True to set the current day, false to reset it.
      selector:
        boolean:
  
  sequence:
    
    - variables:
        
        # The day of the week as a number (0 = Sunday, 6 = Saturday).
        day_of_week: "{{ as_timestamp(now()) | timestamp_custom('%w') | int(0) }}"
    
    # Modify the exercise flags for the current day.    
    - repeat:
        for_each: "{{ exercise_types }}"
        
        sequence:
          - variables:
              
              # This is the bitmask for a given exercise type, where the least significant bit is Sunday.
              days_entity: "{{ 'input_number.' ~ repeat.item ~ '_days' }}"
          
          # Setting the day is easy: just turn on the appropriate bit in the bitmask.
          # For a reset we need a mask that contains all bits on except the one we are going to turn off.
          - service: input_number.set_value
            target:
              entity_id: "{{ days_entity }}"
            data:
              value: >
                {% if operation == true %}
                  {% set current = states(days_entity) | int() %}
                  {% set day_on = 2 ** day_of_week %}
                  {{ current | bitwise_or(day_on) }}
                {% else %}
                  {% set current = states(days_entity) | int() %}
                  {% set day_off = (127 - (2 ** day_of_week)) %}
                  {{ current | bitwise_and(day_off) }}
                {% endif %}
