#===========================#
#     Cinema Activation     #
#===========================#

# There are several ways to use the cinema:
#
# 1) Open for general usage
# 2) Play a feature movie
# 3) Play a random set of music videos
# 4) Start a specific Harmony activity
# 5) Watch a specific Shield TV app
#
# It is possible to use these in various combinations; a few examples:
#
# - open, watch an app, watch another app, ...
# - open, play a feature movie
# - open, start an activity, watch an app, watch videos
#
# So we need a generic script that is a front end to all of these. It needs to do the following:
#
# - Enforce cinema usage control, to prevent rapid open/close activity.
# - Turn on the desired Harmony activity, which ensures the correct devices are turned on.
# - Wait for the projector to warm up if needed.
# - Activate the Kodi app if needed.
# - Perform post-open tasks if needed.

activate_cinema:
  alias: Activate Cinema
  
  fields:
    activity:
      description: The desired Harmony activity name.
    
    need_kodi:
      description: True if we need to start the Kodi app.
  
  variables:
    cinema_off_upon_entry: "{{ states('sensor.harmony_hub') == 'PowerOff' }}"
    plugs: "{{ label_entities('theater_off') }}"
    num_plugs: "{{ plugs | length }}"
  
  sequence:
    
    # Ensure the cinema has not been closed recently, if it was off upon entry.
    - if:
        - "{{ cinema_off_upon_entry }}"
    
      then:
        - action: script.check_cinema_usage_control
          data:
            opening: true
        
        - if:
            - condition: state
              entity_id: input_boolean.cinema_usage_allowed
              state: 'off'
          
          then:
            - stop: "Cinema usage is denied."
  
    # Turn off the projector error handling flag, in case it was left on from a previous unsuccessful attempt to fix it 
    # automatically.
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.projector_error_handling
        
    # Turn on plugs needed for some equipment. Other equipment plugs are turned on every day at wakeup time.
    - action: switch.turn_on
      target:
        entity_id: "{{ plugs }}"
    
    # Wait a bit for the plugs to turn on before starting the Harmony activity. Quit if they don't.
    - wait_template: >
        {% set var = namespace(results = []) %}
        {% for plug in plugs %}
        {% if states(plug) == 'on' %}
        {% set var.results = var.results + [true] %}
        {% endif %}
        {% endfor %}
        {{ var.results | length == num_plugs }}
    
      timeout: '00:01:00'
    
    - if:
        "{{ wait.completed == false }}"
      
      then:
        - stop: "Cinema plugs failed to turn on."
    
    # Start the input Harmony activity, which ensures the correct devices are on.
    # However, if Enable Streaming is requested but the cinema is currently on, then use the Stream Player
    # activity instead. The only difference between those activities is the receiver input (CD for 
    # Enable Streaming and CBL/SAT for Stream Player). This allows us to keep the screen dark when the
    # cinema is first opened, but not switch inputs if it's already open. I probably haven't explained
    # this very well. Sorry.
    - if:
        - "{{ activity == 'Enable Streaming' and not cinema_off_upon_entry }}"
    
      then:
    
        - action: remote.turn_on
          entity_id: remote.harmony_hub
          data:
            activity: Stream Player
      
      else:
        - action: remote.turn_on
          entity_id: remote.harmony_hub
          data:
            activity: "{{ activity }}"
  
    # Do a few things if the cinema was off upon entry.
    - if:
        - "{{ cinema_off_upon_entry }}"
    
      then:
        
        # Indicate the cinema is open.
        - action: input_boolean.turn_on
          entity_id: input_boolean.theater_open
    
        # Turn on some lights.
        - action: script.set_theater_idle
          data:
            operation: activation
    
        # Announce the grand opening.
        - action: script.send_notification
          data:
            destination:
              - voice_assistant
            message: >
              {{ ["I'm waiting a bit for the projector to warm up.", 
                  "You have a minute or so before the theater is ready.", 
                  "I'll let you know when things are ready.",
                  "Hopefully the projector won't explode. Stay tuned.",
                  "Lights are on, just waiting on the projection equipment.",
                  "Loading the film canister now.",
                  "Theater is waking up.",
                  "Popcorn is popping. Cokes are bubbling. Grab a seat and relax.",
                  "I'm flipping on all the switches. Hope that works.",
                  "What's this big red button do? Let's find out!"
                 ] | random }}
            speak: excited
            room: ['family_room', 'theater']
            voice_type: tts
      
        # Define a few variables for debugging (they can be seen in the trace).
        - variables:
            projector_state: "{{ states('media_player.epson_projector') }}"
            projector_error: "{{ states('input_boolean.projector_error_handling') }}"
            projector_active: "{{ states('input_boolean.projector_active') }}"
        
        # Start a timer to wait for the projector to be functional. The timeout is long in case a projector error is detected; 
        # it takes several minutes to attempt a fix (see the Handle Projector Error automation).
        - action: timer.start
          data:
            entity_id: timer.projector_status
            duration:
              minutes: 10
  
    # Activate Kodi if requested.
    - if:
        - "{{ need_kodi }}"
    
      then:        
        - action: script.activate_kodi

#==========================================#
#     1) Open Cinema For General Usage     #
#==========================================#

open_cinema:
  alias: Open Cinema
  
  sequence:
    
    # Activate the cinema.
    - service: script.activate_cinema
      data:
        activity: Open Cinema
        need_kodi: false
    
    - if:
        - condition: state
          entity_id: input_boolean.cinema_usage_allowed
          state: 'off'
      
      then:
        - stop: "Cinema usage is denied."

#===============================#
#     2) Play Feature Movie     #
#===============================#

# This proceeds as follows:
#
# 1) This script activates the cinema and calls Kodi with the GetMovies command.
# 2) The Process Kodi Command Result automation runs with either a successful or unsuccessful result.
# 3) Process Kodi Command Result calls the Process Single Kodi Movie Result script for success; an error is simply logged.
# 4) Process Single Kodi Movie Result attempts to build a short playlist of music videos using the Get All Kodi Videos script... see the 
#    description of '3) Play Random Music Videos' for details.
# 5) If the video playlist was built, the movie is appended to the playlist and the playlist is played; if not the movie alone is played.

play_feature_movie:
  alias: Play Feature Movie
  
  sequence:
    
    # Activate the cinema.
    - service: script.activate_cinema
      data:
        activity: Enable Streaming
        need_kodi: true
    
    - if:
        - condition: state
          entity_id: input_boolean.cinema_usage_allowed
          state: 'off'
      
      then:
        - stop: "Cinema usage is denied."
  
    # Send the GetMovies command to Kodi, with the target movie name. The Handle Kodi Movies Result script calls 
    # Process Single Kodi Movie Result below with the command result.
    - service: kodi.call_method
      data:
        entity_id: media_player.kodi
        method: VideoLibrary.GetMovies
        filter:
          field: title
          operator: is
          value: "{{ states('input_select.kodi_movies') }}"
        limits:
          end: 1
          start: 0

# Process the single movie returned by Kodi.
process_single_kodi_movie_result:
  alias: Process Single Kodi Movie Result
  
  fields:
    result:
      description: The result from the GetMovies Kodi call.
  
  sequence:
    
    # Pick up the movie ID.
    - variables:
        movieid: "{{ result.movies.0.movieid }}"
    
    # Indicate to Process Kodi Videos Result to build a short list of videos.
    - action: input_select.select_option
      target:
        entity_id: input_select.kodi_videos_type
      data:
        option: 'short'
    
    # Build a set of random music videos as a preamble to the movie. These are added to a playlist.
    # There is a chance this could fail, in which case we just play the movie.
    - action: script.get_all_kodi_videos
      response_variable: result
    
    - variables:
        include_videos: "{{ result.result == 'success' }}"
    
    # If success then add the movie to the end of the playlist.
    - if:
        - "{{ include_videos }}"
      
      then:
              
        # Add the movie to the playlist.
        - action: kodi.call_method
          target:
            entity_id: media_player.kodi
          data:
            method: Playlist.Add
            playlistid: 1
            item:
              movieid: "{{ movieid }}"
      
      # Just log an error.
      else:
        - action: system_log.write
          data:
            message: 'Kodi videos could not be retrieved.'
            level: warning
  
    # Now switch the receiver to the proper input so Kodi can be viewed on screen.
    - action: remote.send_command
      entity_id: remote.harmony_hub
      data:
        command: 'InputCbl/Sat'
        device: Marantz Receiver
  
    # Play either the playlist or the single movie.
    - if:
        - "{{ include_videos }}"
      
      then:
        - action: script.play_kodi_playlist
      
      else:
        - action: kodi.call_method
          data_template:
            entity_id: media_player.kodi
            method: Player.Open
            item:
              movieid: "{{ movieid }}"
  
    # Darken the theater.
    - action: script.turn_on
      entity_id: script.set_theater_dark_delay

#=====================================#
#     3) Play Random Music Videos     #
#=====================================#

# This proceeds as follows:
#
# 1) This script activates the cinema and calls the Get All Kodi Videos script.
# 2) Get All Kodi Videos calls Kodi with the GetMusicVideos command, and waits for a playlist to be built or an error.
# 2) The Process Kodi Command Result automation runs with either a successful or unsuccessful result.
# 3) Process Kodi Command Result calls the Process Kodi Videos Result script for success; an error is simply logged.
# 4) Process Kodi Videos Result attempts to build a long playlist of music videos; if successful this script plays the
#    resulting playlist.

# Play random videos using Kodi. This is intended to be run standalone. Playing videos as a preamble to a movie
# uses some of the same technology, but is part of the Play Feature Movie script.
play_random_kodi_videos:
  alias: Play Random Kodi Videos
  
  sequence:
    
    # Activate the cinema.
    - action: script.activate_cinema
      data:
        activity: Enable Streaming
        need_kodi: true
    
    - if:
        - condition: state
          entity_id: input_boolean.cinema_usage_allowed
          state: 'off'
      
      then:
        - stop: "Cinema usage is denied."
    
    # Indicate to Process Kodi Videos Result to build a long list of videos.
    - action: input_select.select_option
      target:
        entity_id: input_select.kodi_videos_type
      data:
        option: 'long'

    # Build a set of random music videos. These are added to a playlist.
    - action: script.get_all_kodi_videos
      response_variable: result
    
    # If we failed, announce it and quit.
    - if:
        - "{{ result.result == 'failure' }}"
      
      then:
        - action: script.send_notification
          data:
            destination:
              - voice_assistant
            message: "I'm sorry, but Kodi videos could not be retrieved."
            room: ['family_room', 'theater']
            voice_type: announce
    
        - stop: 'Kodi videos could not be retrieved'
  
    # Now switch the receiver to the proper input so Kodi can be viewed on screen.
    - action: remote.send_command
      entity_id: remote.harmony_hub
      data:
        command: 'InputCbl/Sat'
        device: Marantz Receiver
        
    # Play the playlist.
    - action: script.play_kodi_playlist
  
    # Darken the theater.
    - action: script.turn_on
      entity_id: script.set_theater_dark_delay

#====================================#
#     4) Start Harmony Activity      #
#====================================#

# Shield TV (streaming)
start_streaming:
  alias: Start Streaming
  
  use_blueprint:
    path: theater/start_harmony_activity.yaml
    input:
      activity: Stream Player
      lighting: script.set_theater_dark_delay

# Blu-ray
start_bluray:
  alias: Start Bluray
  
  use_blueprint:
    path: theater/start_harmony_activity.yaml
    input:
      activity: BD Player
      lighting: script.set_theater_dark_delay

# Laserdisc
start_laserdisc:
  alias: Start Laserdisc
  
  use_blueprint:
    path: theater/start_harmony_activity.yaml
    input:
      activity: LD Player
      lighting: script.set_theater_dark_delay

# Turntable
start_turntable:
  alias: Start Turntable
  
  use_blueprint:
    path: theater/start_harmony_activity.yaml
    input:
      activity: LP Player
      lighting: script.set_theater_dim

#=================================#
#     5) Watch Shield TV App      #
#=================================#

# Amazon Prime
watch_amazon_prime:
  alias: Watch Amazon Prime
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Amazon Prime

# AMC Plus
watch_amc_plus:
  alias: Watch AMC Plus
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: AMC+

# Disney Plus
watch_disney_plus:
  alias: Watch Disney Plus
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Disney+

# Hulu
watch_hulu:
  alias: Watch Hulu
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Hulu

# Kodi
watch_kodi:
  alias: Watch Kodi
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Kodi

# Max
watch_max:
  alias: Watch Max
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: HBO Max

# Netflix
watch_netflix:
  alias: Watch Netflix
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Netflix

# Paramount Plus
watch_paramount_plus:
  alias: Watch Paramount Plus
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Paramount+

# Peacock
watch_peacock:
  alias: Watch Peacock
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Peacock

# Youtube TV
watch_youtube_tv:
  alias: Watch Youtube TV
  
  use_blueprint:
    path: theater/watch_shield_tv_app.yaml
    input:
      appl_name: Youtube TV

#=======================#
#     Cinema Close      #
#=======================#

# Close the cinema by turning off the current harmony activity, and relevant lights after a delay.
#
# NOTE: We're also called by the close_cinema automation ... some steps taken here are superfluous
#       in that context, such as turning the remote off, but should do no harm.
close_cinema:
  alias: Close Cinema
  
  sequence:
    
    # Ensure the cinema is not already closed, and has not been opened recently.
    - action: script.check_cinema_usage_control
      data:
        opening: false
    
    - if:
        - condition: state
          entity_id: input_boolean.cinema_usage_allowed
          state: 'off'
      
      then:
        - stop: "Cinema usage is denied."
        
    # Indicate the cinema is closed.    
    - action: input_boolean.turn_off
      entity_id: input_boolean.theater_open
    
    # Set the usage control timestamp.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.cinema_usage_control
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Turn on some lights. This also turns on automations/lights that were possibly turned off by the open cinema script.
    - action: script.set_theater_idle
      data:
        operation: close
    
    # Turn off all devices.
    - delay: '00:00:02'
    
    - action: remote.turn_off
      entity_id: remote.harmony_hub
    
    # If the penthouse is not occupied, set the upstairs Ecobee to away or sleep mode, depending on the time of day.
    - if:
        - condition: state
          entity_id: binary_sensor.penthouse_occupied
          state: 'off'
        
      then:
        - variables:
            
            # Pick the right preset mode depending on the time.
            preset_mode: >
              {% set tod = states('sensor.time') %}
              {% set hour = tod.split(':')[0] | int(0) %}
              {% set minute = tod.split(':')[1] | int(0) %}
              {% set minutes = (hour * 60) + minute %}
              {{ iif(minutes >= 1110 or minutes <= 420, 'sleep', 'away') }}
            
        - action: script.set_thermostat_preset
          data:
            thermostat_entity: climate.upstairs
            preset: "{{ preset_mode }}"
    
    # Turn on the upstairs ecobee minimum fan time.
    # NOTE: The time amount should be coordinated with the ecobee system settings, using the app or the thermostat.
    - action: ecobee.set_fan_min_on_time
      data:
        entity_id: climate.upstairs
        fan_min_on_time: 5
    
    # Delay for a bit.
    - delay: '00:05:00'
    
    # Turn off theater lights.
    - action: script.set_theater_dark
    
    # Turn off some downstairs lights.
    - action: script.change_downstairs_lighting
      data:
        operation: post_close

#====================================#
#     Cinema Open/Close Control      #
#====================================#

# We don't want to allow operation if the cinema has been closed or opened within a few minutes ago, as this might cause
# undue wear and tear on the projector.
check_cinema_usage_control:
  alias: Check Cinema Usage Control
  
  fields:
    opening:
      description: True if the cinema is being opened, false if it's being closed.
      selector:
        boolean:
  
  variables:
    message_state1: "{{ iif(opening == true, 'closed', 'opened') }}"
    message_state2: "{{ iif(opening == true, 'open', 'close') }}"
    
    # Elapsed time in seconds since the last open or close.
    delta_time: >
      {% set start = as_timestamp(strptime(states('input_datetime.cinema_usage_control'), '%Y-%m-%d %H:%M:%S')) %}
      {% set seconds = (now().timestamp() - start) %}
      {{ seconds }}
    
    # Time in seconds we must wait between open and close or vice versa.
    delay_time: 300
    
    # Time in seconds to delay the requested open or close.
    delay: "{{ (delay_time - delta_time) | round(0, 'ceil') }}"
  
  sequence:
    
    # Ensure the cinema has not been used recently. I don't want to jerk the projector around.    
    - if:
        - "{{ delta_time | float(0) < delay_time }}"
      
      then:
        
        # Turn off the allowed toggle.
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.cinema_usage_allowed
        
        # Bypass the message and timer start if the timer is already running. Someone is being a jerk.
        - if:
            - "{{ is_state('timer.cinema_usage_delay', 'idle') }}"
          
          then:
            - action: script.send_notification
              data:
                destination:
                  - voice_assistant
                message: >
                  {% set delay_minutes = (delay / 60) | round %}
                  {% set delay_display = iif(delay_minutes >= 1, delay_minutes, 1) %}
                  {{ 'Cinema has been ' ~ message_state1 ~ ' recently. Delaying cinema ' ~ message_state2 ~ ' for ' ~ delay_display ~ ' ' ~ iif(delay_display == 1, 'minute', 'minutes') ~ '.' }}
                room: ['family_room', 'theater']
                voice_type: announce
        
            - service: timer.start
              data:
                entity_id: timer.cinema_usage_delay
                duration: "{{ delay }}"
      
      else:
        
        # Turn on the allowed toggle.
        - service: input_boolean.turn_on
          target:
            entity_id: input_boolean.cinema_usage_allowed
    
        # Set the usage control timestamp.
        - service: input_datetime.set_datetime
          target:
            entity_id: input_datetime.cinema_usage_control
          data_template:
            datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

#==========================#
#     Post-Open Tasks      #
#==========================#

# The cinema can be opened for general usage (Open Cinema), a feature film (Play Feature) or to play a set
# of random music videos (Play Random Kodi Videos). In all of these cases there are some common tasks, which
# we perform here.

perform_post_open_tasks:
  alias: Perform Post-Open Tasks
  
  sequence:
    
    # Say something appropriate.
    - action: script.send_notification
      data:
        destination:
          - voice_assistant
        message: >
          {{ ["Cinema is now open to the public!", 
              "Hope you enjoy the show!", 
              "White Rabbit Theater is ready!",
              "Don't forget to silence your phones!",
              "Please don't lose your children in the dark!",
              "Watch for weeping angels!",
              "Come relax in our state of the art theater!",
              "Prepare to laugh and weep in equal measure!",
              "Time to vegetate on the couch!"
             ] | random }}
        speak: excited
        room: ['family_room', 'theater']
        voice_type: tts
    
    # Set the upstairs Ecobee to home mode if the penthouse is not occupied.
    - if:
        - condition: state
          entity_id: binary_sensor.penthouse_occupied
          state: 'off'
        
      then:    
        - action: script.set_thermostat_preset
          data:
            thermostat_entity: climate.upstairs
            preset: 'home'
    
    # Turn off the upstairs Ecobee minimum fan time (it makes me cold sometimes).
    - action: ecobee.set_fan_min_on_time
      data:
        entity_id: climate.upstairs
        fan_min_on_time: 0
    
    # Turn off some downstairs lights after a delay, if appropriate.
    - delay: '00:05:00'
    
    - action: script.change_downstairs_lighting
      data:
        operation: post_open
    
    # Turn off the family room AV system if it's late enough and no one else is home.
    - if:
        - condition: state
          entity_id: 
            - binary_sensor.adults_home
            - binary_sensor.children_home
          state: 'off'
        
        - condition: time
          after:  '18:00:00'
          before: '23:30:00'
      
      then:    
        - action: script.disable_family_room_av

#=========================#
#     Volume Control      #
#=========================#

# Set the receiver media player volume. This is called by:
#
# 1) The Initialize <app/device> Volume automations, when using the theater.
# 2) The Set Application Volume script, if the theater is in use.
set_receiver_volume:
  alias: Set Receiver Volume
  
  fields:
    target_name:
      description: The name of the application on the Shield TV (example 'Youtube TV'), or the Harmony device (example 'BD Player').
    
    volume:
      description: The receiver volume.
      selector:
        number:
          min: 0.48
          max: 0.64
  
  sequence:
    - service: system_log.write
      data:
        message: "Setting volume for {{ target_name }} to {{ volume }}"
        level: debug
  
    - service: media_player.volume_set
      data:
        entity_id: media_player.marantz_sr7012
        volume_level: "{{ volume | float(0.60) }}"

# Set the volume for an app/device into an app-specific number, and also set the live volume if the theater is open
# and the target app/device is currently in use.
set_application_volume:
  alias: Set Application Volume
  
  fields:
    volume_entity:
      description: The entity in which to set the volume for the target application.
      selector:
        entity:
          domain: input_number
    
    volume:
      description: The new volume for the target application.
      selector:
        number:
          min: 0.48
          max: 0.64
  
  sequence:
    
    # NOTE: The Shield TV app names for "plus" apps are named with a '+' for the Android Debug Bridge integration.
    # For example Disney Plus is named Disney+. But we can't use '+' in entity IDs, so the application volume number
    # entity is named input_number.disney_plus_volume. In order to check against the Shield TV app name, convert 'Plus' to '+'.
    - variables:
        target_name: "{{ state_attr(volume_entity, 'friendly_name') | replace('Volume', '') | replace(' Plus', '+') | trim }}"
        activity: "{{ states('sensor.harmony_hub') }}"
    
    # Set the app-specific number, so the app will get set to this volume the next time it is opened/used.
    - service: input_number.set_value
      target:
        entity_id: "{{ volume_entity }}"
      data:
        value: "{{ volume }}"
    
    # Also set the live volume if the target app/device is currently in use.
    - if:
        - "{{ states('input_boolean.theater_open') == 'on' and 
              ('Stream' in activity and state_attr('media_player.shield_android_tv', 'app_name') == target_name) or
              (activity == 'BD Player' or activity == 'LD Player') }}"
      
      then:
        - service: script.set_receiver_volume
          data:
            target_name: "{{ target_name }}"
            volume: "{{ volume }}"

# Raise or lower the theater volume by one step.
#
# NOTE: This is intended to be called by voice control; I don't know how to provide input variables via voice, so these are
# simple front ends to Change Theater Volume.
raise_theater_volume:
  alias: Raise Theater Volume
  
  sequence:
    - service: script.change_theater_volume
      data:
        raise: true

lower_theater_volume:
  alias: Lower Theater Volume
  
  sequence:
    - service: script.change_theater_volume
      data:
        raise: false

# Raise or lower the theater volume.
change_theater_volume:
  alias: Change Theater Volume
  
  fields:
    raise:
      description: Whether to raise (true) or lower (false) the volume.
      selector:
        boolean:
  
  sequence:
    - variables:
        activity: "{{ states('sensor.harmony_hub') }}"
        app_name: "{{ iif('Stream' in activity, state_attr('media_player.shield_android_tv', 'app_name') | replace('+', ' Plus') | replace(' ', '_') | lower, 'none') }}"
        volume_entity: >
          {% if 'Stream' in activity %}
            {{ 'input_number.' ~ app_name ~ '_volume' }}
          {% elif activity == 'BD Player' %}
            input_number.bd_player_volume
          {% elif activity == 'LD Player' %}
            input_number.ld_player_volume
          {% endif %}
        current_volume: "{{ states(volume_entity) | float(0.60) }}"
    
    - if:
        - "{{ raise == true }}"
      
      then:
        - service: script.set_application_volume
          data:
            volume_entity: "{{ volume_entity }}"
            volume: "{{ current_volume + 0.01 }}"
      
      else:
        - service: script.set_application_volume
          data:
            volume_entity: "{{ volume_entity }}"
            volume: "{{ current_volume - 0.01 }}"

#===========================#
#     Theater Lighting      #
#===========================#

# Make the theater dark.
set_theater_dark:
  alias: Set Theater Dark
  
  sequence:
    - action: scene.turn_on
      target:
        entity_id:
          - scene.theater_aux_dark
          - scene.lutron_dark

# Make the theater dark, with a delay.
set_theater_dark_delay:
  alias: Set Theater Dark Delay
  
  sequence:
    - action: scene.turn_on
      target:
        entity_id: scene.theater_aux_dark
    
    - delay: '00:00:12'
    
    - action: scene.turn_on
      target:
        entity_id: scene.lutron_dark

# Make the theater dim.
set_theater_dim:
  alias: Set Theater Dim
  
  sequence:
    - action: scene.turn_on
      target:
        entity_id:
          - scene.theater_aux_dark
          - scene.lutron_dim

# Make the theater idle, meaning it's on but we need lights to see.
set_theater_idle:
  alias: Set Theater Idle
  
  fields:
    operation:
      description: The reason for calling this script (operation in progress). The break operation is called by voice assistant, so is the default since it's not always possible to pass data.
      default: break
      selector:
        select:
          options:
            - 'activation'
            - 'break'
            - 'close'
  
  sequence:
    - action: scene.turn_on
      target:
        entity_id:
          - scene.theater_aux_partial
          - scene.lutron_idle
    
    - if:
        - "{{ not operation is defined }}"
      
      then:
        - action: script.change_downstairs_lighting
          data:
            operation: break
        
      else:
        - action: script.change_downstairs_lighting
          data:
            operation: "{{ operation }}"

#============================#
#     Downstairs Lights      #
#============================#

# Turn on some downstairs lights if it's dark enough, or conditionally turn them off. This is used as follows,
# either directly or via the Set Theater Idle script:
#
# - Cinema open, via Set Theater Idle (operation = activation: turn on)
# - Cinema open after delay (operation = post_open: turn off)
# - Voice assistant break time, via Set Theater Idle (operation = break: turn on)
# - Cinema Resume (operation = resume: turn off)
# - Cinema close, via Set Theater Idle (operation = close: turn on)
# - Cinema close after delay (operation = post_close: turn off)
change_downstairs_lighting:
  alias: Change Downstairs Lighting
  
  trace:
    stored_traces: 20
  
  fields:
    operation:
      description: The reason for calling this script (operation in progress).
      selector:
        select:
          options:
            - 'activation'
            - 'post_open'
            - 'break'
            - 'resume'
            - 'close'
            - 'post_close'
  
  sequence:
    - variables:
        turn_on: "{{ operation in ['activation', 'break', 'close'] }}"
        test_lights: "{{ iif(is_state('input_boolean.christmas_mode', 'off'), 'light.family_room_lamp', 'light.all_christmas_lights') }}"
        ambient_min: "{{ states('input_number.family_room_ambient_min') | float(0) }}"
        ambient_value: "{{ states('sensor.downstairs_sensor_ambient_light') | float(0) }}"
        activation_lights: "{{ ['light.stairway', 'light.kitchen_island'] }}"
        non_activation_lights: "{{ ['light.office_lamp', 'light.family_room_lamp', 'light.hallway_lamp'] + activation_lights }}"
    
    - if:
        - "{{ turn_on == true }}"
        
      # Turn on lights.
      then:
          
        - if:
            - "{{ operation == 'activation' }}"
          
          # At activation time downstairs lights might be on or off, or we could be in a window where the ambient light is below the minimum
          # but the lights haven't turned on yet. So we need to test both conditions. However, for the few days around Christmas and New Year's,
          # the Christmas lights are on all day, so we always want to turn on the lights.
          #
          # Also, the lights we turn on at activation time don't include the daytime lights, because at Christmas time we don't need them, 
          # and otherwise they should already be on.
          then:
            - if:
                - "{{ is_state(test_lights, 'on') or ambient_value < ambient_min }}"
              
              then:
                - action: script.turn_on_lights_per_conditions
                  data:
                    light_entity: "{{ activation_lights }}"
                    lux_entity: sensor.downstairs_sensor_ambient_light
                    min_lux_value: "{{ states('input_number.family_room_ambient_min') | float(0) }}"
          
          # For break time and theater close include the daytime lights.
          else:
            - action: script.turn_on_lights_per_conditions
              data:
                light_entity: "{{ non_activation_lights }}"
                lux_entity: sensor.downstairs_sensor_ambient_light
                min_lux_value: "{{ states('input_number.family_room_ambient_min') | float(0) }}"
        
      # Turn off lights, but only if no family members are present.
      else:
        - condition: state
          entity_id: binary_sensor.adults_home
          state: 'off'
        
        # At post open time, turn off the Christmas lights if Christmas mode is on.
        - if:
            - "{{ states('input_boolean.christmas_mode') == 'on' and (operation == 'post_open') }}"
          
          then: 
            - action: script.turn_off_christmas_lights
        
        # Turn off non-Christmas lights. For post close, we want the daytime lights to remain on, so use the
        # activation lights.
        - action: light.turn_off
          target:
            entity_id: "{{ iif(operation == 'post_close', activation_lights, non_activation_lights) }}"

#========================#
#     Cinema Resume      #
#========================#

# Resume the current harmony activity and restore the lighting.

# Worker script
resume_worker:
  alias: Resume Worker
  fields:
    device:
      description: 'The Harmony device name to be resumed.'
      example: 'Sony DVD/Blu-ray Player'
  
  sequence:
  
    # Send the play command to the target device.
    - service: remote.send_command
      entity_id: remote.harmony_hub
      data:
        command: Play
        device: "{{ device }}"
    
    # Restore theater lighting.
    - service: script.restore_lighting_on_resume

# Call the worker script with the appropriate device based on the Harmony activity.
# Note: The turntable cannot be controlled, so all we do is turn on some lights.
resume_cinema:
  alias: Resume Cinema
  
  sequence:
    - choose:
      - conditions: "{{ is_state('sensor.harmony_hub', 'Stream Player') or is_state('sensor.harmony_hub', 'Enable Streaming') }}"
        
        sequence:
          - service: script.resume_worker
            data:
              device: 'NVIDIA Shield TV'
      
      - conditions: "{{ is_state('sensor.harmony_hub', 'BD Player') }}"
        
        sequence:
          - service: script.resume_worker
            data:
              device: 'Sony DVD/Blu-ray Player'
      
      - conditions: "{{ is_state('sensor.harmony_hub', 'LD Player') }}"
        
        sequence:
          - service: script.resume_worker
            data:
              device: 'Panasonic Laserdisc Player'
      
      - conditions: "{{ is_state('sensor.harmony_hub', 'LP Player') }}"
        
        sequence:
          - service: script.turn_on
            entity_id: script.set_theater_dim
      
      default:
        - service: system_log.write
          data:
            message: Current activity does not support resume command.
            level: warning

# Restore the theater lighting on resume (called by the restore automation and script).
restore_lighting_on_resume:
  alias: Restore Lighting On Resume
  
  sequence:
  
    # Establish 'dark' theater lighting.
    - service: script.turn_on
      entity_id: script.set_theater_dark
    
    # Turn off some downstairs lights.
    - service: script.change_downstairs_lighting
      data:
        operation: resume

#=====================================#
#     Kodi Video Playlist Control     #
#=====================================#

# Get all music videos using Kodi.
get_all_kodi_videos:
  alias: Get All Kodi Videos
  
  sequence:
    - variables:
        
        # We don't want to retry endlessly.
        max_retries: 3
        
        # Wait timeout.
        timeout_secs: 7
    
    # This is a flag to know when we're done.
    - action: input_boolean.turn_off
      data:
        entity_id: input_boolean.music_video_playlist_built
    
    # Initialize the retry count.
    - action: input_number.set_value
      target:
        entity_id: input_number.kodi_video_retry_count
      data:
        value: 0
    
    # This loop is to handle a potential error from the Kodi call. If everything is OK we don't loop.
    - repeat:
        
        # Loop until the video playlist is built.
        until:
          - condition: state
            entity_id: input_boolean.music_video_playlist_built
            state: 'on'
        
        sequence:
    
          # Reset the error toggle before we call Kodi.
          - action: input_boolean.turn_off
            data:
              entity_id: input_boolean.kodi_video_call_error
    
          # Send the command to Kodi to get all available videos. If all is well this drives the
          # Process Kodi Video Result automation, which selects random videos from the result and 
          # builds a Kodi playlist.
          - service: kodi.call_method
            target:
              entity_id: media_player.kodi
            data:
              method: VideoLibrary.GetMusicVideos
              properties:
                - artist
                - streamdetails
        
          # Wait for the playlist to be built or an error to be detected. These are mutually exclusive.
          - wait_for_trigger:
              - trigger: state
                entity_id: input_boolean.music_video_playlist_built
                to: 'on'
              
              - trigger: state
                entity_id: input_boolean.kodi_video_call_error
                to: 'on'
            timeout:
              seconds: "{{ timeout_secs }}"
        
          # Handle the result.
          - choose:
              
            # If the playlist has been built then we're done.
            - conditions: "{{ states('input_boolean.music_video_playlist_built') == 'on' }}"
              
              sequence:
                - variables:
                    result: "{{ {'result': 'success'} }}"
                
                - stop: 'Kodi playlist has been completed'
                  response_variable: result
              
            # If an error was detected then retry the Kodi call.
            - conditions: "{{ states('input_boolean.kodi_video_call_error') == 'on' }}"
              
              sequence:
                - variables:
                    result: "{{ {'result': 'failure'} }}"
                    retry_count: "{{ states('input_number.kodi_video_retry_count') | int(0) }}"
                
                # If we've hit the retry count, we've failed miserably.
                - if:
                    - "{{ retry_count >= max_retries }}"
                  
                  then:
                    - stop: "{{{ 'Kodi call failed ' ~ retry_count ~ ' times' }}"
                      response_variable: result
                
                # Bump the retry count.
                - action: input_number.increment
                  target:
                    entity_id: input_number.kodi_video_retry_count
              
            # If we timed out then I don't know what's wrong. Log it.
            default:
              - variables:
                  result: "{{ {'result': 'failure'} }}"
            
              - action: system_log.write
                data:
                  message: "{{ 'Kodi GetMusicVideos call did not complete after ' ~ timeout_secs ~ ' seconds.' }}"
                  level: warning
            
              - stop: 'Kodi playlist was not built but no error was detected'
                response_variable: result

# Select random videos from all that are available.
process_kodi_videos_result:
  alias: Process Kodi Videos Result
  
  fields:
    result:
      description: The result from the GetMovies Kodi call.
  
  sequence:
  
    - variables:
        video_list_type: "{{ states('input_select.kodi_videos_type') }}"
        max_videos: "{{ states('input_number.kodi_videos_max_number_' ~ video_list_type ) | int(0) }}"
        max_time: "{{ states('input_number.kodi_videos_max_minutes_' ~ video_list_type) | int(0) * 60 }}"
        max_video_time: "{{ 10 * 60 }}"
        
        # Collect the relevant pieces of the results into separate lists.
        artists:  "{{ result['musicvideos'] | map(attribute='artist.0') | list }}"
        ids:      "{{ result['musicvideos'] | map(attribute='musicvideoid') | list }}"
        runtimes: "{{ result['musicvideos'] | map(attribute='streamdetails.video.0.duration') | list }}"
        
        # Then refactor those lists into a list of [artist, ID, runtime] for each video, weeding out long videos and
        # 'PreRoll' artist (such videos are movie prerolls, not music videos).
        results: >
          {% set result = namespace(list = []) %}
          {% for artist in artists %}
            {% if artist != 'PreRoll' and runtimes[loop.index0] < max_video_time %}
              {% set result.list = result.list + [[artists[loop.index0], ids[loop.index0], runtimes[loop.index0]]] %}
            {% endif %}
          {% endfor %}
          
          {{ result.list }}
        
        # Number of videos available.
        number_of_videos: "{{ results | length() }}"
        
        # Minimum runtime ... we use this to determine if no possible video can fit into the remaining total time, meaning we're done.
        minimum_runtime: >
          {% set min = namespace(time = max_time) %}
          {% for result in results %}
            {% set rt = result[2] %}
            {% if rt < min.time %}
              {% set min.time = rt %}
            {% endif %}
          {% endfor %}
          
          {{ min.time }}
    
    # Initialize variables...
    
    # These ensure that no duplicate artists are selected, and collect the IDs and run times of the videos we select.
    - action: input_text.set_value
      target:
        entity_id:
          - input_text.music_video_artists
          - input_text.music_video_ids
          - input_text.music_video_runtimes
      data:
        value: ''
    
    # This ensures we end the loop if we've checked all videos without satisfying the limits.
    - action: input_select.set_options
      target:
        entity_id: input_select.music_videos_checked
      data:
        options: placeholder
    
    # These accumulate the total run time, and count the number of videos.
    - action: input_number.set_value
      target:
        entity_id:
          - input_number.music_videos_total_time
          - input_number.music_videos_selected
      data:
        value: 0
    
    # This is a flag to know when we're done selecting videos.
    - action: input_boolean.turn_off
      data:
        entity_id: input_boolean.music_video_selection_done
          
    # Log video information.
    - action: system_log.write
      data:
        message: "Kodi video count: {{ number_of_videos }}, min runtime: {{ minimum_runtime }}"
        level: info
    
    - action: system_log.write
      data:
        message: "Kodi video list: {{ results }}"
        level: debug
    
    # Loop through the result to randomly select videos.
    - repeat:
        
        # We're done if any of the limits are reached or we've checked all videos.
        until:
          - condition: state
            entity_id: input_boolean.music_video_selection_done
            state: 'on'          
        
        sequence:
          
          - variables:
              
              # Random index into the list of videos.
              index: "{{ range(number_of_videos) | random }}"
              
              # Data from the randomly selected video.
              artist:  "{{ results[index][0] }}"
              videoid: "{{ results[index][1] }}"
              runtime: "{{ results[index][2] }}"
              
          # Debug logging.
          - action: system_log.write
            data:
              message: "Checking video ({{ repeat.index }}): '{{ artist }}', {{ videoid }}, {{ runtime }}"
              level: debug
          
          # Skip this video if:
          # - this artist has already been chosen
          # - the runtime is too long
          - if:
              - "{{ artist not in states('input_text.music_video_artists') and
                    runtime + states('input_number.music_videos_total_time') | int(0) <= max_time }}"
            
            then:
          
              # Only do something if the limits haven't been reached.
              #
              # Note the following:
              #
              # 1) We check if the total accumulated time is less than the maximum time minus the minimum runtime.
              #    If this is false no possible video can be found to fill out the time to the maximum.
              # 2) We also only iterate to twice the number of videos found (an arbitrary value), so we don't
              #    spend too much time trying to fill up the total time.
              - if:
                  - "{{ states('input_number.music_videos_total_time') | int(0) < max_time - minimum_runtime and 
                        states('input_number.music_videos_selected') | int(0) < max_videos and
                        repeat.index <= number_of_videos * 2}}"
                
                then:
                  
                  # Update the list of chosen artists.
                  - action: input_text.set_value
                    target:
                      entity_id: input_text.music_video_artists
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_artists', artist) }}
                  
                  # Update the list of chosen video IDs.
                  - action: input_text.set_value
                    target:
                      entity_id: input_text.music_video_ids
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_ids', videoid) }}
                  
                  # Update the list of chosen video run times.
                  - action: input_text.set_value
                    target:
                      entity_id: input_text.music_video_runtimes
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_runtimes', runtime) }}
                  
                  # Accumulate the total run time.
                  - action: input_number.set_value
                    target:
                      entity_id: input_number.music_videos_total_time
                    data:
                      value: "{{ states('input_number.music_videos_total_time') | int(0) + runtime | int(0) }}"
                  
                  # Bump the number of selected videos.
                  - action: input_number.increment
                    target:
                      entity_id: input_number.music_videos_selected
                
                # Limits have been reached, we're done.
                else:
                  - action: input_boolean.turn_on
                    data:
                      entity_id: input_boolean.music_video_selection_done
          
          # Add this video to the checked list if we haven't checked it yet.
          - action: input_select.set_options
            target:
              entity_id: input_select.music_videos_checked
            data:
              options: >
                {% set id = videoid | string %}
                {% set current = state_attr('input_select.music_videos_checked', 'options') %}
                  {% if id not in current %}
                    {% if 'placeholder' not in current %}
                      {% set current = current + [id] %}
                    {% else %}
                      {% set current = videoid %}
                    {% endif %}
                  {% endif %}
                
                {{ current }}
          
          # Log the results so far.
          - action: system_log.write
            data:
              message: >
                {% set runtime = states('input_number.music_videos_total_time') %}
                {% set artists = states('input_text.music_video_artists') %}
                {% set num_checked = state_attr('input_select.music_videos_checked', 'options') | length() %}
                {{ 'Total runtime: ' ~ runtime ~ ', artists: ' ~ artists ~ ', num checked: ' ~ num_checked }}
              level: info
          
          # We're done if we've checked all available videos, or we've hit the max time or number of videos.
          - if:
              - "{{ state_attr('input_select.music_videos_checked', 'options') | length() >= number_of_videos or
                    max_time - states('input_number.music_videos_total_time') | int(0) < minimum_runtime or
                    states('input_number.music_videos_selected') | int(0) >= max_videos }}"
            
            then:
              - action: input_boolean.turn_on
                data:
                  entity_id: input_boolean.music_video_selection_done
    
    # Debug logging.
    - action: system_log.write
      data:
        message: "Found artists: {{ states('input_text.music_video_artists') }}"
        level: debug
    - action: system_log.write
      data:
        message: "Found video IDs: {{ states('input_text.music_video_ids') }}"
        level: debug
    - action: system_log.write
      data:
        message: "Found run times: {{ states('input_text.music_video_runtimes') }}"
        level: debug
    - action: system_log.write
      data:
        message: "Total time: {{ states('input_number.music_videos_total_time') | int(0) }} minutes"
        level: debug
    
    # Go build the video playlist.
    - action: script.build_kodi_video_playlist
    
    # Indicate the playlist has been built.
    - action: input_boolean.turn_on
      data:
        entity_id: input_boolean.music_video_playlist_built

# Build a playlist of selected music videos.
build_kodi_video_playlist:
  alias: Build Kodi Video Playlist
  
  sequence:
  
    # Ensure the playlist is clear.
    - service: kodi.call_method
      target:
        entity_id: media_player.kodi
      data:
        method: Playlist.Clear
        playlistid: 1
    
    - repeat:
        
        # Repeat for each selected video ID.
        for_each: "{{ states('input_text.music_video_ids').split(',') }}"
        
        sequence:
          
          # Add the video to the playlist.
          - service: kodi.call_method
            target:
              entity_id: media_player.kodi
            data:
              method: Playlist.Add
              playlistid: 1
              item:
                musicvideoid: "{{ repeat.item | int(0) }}"

# Play a Kodi playlist. This consists of either a set of music videos, or such a set along with a feature movie.
play_kodi_playlist:
  alias: Play Kodi Playlist
  
  sequence:
    - service: kodi.call_method
      target:
        entity_id: media_player.kodi
      data:
        method: Player.Open
        item:
          playlistid: 1

#========================#
#     Kodi Utilities     #
#========================#

# Activate Kodi on the Shield TV. We make no assumptions here about the rest of the theater; for example we don't
# require the projector to be on. All we need is the Shield TV on and the Kodi application running on it.
activate_kodi:
  alias: Activate Kodi
  
  sequence:
  
    # Turn on the Shield TV if needed so we can host the Kodi application.
    - if:
        - condition: state
          entity_id: media_player.shield_tv
          state: 'off'
      
      then:    
        - action: media_player.turn_on
          data:
            entity_id: media_player.shield_tv
        
    # Wait until the Shield media player is on.
    # NOTES:
    # 1) We check the state of the media player for the Android TV Remote integration. The ADB media player turns on in 'idle' state
    #    but I don't trust that will always be true.
    # 2) We can't use wait_for_trigger because of timing between the state we want and the associated trigger being initialized.
    - repeat:
        until: "{{ is_state('media_player.shield_android_tv', 'on') }}"
        
        sequence:
          - event: unused_event
          
          - delay:
              milliseconds: 10
          
    # Initialize the toggle that indicates Kodi is responding to commands.
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.kodi_activated
  
    # Start Kodi on the Shield TV.
    - action: remote.turn_on
      target:
        entity_id: remote.shield_android_tv
      data:
        activity: Kodi
    
    # Wait until Kodi responds to commands, by sending a valid command that we never actually use. If this succeeds
    # the Process Kodi Command Result automation turns on the toggle that indicates Kodi is responding to commands.    
    # If this doesn't work within the timeout period, then whatever we need Kodi for will also probably fail. Oh well.
    - variables:
        delay_milliseconds: 500
        timeout_seconds: 10
    
    - repeat:
        until: "{{ is_state('input_boolean.kodi_activated', 'on') or repeat.index > timeout_seconds * 1000 / delay_milliseconds }}"
        
        sequence:
          - action: kodi.call_method
            data:
              entity_id: media_player.kodi
              method: VideoLibrary.GetMovieSets
          
          - delay:
              milliseconds: "{{ delay_milliseconds }}"

# Get the list of all movies known by Kodi.
# This script is only needed when the Kodi movie library is updated.
get_all_kodi_movies:
  alias: Get All Kodi Movies
  
  sequence:
    
    # Activate Kodi on the Shield TV.
    - service: script.activate_kodi
    
    - delay: '00:00:10'
  
    # Send the GetMovies command to Kodi. The Handle Kodi Movies Result script calls Process All Kodi Movies Result
    # below with the command result.
    - service: kodi.call_method
      data:
        entity_id: media_player.kodi
        method: VideoLibrary.GetMovies

# Process the list of movies returned by Kodi.
process_all_kodi_movies_result:
  alias: Process All Kodi Movies Result
  
  fields:
    result:
      description: The result from the GetMovies Kodi call.
  
  sequence:
    
    - variables:
        movie_list: >
          {% set movies = result.get('movies') %}
          {% set ns = namespace(list = []) %}
          {% for movie in movies %}
            {% set ns.list = ns.list + [movie.get('label')] %}
          {% endfor %}
          
          {{ ns.list | sort }}
    
    # Call the python script to populate the input select.
    - service: pyscript.save_input_select_options
      data:
        entity: input_select.kodi_movies
        list: "{{ movie_list }}"
        file: '/config/all_movies_backup'
  
    # Exit the Kodi application.
    - service: remote.send_command
      entity_id: remote.harmony_hub
      data:
        command: 'Home'
        device: NVIDIA Shield TV
    - delay: '00:00:01'
  
    # Turn the Shield TV off again.
    - service: media_player.turn_off
      data:
        entity_id: media_player.shield_tv
