#=======================#
#     Cinema Resume     #
#=======================#

# Make the theater dark when the Shield TV resumes.    
- alias: Resume Cinema
  id: resume_cinema
  
  trace:
    stored_traces: 20

  trigger:
    - platform: state
      entity_id: media_player.shield_tv
      from:
        - 'paused'
        - 'standby'
      to: 'playing'
      for: 00:00:02
  
  action:  
    
    # Restore theater lighting.
    - service: script.restore_lighting_on_resume

#======================#
#     Cinema Close     #
#======================#

# Close the cinema when the Harmony is powered off.   
- alias: Close Cinema
  id: close_cinema
  trigger:
    - platform: state
      entity_id: sensor.harmony_hub
      to: 'PowerOff'
  
  # Sanity check to prevent false triggers, which can happen if the network is twitchy.
  condition:
    - condition: state
      entity_id: input_boolean.theater_open
      state: 'on'
  
  action:
    - service: script.close_cinema

#===================================#
#     Cinema Open/Close Control     #
#===================================#

# To prevent the projector and other components from frequent on/off cycles, the cinema can only be opened or closed
# about 10 minutes after being closed or opened. This is largely controlled by the Check Cinema Usage Control script,
# but it uses a timer to delay the actual open or close. We handle the timer expiration here.
- alias: Handle Cinema Usage Delay
  id: handle_cinema_usage_delay
  
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.cinema_usage_delay
  
  action:
    - if:
        - "{{ states('input_boolean.theater_open') == 'off' }}"
      
      then:
        - service: script.open_cinema
      
      else:
        - service: script.close_cinema

#==================================#
#     Projector Error Handling     #
#==================================#

# The projector sometimes encounters a (bogus) lamp error when powering on. We detect that here and try to
# automatically handle it.
- alias: Handle Projector Error
  id: handle_projector_error
  
  trigger:
    - platform: event
      event_type: system_log_event
      event_data:
        name: 'custom_components.epson_projector_link.projector.projector'
        level: 'ERROR'
  
  condition: "{{ 'Lamp ON failure' in trigger.event.data.message[0] }}"
  
  action:
    - service: notify.alexa_media
      data:
        message: "Projector lamp error detected. Please wait a few minutes while I try to fix it."
        target:
          - media_player.family_room_echo
          - media_player.theater_echo
        data:
          type: tts
    
    # Wait a few minutes for the projector to turn itself off.
    - delay: '00:02:00'
    
    # Turn off the power for a bit.
    - service: switch.turn_off
      entity_id: switch.projector_plug
    
    - delay: '00:00:30'
    
    # Turn the power back on.
    - service: switch.turn_on
      entity_id: switch.projector_plug
    
    - service: notify.alexa_media
      data:
        message: "I'm turning the projector back on. Keep your fingers crossed!"
        target:
          - media_player.family_room_echo
          - media_player.theater_echo
        data:
          type: tts
    
    - delay: '00:00:10'
    
    # Finally, power on the projector.
    - service: remote.send_command
      entity_id: remote.harmony_hub
      data:
        command: 'PowerOn'
        device: Epson Projector

#==================================#
#     Automatic Volume Control     #
#==================================#

# Initialize the theater volume for Shield TV apps and other input devices.
#
# NOTE: The volume levels in the map below must be coordinated with the *_volume blueprints.
#
# Mapping of db levels to percentages:
#
# -16 db = 64%
# -17 db = 63%
# -18 db = 62%
# -19 db = 61%
# -20 db = 60%
# -21 db = 59%
# -22 db = 58%
# -23 db = 57%
# -24 db = 56%
# -25 db = 55%
# -26 db = 54%
# -27 db = 53%
# -28 db = 52%
# -29 db = 51%
# -30 db = 50%
# -31 db = 49%
# -32 db = 48% 

# The Marantz receiver is set to turn on muted. This is because there are intermittent noise sounds at turn on.
# This automation sets the volume to a default level a short time after the receiver is powered on.
- alias: Initialize Turn On Volume
  id: initialize_turn_on_volume
  trigger:
    - platform: state
      entity_id: media_player.marantz_sr7012
      from: 'off'
      to: 'on'
  
  action:
    - delay: '00:00:30'
    - service: media_player.volume_set
      data:
        entity_id: media_player.marantz_sr7012
        volume_level: 0.60

# NOTES:
#   1) The Shield TV app names used here must match those defined for the androidtv integration.
#   2) The Harmony activity names used here must match those defined in harmony_nnn.conf.

#   -- Shield TV Apps --   #

# Amazon Prime
- alias: Initialize Amazon Prime Volume
  id: initialize_amazon_prime_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Amazon Prime
      volume: 0.60

# Disney Plus
- alias: Initialize Disney Plus Volume
  id: initialize_disney_plus_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Disney+
      volume: 0.64

# ESPN
- alias: Initialize ESPN Volume
  id: initialize_espn_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: ESPN
      volume: 0.57

# HBO Max
- alias: Initialize HBO Max Volume
  id: initialize_hbo_max_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: HBO Max
      volume: 0.62

# Hulu
- alias: Initialize Hulu Volume
  id: initialize_hulu_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Hulu
      volume: 0.58

# Kodi
- alias: Initialize Kodi Volume
  id: initialize_kodi_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Kodi
      volume: 0.63

# Netflix
- alias: Initialize Netflix Volume
  id: initialize_netflix_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Netflix
      volume: 0.62

# Paramount Plus
- alias: Initialize Paramount Plus Volume
  id: initialize_paramount_plus_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Paramount+
      volume: 0.62

# Peacock
- alias: Initialize Peacock Volume
  id: initialize_peacock_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Peacock
      volume: 0.62

# Youtube TV
- alias: Initialize Youtube TV Volume
  id: initialize_youtube_tv_volume
  use_blueprint:
    path: theater/shield_app_volume.yaml
    input:
      appl_name: Youtube TV
      volume: 0.62

#   -- Harmony Activities --   #

# Blu-ray Player
- alias: Initialize Bluray Volume
  id: initialize_bluray_volume
  use_blueprint:
    path: theater/harmony_device_volume.yaml
    input:
      device_name: BD Player
      volume: 0.63

# Laserdisc Player
- alias: Initialize Laserdisc Volume
  id: initialize_laserdisc_volume
  use_blueprint:
    path: theater/harmony_device_volume.yaml
    input:
      device_name: LD Player
      volume: 0.63
 
#=================================#
#     Kodi Feature Movie List     #
#=================================#
 
# We have an input select that represents the list of Kodi movies. This is dynamically set using the 
# Process All Kodi Movies Result script. However, when HA restarts, the input select gets restored to the yaml value
# instead of the dynamically set value. So the dynamic list is restored on HA start, by Perform Startup Chores.

# Save the feature movie name when a new movie is selected in the front end.
# This is needed to restore the selected value in the corresponding list of movies on HA restart, because on restart
# that gets restored to the single yaml value ('Select') instead of the list of movies that was dynamically set.
- alias: Save Feature Movie Name
  id: save_feature_movie_name
  
  trigger:
    - platform: state
      entity_id: input_select.kodi_movies
  
  condition:
    - condition: state
      entity_id: input_boolean.kodi_movie_list_restoration
      state: 'off'
    
    - "{{ ( trigger.to_state.state ) != ( 'Select' ) and ( trigger.to_state.state ) != ( 'unknown' ) }}"
  
  action:
    - service: system_log.write
      data:
        message: "feature movie name: '{{ trigger.to_state.state }}'"
        level: debug
    
    - service: input_text.set_value
      data_template:
        entity_id: input_text.current_feature
        value: "{{ ( trigger.to_state.state ) }}"

#==============================#
#     Kodi Process Results     #
#==============================#

# Process a bad result from any Kodi call.
- alias: Process Kodi Bad Result
  id: process_kodi_bad_result
  
  # Trigger on an unsuccessful command result.
  trigger:
    - platform: event
      event_type: kodi_call_method_result
      event_data:
        result_ok: false
  
  action:
    - service: system_log.write
      data:
        message: "Kodi {{ trigger.event.data.input.method }} call failed."
        level: warning

# Process the results from a GetMovies Kodi call.
- alias: Process Kodi Movies Result
  id: process_kodi_movies_result
  
  # Trigger on a successful GetMovies command result.
  trigger:
    - platform: event
      event_type: kodi_call_method_result
      event_data:
        result_ok: true
        input:
          method: VideoLibrary.GetMovies
  
  action:
    - service: script.handle_kodi_movies_result
      data:
        result: "{{ trigger.event.data.result }}"

# Process the results from a GetMusicVideos Kodi call.
- alias: Process Kodi Video Result
  id: process_kodi_video_result
  
  # Trigger on a successful GetMusicVideos command result.
  trigger:
    - platform: event
      event_type: kodi_call_method_result
      event_data:
        result_ok: true
        input:
          method: VideoLibrary.GetMusicVideos
  
  variables:
    
    # Limits are imposed on the number of videos played, as well as the total time allotted.
    max_videos: 3
    max_time: "{{ (12 * 60) | int }}"
    
    # Collect the relevant pieces of the results into separate lists.
    artists:  "{{ trigger.event.data.result['musicvideos'] | map(attribute='artist.0') | list }}"
    ids:      "{{ trigger.event.data.result['musicvideos'] | map(attribute='musicvideoid') | list }}"
    runtimes: "{{ trigger.event.data.result['musicvideos'] | map(attribute='streamdetails.video.0.duration') | list }}"
    
    # Then refactor those lists into a list of [artist, ID, runtime] for each video, weeding out long videos.
    results: >
      {% set result = namespace(list = []) %}
      {% for artist in artists %}
        {% if runtimes[loop.index0] < max_time %}
          {% set result.list = result.list + [[artists[loop.index0], ids[loop.index0], runtimes[loop.index0]]] %}
        {% endif %}
      {% endfor %}
      
      {{ result.list }}
    
    # Number of videos available.
    number_of_videos: "{{ results | length() }}"
    
    # Minimum runtime ... we use this to determine if no possible video can fit into the remaining total time, meaning we're done.
    minimum_runtime: >
      {% set min = namespace(time = max_time) %}
      {% for rt in runtimes %}
        {% if rt < min.time %}
          {% set min.time = rt %}
        {% endif %}
      {% endfor %}
      
      {{ min.time }}
  
  action:
    
    # Initialize variables...
    
    # These ensure that no duplicate artists are selected, and collect the IDs and run times of the videos we select.
    - service: input_text.set_value
      target:
        entity_id:
          - input_text.music_video_artists
          - input_text.music_video_ids
          - input_text.music_video_runtimes
      data:
        value: ''
    
    # This ensures we end the loop if we've checked all videos without satisfying the limits.
    - service: input_select.set_options
      target:
        entity_id: input_select.music_videos_checked
      data:
        options: placeholder
    
    # These accumulate the total run time, and count the number of videos.
    - service: input_number.set_value
      target:
        entity_id:
          - input_number.music_videos_total_time
          - input_number.music_videos_selected
      data:
        value: 0
    
    # This is a flag to know when we're done.
    - service: input_boolean.turn_off
      data:
        entity_id: input_boolean.music_video_selection_done
          
    # Debug logging.
    - service: system_log.write
      data:
        message: "Videos: {{ number_of_videos }}:, min runtime {{ minimum_runtime }}, {{ results }}"
        level: info
    
    # Loop through the result to randomly select videos.
    - repeat:
        
        # We're done if any of the limits are reached or we've checked all videos.
        until:
          - condition: state
            entity_id: input_boolean.music_video_selection_done
            state: 'on'          
        
        sequence:
          
          - variables:
              
              # Random index into the list of videos.
              index: "{{ range(number_of_videos) | random }}"
              
              # Data from the randomly selected video.
              artist:  "{{ results[index][0] }}"
              videoid: "{{ results[index][1] }}"
              runtime: "{{ results[index][2] }}"
              
          # Debug logging.
          - service: system_log.write
            data:
              message: "Checking video ({{ repeat.index }}): '{{ artist }}', {{ videoid }}, {{ runtime }}"
              level: info
          - service: system_log.write
            data:
              message: "Total runtime {{ states('input_number.music_videos_total_time') }}, artists {{ states('input_text.music_video_artists') }}"
              level: info
          
          # Skip if this artist has already been chosen, or the runtime is too long.
          - if:
              - "{{ artist not in states('input_text.music_video_artists') and
                    runtime + states('input_number.music_videos_total_time') | int(0) <= max_time }}"
            
            then:
          
              # Only do something if the limits haven't been reached.
              #
              # Note the following:
              #
              # 1) We check if the total accumulated time is less than the maximum time minus the minimum runtime.
              #    If this is false no possible video can be found to fill out the time to the maximum.
              # 2) We also only iterate to twice the number of videos found (an arbitrary value), so we don't
              #    spend too much time trying to fill up the total time.
              - if:
                  - "{{ states('input_number.music_videos_total_time') | int(0) < max_time - minimum_runtime and 
                        states('input_number.music_videos_selected') | int(0) < max_videos and
                        repeat.index <= number_of_videos * 2}}"
                
                then:
                  
                  # Update the list of chosen artists.
                  - service: input_text.set_value
                    target:
                      entity_id: input_text.music_video_artists
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_artists', artist) }}
                  
                  # Update the list of chosen video IDs.
                  - service: input_text.set_value
                    target:
                      entity_id: input_text.music_video_ids
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_ids', videoid) }}
                  
                  # Update the list of chosen video run times.
                  - service: input_text.set_value
                    target:
                      entity_id: input_text.music_video_runtimes
                    data:
                      value: >
                        {% from 'utilities.jinja' import build_list %}
                        {{ build_list('input_text.music_video_runtimes', runtime) }}
                  
                  # Accumulate the total run time.
                  - service: input_number.set_value
                    target:
                      entity_id: input_number.music_videos_total_time
                    data:
                      value: "{{ states('input_number.music_videos_total_time') | int(0) + runtime | int(0) }}"
                  
                  # Bump the number of selected videos.
                  - service: input_number.increment
                    target:
                      entity_id: input_number.music_videos_selected
                
                # Limits have been reached, we're done.
                else:
                  - service: input_boolean.turn_on
                    data:
                      entity_id: input_boolean.music_video_selection_done
          
          # Add this video to the checked list if we haven't checked it yet.
          - service: system_log.write
            data:
              message: "Checked {{ state_attr('input_select.music_videos_checked', 'options') }}"
              level: info
          - service: input_select.set_options
            target:
              entity_id: input_select.music_videos_checked
            data:
              options: >
                {% set id = videoid | string %}
                {% set current = state_attr('input_select.music_videos_checked', 'options') %}
                  {% if id not in current %}
                    {% if 'placeholder' not in current %}
                      {% set current = current + [id] %}
                    {% else %}
                      {% set current = videoid %}
                    {% endif %}
                  {% endif %}
                
                {{ current }}
          
          # We're done if we've checked all available videos.
          - if:
              - "{{ state_attr('input_select.music_videos_checked', 'options') | length() >= number_of_videos or
                    max_time - states('input_number.music_videos_total_time') | int(0) < minimum_runtime }}"
            
            then:
              - service: input_boolean.turn_on
                data:
                  entity_id: input_boolean.music_video_selection_done
    
    # Debug logging.
    - service: system_log.write
      data:
        message: "Found artists: {{ states('input_text.music_video_artists') }}"
        level: debug
    - service: system_log.write
      data:
        message: "Found video IDs: {{ states('input_text.music_video_ids') }}"
        level: debug
    - service: system_log.write
      data:
        message: "Found run times: {{ states('input_text.music_video_runtimes') }}"
        level: debug
    - service: system_log.write
      data:
        message: "Total time: {{ states('input_number.music_videos_total_time') | int(0) }} minutes"
        level: debug
    
    # Go build the video playlist.
    - service: script.build_kodi_video_playlist
