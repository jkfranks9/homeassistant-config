#=================================#
#     Guest Arrival/Departure     #
#=================================#

# Handle guest arrivals ... everything concerning guest suites is handled by the Add Guest To Suite script. Other tasks
# like opening the garage are done here.
- alias: Handle Guest Arrival
  id: handle_guest_arrival
  mode: queued
  
  triggers:
    
    # Adults arrive.
    - trigger: state
      entity_id:
        - person.david
        - person.sarah
        - person.mike
      to: 'home'
      id: adult
    
    # Children arrive.
    - trigger: state
      entity_id:
        - person.skylar
      to: 'home'
      id: child
  
  actions:
    - variables:
        guest: "{{ trigger.to_state.attributes.friendly_name }}"
        suite: "{{ states('input_select.' ~ guest | lower ~ '_guest_suite') }}"
    
    # Special case for Mike: only add if he arrives after 4:00 PM.
    - if:
        - "{{ guest != 'Mike' or now().hour >= 16 }}"
      
      then:
    
        # Add the triggering guest to the appropriate suite.
        - action: script.add_guest_to_suite
          data:
            guest: "{{ guest }}"
            suite: "{{ suite }}"
    
    # Perform tasks for adults.
    - if:
        - "{{ trigger.id == 'adult' }}"
      
      then:
        
        # Open garage door.
        - action: script.turn_on
          target:
            entity_id: script.open_garage_door_north
          data:
            variables:
              use_info_message: true
        
        # If sunset has already occurred, turn on some outdoor lights.
        # Also, start a timer to close the garage and turn off the lights after a short period of time.
        - if:
            - condition: state
              entity_id: sun.sun
              state: 'below_horizon'
        
          then:
            - action: light.turn_on
              target:
                entity_id:
                  - light.driveway
                  - light.front_floodlight
            
            - action: timer.start
              data:
                entity_id: timer.guest_arrival_cleanup
                duration: '00:30:00'

# Handle guest departures ... everything concerning guest suites is handled by the Remove Guest From Suite script. Other tasks
# like closing the garage are done here.
- alias: Handle Guest Departure
  id: handle_guest_departure
  mode: queued
  
  triggers:
    
    # Adults depart.
    - trigger: state
      entity_id:
        - person.david
        - person.sarah
        - person.mike
      from: 'home'
      id: adult
    
    # Children depart.
    - trigger: state
      entity_id:
        - person.skylar
      from: 'home'
      id: child
  
  actions:
    - variables:
        guest: "{{ trigger.to_state.attributes.friendly_name }}"
        suite: "{{ iif(guest in states('input_select.studio_guests'), 'Studio', 'Penthouse') }}"
    
    # Remove the triggering guest from the appropriate suite.
    - action: script.remove_guest_from_suite
      data:
        guest: "{{ guest }}"
        suite: "{{ suite }}"
    
    # Perform tasks for adults.
    - if:
        - "{{ trigger.id == 'adult' }}"
      
      then:
        
        # Close garage door.
        - action: script.turn_on
          target:
            entity_id: script.close_garage_door_north
          data:
            variables:
              use_info_message: true
            
        # Turn off outdoor lights, in case they were on to assist departure.
        - action: light.turn_off
          target:
            entity_id: light.outdoor_lights

#================================#
#     Guest Suite Management     #
#================================#

# Modify the guest suite occupancy. This is done using the dashboard.
- alias: Modify Occupied Guest Suites
  id: modify_occupied_guest_suites
  mode: queued
  
  # The triggers are dropdowns for each guest, to allow changes by any guest.
  triggers:
    - trigger: state
      entity_id: input_select.david_guest_suite
      to:
      id: David
    
    - trigger: state
      entity_id: input_select.mike_guest_suite
      to:
      id: Mike
    
    - trigger: state
      entity_id: input_select.sarah_guest_suite
      to:
      id: Sarah
    
    - trigger: state
      entity_id: input_select.skylar_guest_suite
      to:
      id: Skylar
  
  actions:
    
    # Only perform an actual switch if the guest is currently home.
    - condition: "{{ is_state('person.' ~ trigger.id | lower, 'home') }}"
    
    # Remove the triggering guest from the previous suite and add them to the current suite.
    - action: script.remove_guest_from_suite
      data:
        guest: "{{ trigger.id }}"
        suite: "{{ trigger.from_state.state }}"
    
    - action: script.add_guest_to_suite
      data:
        guest: "{{ trigger.id }}"
        suite: "{{ trigger.to_state.state }}"
    
    # If we're switching suites, send the completion event.
    - if:
        - condition: state
          entity_id: input_boolean.switch_guest_suites
          state: 'on'
      
      then:
        - event: switch_guest_suites_complete

# Handle a change to the thermostat metrics (currently only applies to the penthouse):
#
# - Number of nights a guest suite is occupied. There is only one helper for nights occupied that all guests use,
#   since only one (adult) guest occupies the suite at any one time.
# - Individual temperature range values. Each guest has their own helpers for the low/high ends of the range, that
#   are combined into temp range sensors.
- alias: Modify Thermostat Hold Metrics
  id: modify_thermostat_hold_metrics
  
  mode: queued
  
  triggers:
    - trigger: state
      entity_id: input_number.penthouse_nights_occupied
      to:
      id: nights
    
    - trigger: state
      entity_id: sensor.david_temp_range
      to:
      id: david
    
    - trigger: state
      entity_id: sensor.mike_temp_range
      to:
      id: mike
    
    - trigger: state
      entity_id: sensor.sarah_temp_range
      to:
      id: sarah
    
    - trigger: state
      entity_id: sensor.skylar_temp_range
      to:
      id: skylar
  
  conditions:
    - or:
    
        # For the nights trigger, ensure the penthouse is currently occupied.
        - "{{ trigger.id == 'nights' and is_state('binary_sensor.penthouse_occupied', 'on') }}"
        
        # For a non-nights trigger, ensure the triggering guest is currently staying in the penthouse.
        - "{{ trigger.id != 'nights' and trigger.id | title in states('input_select.penthouse_guests') }}"
  
  actions:
    
    # Start a delay timer if it's not currently running. The purpose of the timer is to allow all available metrics to be changed
    # within a reasonable time window, before actually changing the thermostat hold. For all but the first such change within the
    # window, the timer will be active so we won't do anything. 
    # 
    # Note that the timer could possibly expire while HA is restarting, so set a flag so we can handle that case when HA starts up.
    - if:
        - condition: state
          entity_id: timer.thermostat_metrics_delay
          state: idle
      
      then:        
        - action: timer.start
          data:
            entity_id: timer.thermostat_metrics_delay
            duration:
              minutes: "{{ states('input_number.thermostat_metrics_delay_minutes') }}"
        
        - action: input_boolean.turn_on
          target:
            entity_id: input_boolean.thermostat_metrics_delay_timer_started

# Handle the thermostat metrics delay timer expiration. Normally, the timer finished event will drive this automation. But if HA was 
# restarting at that time, the event is lost. So we also trigger on HA start.
- alias: Handle Thermostat Metrics Delay Timer Expiration
  id: handle_thermostat_metrics_delay_timer_expiration
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.thermostat_metrics_delay
    
    - trigger: homeassistant
      event: start
  
  # Because of the case where HA was restarting when the timer would have expired, we need to verify that the timer is indeed idle and the 
  # flag we set when we started it is on. Note that if HA was restarted but came back up before the timer expired, we would be triggered by
  # the timer finished event.
  conditions:
    - condition: state
      entity_id: timer.thermostat_metrics_delay
      state: idle
    
    - condition: state
      entity_id: input_boolean.thermostat_metrics_delay_timer_started
      state: 'on'
  
  actions:
    - action: script.modify_penthouse_thermostat_hold
    
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.thermostat_metrics_delay_timer_started

# Handle the thermostat hold delay timer expiration. This timer is started by the Modify Penthouse Thermostat Hold script, to guard against
# rapid changes to the thermostat. For example, the guest could change the temp range, then do it again shortly afterwards because they
# made a mistake.
#
# Note that we use the same mechanisms here as we do above for the temp range delay timer, to cover the HA restart case.
- alias: Handle Thermostat Hold Delay Timer Expiration
  id: handle_thermostat_hold_delay_timer_expiration
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.thermostat_hold_delay
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: state
      entity_id: timer.thermostat_hold_delay
      state: idle
    
    - condition: state
      entity_id: input_boolean.thermostat_hold_delay_timer_started
      state: 'on'
  
  actions:
    
    # Reinstate the hold using the changed information.
    - action: script.set_penthouse_thermostat_hold
    
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.thermostat_hold_delay_timer_started

#===========================================#
#     Studio Preferred Lamps Management     #
#===========================================#

# Modify studio lights if the preferred lamps are changed while the studio is occupied.
- alias: Modify Active Studio Lamps
  id: modify_active_studio_lamps
  
  triggers:
    - trigger: state
      entity_id: input_select.preferred_studio_lamps
      to:
  
  # The following must be true:
  #
  # 1) The studio must be occupied.
  # 2) It must be dark enough according to the ambient light level.
  conditions: "{{ is_state('binary_sensor.studio_occupied', 'on') and
                  states('sensor.downstairs_sensor_ambient_light') | float(0) < states('input_number.studio_bedroom_ambient_min') | float(0) }}"
  
  actions:
    - variables:
        
        # The new (just changed) preference.
        preference: "{{ states('input_select.preferred_studio_lamps') }}"
        
        # The operation to perform on each lamp.
        sarah_s_lamp_operation: >
          {{ iif(preference in ['Sarah\'s', 'Both'], 'on', 'off') }}
        skylar_s_lamp_operation: >
          {{ iif(preference in ['Skylar\'s', 'Both'], 'on', 'off') }}
    
    # Operate Sarah's lamp.
    - action: light.turn_{{ sarah_s_lamp_operation }}
      target:
        entity_id: light.sarah_s_lamp
    
    # Operate Skylar's lamp.
    - action: light.turn_{{ skylar_s_lamp_operation }}
      target:
        entity_id: light.skylar_s_lamp

#=========================#
#     Device Trackers     #
#=========================#

# Toggle virtual device trackers.
- alias: Toggle Virtual Device Tracker
  id: 'toggle_virtual_device_tracker'
  mode: queued
  
  triggers:
    - trigger: state
      entity_id:
        - input_boolean.virtual_david
        - input_boolean.virtual_maryam
        - input_boolean.virtual_mike
        - input_boolean.virtual_sarah
        - input_boolean.virtual_skylar
      to:
  
  actions:
    - variables:
        new_state: >
          {% if trigger.to_state.state == 'on' %}
            home
          {% else %}
            not_home
          {% endif %}
        
        topic_suffix: "{{ trigger.to_state.entity_id | replace('input_boolean.', '') }}"
    
    - action: mqtt.publish
      data:
        topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
        payload: "{{ new_state }}"

# Toggle phone stationary device trackers, based on the wifi SSID.
- alias: Toggle Jon Phone Stationary Tracker
  id: toggle_jon_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.jon_galaxy_wifi_connection
      ssid: White Rabbit
      topic_suffix: jon_phone_stationary

- alias: Toggle Mike Phone Stationary Tracker
  id: toggle_mike_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.mike_galaxy_wifi_connection
      ssid: White Rabbit
      topic_suffix: mike_phone_stationary

- alias: Toggle Sarah Phone Stationary Tracker
  id: toggle_sarah_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.sarah_pixel_wi_fi_connection
      ssid: White Rabbit
      topic_suffix: sarah_phone_stationary

- alias: Toggle David Phone Stationary Tracker
  id: toggle_david_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.david_s_latest_phone_wi_fi_connection
      ssid: White Rabbit
      topic_suffix: david_phone_stationary
  
# Children without personal devices use NFC tags to scan in and out.
- alias: Handle Child Tag Scan
  id: handle_child_tag_scan
  
  triggers:
    - trigger: tag
      tag_id: 0c6d2dfd-4ad7-4281-9ec0-54756ed2d539
      id: skylar
    
    - trigger: state
      entity_id: input_button.skylar_tag_scan
      id: skylar_simulated
        
  actions:
    - variables:
        tracker_entity: "{{ 'device_tracker.' ~ trigger.id.split('_')[0] ~ '_nfc_tag' }}"
        new_state: >
          {% if states(tracker_entity) != 'home' %}
            home
          {% else %}
            not_home
          {% endif %}
        topic_suffix: "{{ tracker_entity.split('.')[1] }}"
        toggle_action: "{{ iif(new_state == 'home', 'on', 'off') }}"
    
    - action: mqtt.publish
      data:
        topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
        payload: "{{ new_state }}"

#=========================#
#     Sleep Detection     #
#=========================#

# Set the sleep start time.
- alias: Set Sleep Start
  id: set_sleep_start

  triggers:
    - trigger: state
      entity_id: binary_sensor.jon_sleeping
      to: 'on'
  
  actions:
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.sleep_start
      data:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

# Handle everything that needs to be done when I wake up.
- alias: Handle Jon Awake
  id: 'handle_jon_awake'
  
  triggers:
    - trigger: state
      entity_id: binary_sensor.jon_sleeping
      from: 'on'
      to: 'off'
  
  actions:
    - variables:
        
        # Sleep duration in seconds.
        duration: "{{ ((as_timestamp(now().strftime('%Y-%m-%d %H:%M:%S')) - as_timestamp(states('input_datetime.sleep_start'))) / 3600) | round(2) }}"
        
        # List of echo devices.
        echo_list: "{{ expand(integration_entities('alexa_media') | select('search', 'media_player')) |
                       rejectattr('attributes.friendly_name', 'in', ['This Device', 'Everywhere']) | map(attribute = 'entity_id') | list }}"
    
    # Reset the Nighttime and Sleeptime flags.
    - action: input_boolean.turn_off
      entity_id:
        - input_boolean.nighttime
        - input_boolean.sleeptime
    
    # Reset the bedtime environment. Run the script in parallel, because there is a potential long wait while performing
    # master bedroom tasks, and I'd like to hear the wakeup notification ASAP.
    - action: script.turn_on
      target:
        entity_id: script.reset_bedtime_environment
    
    # Set the sleep duration time.
    - action: input_number.set_value
      target:
        entity_id: input_number.sleep_duration
      data:
        value: "{{ duration }}"
    
    # The sleep duration just set above is used to update the Sleep Duration Display sensor, which is used below.
    # Take a short nap to allow the sensor to be updated.
    - delay:
        milliseconds: 500
    
    # Normalize the volume on all echoes in case they were modified yesterday or during the night.
    # However, we're about to send an announcement to the master bedroom, and I want that to be quieter, so use a lower
    # volume for that one device for now. We normalize it after the announcement.
    - variables:
        normal_volume: 0.5
        quiet_volume: 0.3
    
    - repeat:
        for_each: "{{ echo_list }}"
        
        sequence:
          - variables:
              volume: "{{ iif((repeat.item).split('.')[1] == 'master_bedroom_echo', quiet_volume, normal_volume) }}"
              
          - if:
              - "{{ not is_state_attr(repeat.item, 'volume_level', volume) }}"
            
            then:
              - action: media_player.volume_set
                target:
                  entity_id: "{{ repeat.item }}"
                data:
                  volume_level: "{{ volume }}"
    
    # The Nighttime toggle being reset (above) causes the Manage Echo Do Not Disturb automation to run. We need to ensure
    # that the master bedroom echo has been unmuted before trying to send the announcement below.
    - repeat:
        until: "{{ is_state('switch.master_bedroom_echo_do_not_disturb_switch', 'off') }}"
        
        sequence:
          - event: unused_event
          
          - delay:
              milliseconds: 10
    
    # Now we can set the various notification data.
    - variables:
        time: "{{ states('sensor.sleep_duration_display') }}"
        hours: "{{ time.split(':')[0] | int(0) }}"
        minutes: "{{ time.split(':')[1] | int(0) }}"
        hours_str: "{{ iif(hours == 1, 'hour', 'hours') }}"
        minutes_str: "{{ iif(minutes == 1, 'minute', 'minutes') }}"
        keys: "{{ state_attr('sensor.mobile_tag_registry_keys', 'tags') }}"
        calendar: "{{ iif('calendar_appointment' in keys or 'calendar_home' in keys, true, false) }}"
          
    # Notify about the sleep duration and possible short term calendar items.
    - action: script.send_notification
      data:
        destination:
          - voice_assistant
        message: >
          {% set msg = 'Good morning. You slept ' ~ hours ~ ' ' ~ hours_str ~ iif(minutes | int(0) > 0, ' and ' ~ minutes ~ ' ' ~ minutes_str ~ '.', '.') %}
          {% if calendar == true %}
            {% set msg = msg + ' Also, check your phone for upcoming calendar items.' %}
          {% endif %}
          
          {{ msg }}
        room: ['master_bedroom']
        voice_type: tts
    
    # Turn on voice assistant screens.
    - if:
        - condition: numeric_state
          entity_id: sensor.downstairs_sensor_ambient_light
          below: input_number.family_room_ambient_max
      
      then:
        - action: scene.turn_on
          target:
            entity_id: scene.voice_assistants_on_dim
      
      else:    
        - action: scene.turn_on
          target:
            entity_id: scene.voice_assistants_on_bright
    
    # I might stay in bed for a while before actually getting up, so wait until motion is detected somewhere downstairs.
    # The Reset Bedtime Environment script (called above) calls Modify Master Suite for wakeup. That script in turn waits 
    # until downstairs motion is detected before turning off master suite lights. So we can use that to manage the island 
    # light and echo volume here.
    - wait_template: "{{ is_state('script.modify_master_suite', 'off') }}"
                  
    # Normalize the master bedroom echo volume.
    - action: media_player.volume_set
      target:
        entity_id: media_player.master_bedroom_echo
      data:
        volume_level: "{{ normal_volume }}"
    
    # Turn on island light if needed (lets me get breakfast).
    - action: script.turn_on_lights_per_conditions
      data:
        light_entity: light.kitchen_island
        lux_entity: sensor.downstairs_sensor_ambient_light
        min_lux_value: "{{ states('input_number.kitchen_ambient_min') | float(0) }}"
