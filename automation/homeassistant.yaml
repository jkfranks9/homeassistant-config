#=========================#
#     Automations Log     #
#=========================#

# Record fired automations in a log file.
- alias: Log Automations
  id: log_automations
  mode: queued
  max: 200
  
  # We trigger on all state changes, then weed out unnecessary events in the condition.
  trigger:
    - platform: event
      event_type: state_changed
  
  # Weed out non-automations and some we want to skip (including this one!). Also, verify we have a 
  # valid old and new state to work with, and that the last triggered time has changed.
  condition:
    - condition: template
      value_template: >
        {% set skip_list = [
                            'backup_log_on_shutdown', 
                            'delete_junk_log_files', 
                            'handle_shield_application_change', 
                            'initialize_turn_on_volume', 
                            'log_automations', 
                            'log_dryer_trend_sensors', 
                            'log_notifications', 
                            'log_scripts',
                            'perform_daily_chores',
                            'remove_saved_notifications_on_dismiss',
                            'restore_movie_list_on_start',
                            'restore_notifications',
                            'resume_cinema', 
                            'save_notifications_on_create', 
                            'set_maximum_attic_temperature', 
                            'set_maximum_garage_temperature', 
                            'set_maximum_outdoor_temperature',
                            'set_minimum_attic_temperature', 
                            'set_minimum_garage_temperature', 
                            'set_minimum_outdoor_temperature',
                            'trigger_floorplan_christmas_elements',
                            'update_openuv'
                           ] %}
        {{ trigger.event.data.entity_id.startswith('automation.') and
           trigger.event.data.entity_id.split('.')[1] not in skip_list and
           'old_state' in trigger.event.data and 'new_state' in trigger.event.data and
           'last_triggered' in trigger.event.data.new_state.attributes and 'last_triggered' in trigger.event.data.old_state.attributes and
           trigger.event.data.new_state.attributes.last_triggered != trigger.event.data.old_state.attributes.last_triggered }}
  
  action:
    
    # Log it.
    - service: notify.triggered_automations
      data_template:
        message: >
         {{ as_timestamp(trigger.event.data.new_state.last_updated) | timestamp_custom('%b %d: %X') }}: {{ trigger.event.data.new_state.name }}

#=====================#
#     Scripts Log     #
#=====================#

# Record fired scripts in a log file.
- alias: Log Scripts
  id: log_scripts
  mode: queued
  max: 200
  
  # We trigger on all started scripts.
  trigger:
    - platform: event
      event_type: script_started
  
  # Weed out non-scripts and some we want to skip.
  condition:
    - condition: template
      value_template: >
        {% set skip_list = [
                            'change_some_downstairs_lights',
                            'close_garage_door', 
                            'concat_auto_log_files', 
                            'concat_log_files', 
                            'concat_scripts_log_files', 
                            'evaluate_weather_condition', 
                            'popup_light_group',
                            'position_hvac_vent',
                            'reset_smart_bulbs', 
                            'resume_cinema',
                            'resume_worker', 
                            'set_datetime_offset_days', 
                            'set_datetime_offset_months', 
                            'set_datetime_offset_weeks', 
                            'set_theater_dark',
                            'start_activity', 
                            'throttle_mobile_notification', 
                            'turn_off_adguard', 
                            'turn_on_adguard', 
                            'watch_application'
                           ] %}
        {{ trigger.event.data.entity_id.startswith('script.') and
           trigger.event.data.entity_id.split('.')[1] not in skip_list }}
  
  action:
    
    # Log it.
    - service: notify.triggered_scripts
      data_template:
        message: >
         {{ as_timestamp(trigger.event.time_fired) | timestamp_custom('%b %d: %X') }}: {{ trigger.event.data.name }}

#===================#
#     Log Files     #
#===================#

# Backup the current HA log file on shutdown, so we don't lose possible debugging information.
- alias: Backup Log On Shutdown
  id: backup_log_on_shutdown
  trigger:
    - platform: homeassistant
      event: shutdown
  action:
    - service: shell_command.backup_log

# Delete junk log files left over from the above automation.
- alias: Delete Junk Log Files
  id: delete_junk_log_files
  trigger:
    - platform: homeassistant
      event: start
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - service: shell_command.delete_junk_log_files

#======================#
#     Daily Chores     #
#======================#

# Perform various daily chores.
- alias: Perform Daily Chores
  id: 'perform_daily_chores'
  trigger:
    - platform:  time
      at: '01:01:01'
  action:
    
    # Reset manual exercise controls.
    - service: input_number.set_value
      target:
        entity_id: input_number.yard_work_time
      data:
        value: 0
    
    - service: input_number.set_value
      target:
        entity_id: input_number.weight_training_time
      data:
        value: 0
    
    # Reset occupied bedrooms.
    - choose:
      
      # If children are home without adults, default to the downstairs guest bedroom.
      - conditions:
        - condition: template
          value_template: "{{ is_state('input_boolean.adults_home', 'off') and is_state('input_boolean.children_home', 'on') }}"
        
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: Downstairs
      
      # Otherwise, default to none.
      default:
        - service: input_select.select_option
          target:
            entity_id: input_select.occupied_bedrooms
          data:
            option: None
    
    # Turn off washer plug.
    - service: switch.turn_off
      entity_id: switch.sonoff_washer
    
    # Backup automations and scripts log files.
    - service: shell_command.backup_auto_log
    
    - service: shell_command.backup_scripts_log
    
    # Temporarily make sure the dryer isn't running.
    - service: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    
    # Backup the dryer trend sensors log file if indicated.
    - condition: state
      entity_id: input_boolean.backup_dryer_trend_sensors_log
      state: 'on'
    
    - service: shell_command.backup_dryer_trend_sensors_log
    
    - service: input_boolean.turn_off
      entity_id: input_boolean.backup_dryer_trend_sensors_log

#===================================#
#     Kodi Media Player Logging     #
#===================================#
     
# The Kodi media player has a tendency to fill the log with useless error messages, because the player can't
# be contacted on an async_update(), which happens every 10 seconds. Count these events so we can restart HA if 
# the situation persists for ~5 minutes.
- alias: Detect Kodi Error Loop
  id: detect_kodi_error_loop
  trigger:
    - platform: event
      event_type: system_log_event
      event_data:
        name: 'homeassistant.components.kodi.media_player'
        level: 'ERROR'
  #condition:
  #  - condition: template
  #    value_template: "{{ 'Error calling async_update on entity media_player.kodi: TransportError' in trigger.event.data.message }}"
  action:
    - service: counter.increment
      data:
        entity_id: counter.kodi_errors

# Restart HA if the kodi error loop situation exists (see above).
- alias: Handle Kodi Error Loop
  id: handle_kodi_error_loop
  trigger:
    - platform: state
      entity_id: counter.kodi_errors
  condition:
    - condition: template
      value_template: "{{ trigger.to_state.state | int(0) >= 30 }}"
  action:
    - service: persistent_notification.create
      data:
        title: 'Home Assistant Restarted'
        notification_id: 'kodi_error_loop'
        message: 'Home Assistant was restarted due to excessive Kodi media player errors.'
    - service: homeassistant.restart

# Reset the counter after a few minutes since we're not interested in occasional sporadic errors.
- alias: Reset Kodi Error Counter
  id: reset_kodi_error_counter
  trigger:
    - platform: time_pattern
      minutes: '/7'
  condition:
    - condition: template
      value_template: "{{ states('counter.kodi_errors')|int(0) > 0 }}"      
  action:
    - service: counter.reset
      entity_id: counter.kodi_errors

#==================================#
#     Persistent Notifications     #
#==================================#

# NOTE: This was originally obtained as a package (I forget where). But I've had to debug it and
#       make changes, so it's now just included with all the other automations instead of a package.

# Save notifications to MQTT when they are created.
- alias: Save Notifications On Create
  id: save_notifications_on_create
  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: persistent_notification
        service: create
  condition:
    - condition: template
      value_template: >-
        {{ trigger.event.data.service_data.notification_id != 'config_entry_discovery' }}
  action:
    - service: mqtt.publish
      data_template:
        topic: "home-assistant/notifications/{{ trigger.event.data.service_data.notification_id }}"
        payload: >-
          {
            'notification_id' : "{{ trigger.event.data.service_data.notification_id }}",
            'title' : "{{ trigger.event.data.service_data.title }}",
            'message' : "{{ trigger.event.data.service_data.message }}"
          }
        retain: true

# Remove saved notifications from MQTT when they are dismissed.
- alias: Remove Saved Notifications On Dismiss
  id: remove_saved_notifications_on_dismiss
  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: persistent_notification
        service: dismiss
  condition:
    - condition: template
      value_template: >-
        {{ trigger.event.data.service_data.notification_id != 'config_entry_discovery' }}
  action:
    - service: mqtt.publish
      data_template:
        topic: "home-assistant/notifications/{{ trigger.event.data.service_data.notification_id }}"
        retain: true

# Restore persistent notifications (the whole point).
#
# This one is tricky:
#   - It's triggered by the above save_notifications_on_create automation, since that one publishes an MQTT message.
#   - The condition compares the triggered message with the entity ID 'persistent_notification.[notification ID]':
#       - This entity is created to represent the retained MQTT message
#       - This sometimes creates an error in the log indicating the MQTT message has no payload_json attribute.
#         I've used the log_notifications automation below to try and debug, but it shows the payload_json attribute is
#         present. Not really sure what is going on, since all this stuff does indeed work - I suspect some sort of timing
#         problem.
#   - If the comparison is true then the message has changed since it was originally issued, and the action then creates
#     a new persistent notification to replace the original, thus driving save_notifications_on_create, which in turn re-drives
#     this, but the condition should be false on the redrive.
#   - Note that dashes in the notification ID are changed to underscores, presumably to prevent some problem.
- alias: Restore Notifications
  id: restore_notifications
  trigger:
    - platform: mqtt
      topic: home-assistant/notifications/+
  condition:
    - condition: template
      value_template: >-
        {{ trigger.payload != '' and state_attr('persistent_notification.' + trigger.payload_json.notification_id | replace('-','_'),'message') != trigger.payload_json.message }}
  action:
    - service: persistent_notification.create
      data_template:
        title: >-
          {{ trigger.payload_json.title }}
        message: >-
          {{ trigger.payload_json.message }}
        notification_id: >-
          {{ trigger.payload_json.notification_id }}

# Log the published MQTT message for debugging purposes (normally turned off).
- id: log_notifications
  alias: Log Notifications
  trigger:
    - platform: mqtt
      topic: home-assistant/notifications/+
  action:
    - service: system_log.write
      data:
        message: "notification: '{{ trigger.payload }}'"
        level: info

#========================#
#     Christmas Mode     #
#========================#

# I want to only show certain elements on the floorplan at Christmas time. This requires two different
# floorplan image and dashboard files. When Christmas mode changes, copy the appropriate files.
- alias: Trigger Floorplan Christmas Elements
  id: 'trigger_floorplan_christmas_elements'
  trigger:
    - platform: state
      entity_id: input_boolean.christmas_mode
  action:
    - choose:
      - conditions: "{{ is_state('input_boolean.christmas_mode', 'on') }}"          
        sequence:
          - service: shell_command.copy_floorplan_christmas
      default:
        - service: shell_command.copy_floorplan_normal
