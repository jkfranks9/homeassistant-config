#========================#
#     Startup Chores     #
#========================#

- alias: Perform Startup Chores
  id: perform_startup_chores
  
  triggers:
    - trigger: homeassistant
      event: start
  
  actions:
    
    # Delete junk log files left over from backing up the logs on shutdown.
    - action: shell_command.delete_junk_log_files 
    
    # We have an input select that represents the list of Kodi movies. This is dynamically set using the 
    # Process All Kodi Movies Result script. However, when HA restarts, the input select gets restored to the yaml value
    # instead of the dynamically set value. So we restore the dynamic list on HA start.
    #
    # The actual list should exist in a file that was saved at Process All Kodi Movies Result time, and the feature
    # movie name (input select state value) exists in input_text.current_feature.
    
    # Turn on a flag to prevent any other automations or scripts mucking with the feature movie name until
    # restoration is complete.
    - action: input_boolean.turn_on
      data:
        entity_id: input_boolean.kodi_movie_list_restoration
    
    # Call a pyscript module to restore the movie list.
    - action: pyscript.restore_input_select_options
      data:
        entity: input_select.kodi_movies
        file: '/config/all_movies_backup'
    
    # Wait until the list is restored (state not equal to the static yaml value).
    - wait_template: "{{ not is_state('input_select.kodi_movies', 'Select') }}"
      timeout: '00:00:10'
    
    # Set the current feature movie as the selected option in the list.
    - action: input_select.select_option
      data:
        entity_id: input_select.kodi_movies
        option: "{{ states('input_text.current_feature') }}"
    
    # Turn off the restoration flag.
    - action: input_boolean.turn_off
      data:
        entity_id: input_boolean.kodi_movie_list_restoration
    
    # TEMPORARY until Alexa Media Player startup problem is fixed.
    - delay: '00:00:30'
    
    - action: homeassistant.reload_config_entry
      target:
        entity_id: media_player.office_echo

#=====================#
#     MQTT Chores     #
#=====================#

# We need to wait until the MQTT broker is active after a restart to perform various MQTT chores. This may take
# a little time after HA startup.
- alias: Perform MQTT Chores
  id: perform_mqtt_chores
  
  triggers:
    - trigger: mqtt
      topic: homeassistant/status
      payload: 'online'
  
  actions:
    
    # Reinitialize virtual and NFC tag device trackers.
    - variables:
        vtrack_entities: >
          {% set var = namespace(vtrack = []) %}
          {% for state in states.input_boolean %}
            {% if 'Virtual' in state.name %}
              {% set var.vtrack = var.vtrack + [state.entity_id] %}
            {% endif %}
          {% endfor %}
          {% for state in states.input_boolean %}
            {% if 'NFC Tag' in state.name %}
              {% set var.vtrack = var.vtrack + [state.entity_id] %}
            {% endif %}
          {% endfor %}
          
          {{ var.vtrack }}
    
    - repeat:
        for_each: "{{ vtrack_entities }}"
        
        sequence:
          - variables:
              topic_suffix: "{{ repeat.item | replace('input_boolean.', '') }}"
          
          - if:
              - "{{ states(repeat.item) == 'on' }}"
            
            then:          
              - action: mqtt.publish
                data:
                  topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
                  payload: home
            
            else:          
              - action: mqtt.publish
                data:
                  topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
                  payload: not_home 
    
    # Set up MQTT discovery sensors to keep track of the last changed time for interesting entities.
    - variables:
        suffix: 'last_changed'    
        items:
          - "{{ 'ups_' ~ suffix }}"
          - "{{ 'garage_door_north_' ~ suffix }}"
          - "{{ 'garage_door_south_' ~ suffix }}"
          - "{{ 'treadmill_' ~ suffix }}"
          - "{{ 'washer_' ~ suffix }}"
          - "{{ 'workout_' ~ suffix }}"
    
    - repeat:
        count: "{{ items | length }}"
        
        sequence:
          - action: script.set_up_mqtt_automated_config
            data:
              domain: sensor
              unique_id: "{{ items[repeat.index - 1] }}"
              device_class: timestamp

#=========================#
#     Shutdown Chores     #
#=========================#

- alias: Perform Shutdown Chores
  id: perform_shutdown_chores
  
  trigger:
    - platform: homeassistant
      event: shutdown
  
  action:
    
    # Backup the current HA log file on shutdown, so we don't lose possible debugging information.
    - service: shell_command.backup_log

#======================#
#     Daily Chores     #
#======================#

# Perform various daily chores.
- alias: Perform Daily Chores
  id: 'perform_daily_chores'
  
  triggers:
    - trigger: time
      at: '01:01:01'
  
  actions:
    - variables:
        day_of_week: "{{ as_timestamp(now()) | timestamp_custom('%w') | int(0) }}"
        day_of_month: "{{ now().day }}"
    
    # Reset the recordable exercise toggle. This is used in the Register Exercise Metrics script so we only bump the
    # associated count once per day.
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.exercise_recordable
    
    # Reset daily exercise values.
    - action: input_number.set_value
      target:
        entity_id:
          - input_number.treadmill_daily_time
          - input_number.treadmill_daily_calories
          - input_number.workout_daily_time
          - input_number.workout_daily_calories
          - input_number.yard_work_daily_time
          - input_number.yard_work_daily_calories
          - input_number.steps_daily
          - input_number.steps_daily_calories
      data:
        value: 0
    
    # Turn on most automations that may have been turned off. This is normally not needed, but some can be left off
    # if certain automations or scripts do not finish normally.
    #
    # Don't touch the few that are turned off most of the time, or for extended periods.
    - action: automation.turn_on
      entity_id:
        - automation.determine_cpap_filter_target_day
        - automation.run_studio_motion_based_light
        - automation.update_last_alexa_device
    
    # Some automations that could be off should only be turned back on conditionally.
    - if:
        - condition: state
          entity_id: update.zigbee2mqtt_update
          state: 'off'
      
      then:
        - action: automation.turn_on
          entity_id: automation.notify_zigbee_device_unavailable
    
    # Backup automations and scripts log files.
    - action: shell_command.backup_auto_scripts_log

    # Make sure the dryer isn't running, just in case.
    - action: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    
    # Backup the laundry events log file if indicated.
    - if:
        - condition: state
          entity_id: input_boolean.backup_laundry_log
          state: 'on'
      
      then:    
        - action: shell_command.backup_laundry_log
        
        - action: input_boolean.turn_off
          entity_id: input_boolean.backup_laundry_log
    
    # Update the hockey Rest sensors during hockey season. The sensors have a very long scan interval so
    # they don't try to update when there's no hockey.
    - if:
        - condition: state
          entity_id: input_boolean.hockey_season
          state: 'on'
      
      then:
        - if:
            - condition: state
              entity_id: input_boolean.hockey_canes_active
              state: 'on'
          
          then:        
            - action: homeassistant.update_entity
              target:
                entity_id: sensor.next_canes_game
              continue_on_error: true
        
        - if:
            - condition: state
              entity_id: input_boolean.hockey_flyers_active
              state: 'on'
          
          then:        
            - action: homeassistant.update_entity
              target:
                entity_id: sensor.next_flyers_game
              continue_on_error: true
    
    # Bump the F150 mileage. We use this to notify when the next service is due.
    - action: input_number.set_value
      target:
        entity_id: input_number.f150_mileage
      data:
        value: "{{ states('input_number.f150_mileage') | int(0) + 32 }}"
    
    # In rare situations the theater open toggle can be left on. Reset it if adults are not home and the Harmony remote
    # is in power off state.
    - if:
        - condition: state
          entity_id: input_boolean.theater_open
          state: 'on'
        
        - condition: state
          entity_id: binary_sensor.adults_home
          state: 'off'
        
        - condition: state
          entity_id: sensor.harmony_hub
          state: 'PowerOff'
      
      then:   
        - action: input_boolean.turn_off
          target:
            entity_id: input_boolean.theater_open
    
    # Reset the pool salt system low temperature notification toggle.
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.salt_system_low_temperature
    
    # Reset the automations that control family room lighting, so that the family room lamp will be
    # used at wakeup time. Control Family Room Light Automations will flip them back to Christmas lights
    # if Christmas mode is on, when the sun stops rising.
    - action: automation.turn_on
      entity_id: automation.control_family_room_lamp
    
    - action: automation.turn_off
      entity_id: automation.control_christmas_lights
      
    # Run a daily Watchman report.
    - action: watchman.report
      data:
        parse_config: false
        create_file: true
    
    # Reset the default guest suite preferences for all guests not currently home.
    - repeat:
        for_each:
          - 'david'
          - 'mike'
          - 'sarah'
          - 'skylar'
        
        sequence:
          - if:
              - "{{ not is_state('person.' ~ repeat.item, 'home') }}"
            
            then:
              - action: input_select.select_first
                target:
                  entity_id: "{{ 'input_select.' ~ repeat.item ~ '_guest_suite' }}"
    
    # Perform weekly chores at the start of a new week (Sunday).
    - if:
        - "{{ day_of_week == 0 }}"
      
      then:
        
        # Reset weekly exercise values.
        - action: input_number.set_value
          target:
            entity_id:
              - input_number.treadmill_weekly_time
              - input_number.treadmill_weekly_calories
              - input_number.workout_weekly_time
              - input_number.workout_weekly_calories
              - input_number.yard_work_weekly_time
              - input_number.yard_work_weekly_calories
              - input_number.steps_weekly
              - input_number.steps_weekly_calories
          data:
            value: 0
        
        # Generate the weekly mini todo stuff:
    
        # 1) Toggle the generator switch, which introduces randomness into some decisions.
        - action: input_boolean.toggle
          entity_id: input_boolean.mini_todo_generator_switch
        
        # 2) Create weekly periodic lists.
        - action: script.generate_periodic_lists
          data:
            type: all
            start_date: "{{ states('sensor.date') }}"
        
        # 3) Determine which days will be free time this week.
        - action: script.generate_weekly_free_time_days
    
    # Perform monthly chores at the start of a new month.
    - if:
        - "{{ day_of_month == 1 }}"
      
      then:
        
        # Reset monthly exercise values.
        - action: input_number.set_value
          target:
            entity_id:
              - input_number.treadmill_monthly_time
              - input_number.treadmill_monthly_calories
              - input_number.workout_monthly_time
              - input_number.workout_monthly_calories
              - input_number.yard_work_monthly_time
              - input_number.yard_work_monthly_calories
              - input_number.steps_monthly
              - input_number.steps_monthly_calories
          data:
            value: 0
    
        # Reset monthly exercise and recordable counts.    
        - action: counter.reset
          target:
            entity_id:
              - counter.treadmill_days
              - counter.workout_days
              - counter.yard_work_days
              - counter.steps_days
              - counter.exercise_recordable
        
        # Backup the exercise activity log.
        - action: shell_command.backup_exercise_log

#=========================#
#     Automations Log     #
#=========================#

# Record fired automations in a log file.
- alias: Log Automations
  id: log_automations
  mode: queued
  max: 200
  
  trace:
    stored_traces: 20
  
  # We trigger on all automation triggers.
  triggers:
    - trigger: event
      event_type: automation_triggered
  
  # Weed out automations we want to skip (including this one!).
  conditions:
    - condition: template
      value_template: >
        {% set skip_list = [
                            'log_automations',
                            'log_scripts',
                            'set_maximum_attic_temperature', 
                            'set_maximum_garage_temperature', 
                            'set_maximum_outdoor_temperature',
                            'set_minimum_attic_temperature', 
                            'set_minimum_garage_temperature', 
                            'set_minimum_outdoor_temperature',
                            'set_washer_operation'
                           ] %}
        {{ trigger.event.data.entity_id.split('.')[1] not in skip_list }}
  
  actions:
    
    # Log it.
    - action: notify.send_message
      target:
        entity_id: notify.automations_scripts
      data:
        message: >
         {{ as_timestamp(trigger.event.time_fired) | timestamp_custom('%b %d: %X') }}: (A) {{ trigger.event.data.name }}

#=====================#
#     Scripts Log     #
#=====================#

# Record fired scripts in a log file.
- alias: Log Scripts
  id: log_scripts
  mode: queued
  max: 200
  
  trace:
    stored_traces: 20
  
  # We trigger on all started scripts.
  triggers:
    - trigger: event
      event_type: script_started
  
  # Weed out scripts we want to skip.
  conditions:
    - condition: template
      value_template: >
        {% set skip_list = [
                            'log_laundry_event',
                            'mobile_notification_worker',
                            'restore_lighting_on_resume',
                            'resume_cinema',
                            'resume_worker', 
                            'set_datetime_offset_days', 
                            'set_datetime_offset_months', 
                            'set_datetime_offset_weeks', 
                            'set_fan_to_speed', 
                            'set_theater_dark',
                            'set_theater_dark_delay',
                            'set_theater_dim',
                            'set_theater_idle'
                           ] %}
        {{ trigger.event.data.entity_id.split('.')[1] not in skip_list }}
  
  actions:
    
    # Log it.
    - action: notify.send_message
      target:
        entity_id: notify.automations_scripts
      data:
        message: >
         {{ as_timestamp(trigger.event.time_fired) | timestamp_custom('%b %d: %X') }}: (S) {{ trigger.event.data.name }}

#========================#
#     YAML Log Level     #
#========================#

# Change the log level used in automations & scripts.
# NOTE: The default is specified in the logger configuration using:
#   homeassistant.components.system_log.external
- alias: Change YAML Log Level
  id: change_yaml_log_level
  
  # Trigger on changes to the YAML Log Level dropdown (available on the dashboard).
  triggers:
    - trigger: state
      entity_id: input_select.yaml_log_level
  
  actions:
    - action: logger.set_level
      data:
        homeassistant.components.system_log.external: "{{ trigger.to_state.state }}"

#==================================#
#     Persistent Notifications     #
#==================================#

# Save notifications to MQTT when they are created. Since they are retained messages, they get reloaded by the MQTT 
# broker when HA restarts.
- alias: Save Notifications On Create
  id: save_notifications_on_create  
  mode: queued
  
  triggers:
    - trigger: persistent_notification
      update_type:
        - added
        - updated
        - current
  
  conditions: "{{ trigger.notification.notification_id != 'config_entry_discovered' }}"
  
  actions:
    - action: mqtt.publish
      data_template:
        topic: "homeassistant/notifications/{{ trigger.notification.notification_id }}"
        payload: >-
          {
            'notification_id' : "{{ trigger.notification.notification_id }}",
            'title' : "{{ trigger.notification.title }}",
            'message' : "{{ trigger.notification.message }}"
          }
        retain: true

# Remove saved notifications from MQTT when they are dismissed.
- alias: Remove Saved Notifications On Dismiss
  id: remove_saved_notifications_on_dismiss
  mode: queued
  
  trigger:
    - trigger: persistent_notification
      update_type:
        - removed
  
  condition: "{{ trigger.notification.notification_id != 'config_entry_discovery' }}"
  
  action:
    - service: mqtt.publish
      data_template:
        topic: "homeassistant/notifications/{{ trigger.notification.notification_id }}"
        retain: true

#========================#
#     MQTT Discovery     #
#========================#

# Publish state & attributes for MQTT last changed sensors.
- alias: Publish MQTT Automated States
  id: publish_mqtt_automated_states
  mode: parallel
  
  triggers:
    
    # Device triggers
    - trigger: state
      entity_id: sensor.cyber1_status_data
      to: 'OB DISCHRG'
      for: '00:01:00'
      id: ups
    
    - trigger: state
      entity_id: cover.garage_door_north
      from: 'closed'
      to: 'open'
      id: garage_door_north
    
    - trigger: state
      entity_id: cover.garage_door_south
      from: 'closed'
      to: 'open'
      id: garage_door_south
    
    - trigger: state
      entity_id: input_select.washer_state
      from: 'Off'
      not_to:
        - 'Unknown'
        - 'unknown'
        - 'unavailable'
      id: washer
    
    # Exercise triggers
    - trigger: state
      entity_id: input_boolean.treadmill_triggered
      from: 'off'
      to: 'on'
      id: treadmill
    
    - trigger: numeric_state
      entity_id: input_number.workout_daily_time
      above: 0
      id: workout
  
  variables:
    valid: >
      {{ trigger | default(none) is not none and trigger.to_state is defined and trigger.from_state is defined }}
    
    timestamp: >
      {{ (datetime | default(now())).isoformat() }}
    
    unique_id: >
      {{ trigger.id }}_last_changed
  
  conditions: "{{ valid }}"

  actions:
    - action: script.publish_mqtt_automated_states
      data:
        domain: sensor
        unique_id: "{{ unique_id }}"
        state: "{{ timestamp }}"
        attributes: {}

#========================#
#     Zigbee Devices     #
#========================#

# The Zigbee device unavailable notification is triggered unintentionally when the Zigbee2MQTT add-on is updated.
# Detect that here and disable the notification automation; re-enable it after the update is complete.
- alias: Toggle Zigbee Unavailable Notification
  id: toggle_zigbee_unavailable_notification
  
  triggers:
    - trigger: state
      entity_id: update.zigbee2mqtt_update
      from: 'off'
      to: 'on'
      id: 'off'
    
    - trigger: state
      entity_id: update.zigbee2mqtt_update
      from: 'on'
      to: 'off'
      id: 'on'
  
  actions:
    - action: automation.turn_{{ trigger.id }}
      entity_id: automation.notify_zigbee_device_unavailable

#=======================#
#     Hockey Season     #
#=======================#

- alias: Toggle Hockey Hobby
  id: toggle_hockey_hobby
  
  triggers:
    - trigger: state
      entity_id: input_boolean.hockey_season
      from: 'off'
      to: 'on'
      id: 'on'
    
    - trigger: state
      entity_id: input_boolean.hockey_season
      from: 'on'
      to: 'off'
      id: 'off'
  
  actions:
    
    # Toggle the notification automations.
    - action: automation.turn_{{ trigger.id }}
      entity_id:
        - automation.notify_next_canes_game
        - automation.notify_next_flyers_game
    
    # Toggle the team active toggles. These can be turned off using the dashboard if a team doesn't make the playoffs :(
    - action: input_boolean.turn_{{ trigger.id }}
      entity_id:
        - input_boolean.hockey_canes_active
        - input_boolean.hockey_flyers_active

#======================#
#     Mobile Texts     #
#======================#

# I'm using the last notification sensor from the HA companion app on my phone. If I'm not available
# to respond (sleeping, on the treadmill, maybe driving), and the text is from a family member, I want
# to send a response indicating I can't respond right now.
- alias: Respond To Mobile Text
  id: respond_to_mobile_text
  mode: queued
  
  # Trigger on any state change to the last notification sensor.
  triggers:
    - trigger: state
      entity_id: sensor.jon_galaxy_last_notification
      to:
  
  variables:
    title: "{{ state_attr('sensor.jon_galaxy_last_notification', 'android.title') }}"
    text: "{{ state_attr('sensor.jon_galaxy_last_notification', 'android.text') }}"
    category: "{{ state_attr('sensor.jon_galaxy_last_notification', 'category') }}"
    
    # This could be a group text, so create a list.
    persons: >
      {% set var = namespace(list = []) %}
      {% if 'Michael' in title or 'Michael' in text %}
        {% set var.list = var.list + ['Michael'] %}
      {% endif %}
      {% if 'Maryam' in title or 'Maryam' in text %}
        {% set var.list = var.list + ['Maryam'] %}
      {% endif %}
      {% if 'Sarah' in title or 'Sarah' in text %}
        {% set var.list = var.list + ['Sarah'] %}
      {% endif %}
      {% if 'David' in title or 'David' in text %}
        {% set var.list = var.list + ['David'] %}
      {% endif %}
      {% if var.list | length == 0 %}
        {% set var.list = var.list + ['Stranger'] %}
      {% endif %}
      
      {{ var.list }}
    
    # Possible reasons to respond.
    on_treadmill: "{{ states('input_boolean.treadmill_triggered') == 'on' }}"
    sleeping: "{{ states('input_boolean.sleeptime') == 'on' }}"
    driving: "{{ states('binary_sensor.jon_driving') == 'on' }}"
  
  conditions:
    - and:
    
      # Weed out emails.
      - "{{ category != 'email' }}"
    
      # Text must be from family member.
      - "{{ persons[0] != 'Stranger' }}"
      
      # And any of the following. These are all mutually exclusive.
      - or:
    
        # I'm on the treadmill.
        - "{{ on_treadmill }}"
    
        # I'm sleeping.
        - "{{ sleeping }}"
    
        # I'm driving.
        - "{{ driving }}"
  
  actions:
    
    # Repeat for each person.
    - repeat:
        for_each: "{{ persons }}"
        
        sequence:
          - variables:  
              timer_entity: "{{ 'timer.text_response_delay_' ~ repeat.item | lower }}"
          
          # Verify the response delay timer for this person is not running.
          - condition: "{{ states(timer_entity) == 'idle' }}"
          
          - variables:
              number: >
                {% if repeat.item == 'Michael' %}
                  9199246845
                {% elif repeat.item == 'Maryam' %}
                  9197571974
                {% elif repeat.item == 'Sarah' %}
                  2522302146
                {% elif repeat.item == 'David' %}
                  2522991689
                {% else %}
                  0000000000
                {% endif %}
            
              activity: >
                {% if on_treadmill %}
                  on the treadmill
                {% elif sleeping %}
                  asleep, and dreaming of {{ ('sugarplums', 'aliens', 'flying', 'weasels', 'being lost in an everchanging city', 'trying to find a bathroom', 'ghosts messing with electricity') | random }}
                {% elif driving %}
                  driving, or at least in a vehicle
                {% else %}
                  unavailable for some unknown reason
                {% endif %}
        
          # Send the response via gmail to the mobile number.
          - action: notify.gmail
            data:
              title: ' '
              target: "{{ number ~ '@vtext.com' }}"
              message: "{{ 'Sorry, I am ' ~ activity ~ '. I will respond when available.' }}"
            
          # Start the response delay timer for this person.
          - action: timer.start
            data:
              entity_id: "{{ timer_entity }}"
              duration: 300

#========================#
#     Mini ToDo List     #
#========================#

# Create today's mini todo list. We do this in several steps:
#
# 1) Add calendar tasks if any exist, and calculate the amount of time remaining for other tasks.
# 2) Add a free time task if needed - if so there is nothing else to do.
# 3) Add other types of tasks as needed in a loop, to either fill up the remaining time, or until the maximum tasks have been added.
- alias: Create Daily Mini ToDo List
  id: create_daily_mini_todo_list
  
  triggers:
    - trigger: time
      at: '05:00:00'
  
  actions:
    
    # If for some reason any of the weekly lists are unknown or unavailable, regenerate them, starting with the most recent Sunday,
    # which can be in the past, or today.
    - variables:
        weekly_list_entities: ['sensor.mini_todo_weekly_cleaning_list', 'sensor.mini_todo_weekly_other_list', 'sensor.mini_todo_weekly_yard_work_list']
        start_date: >
          {% set day = now().isoweekday() %}
          {% set offset = iif(day <= 6, day, 0) %}
          {{ as_datetime(states('sensor.date')) - timedelta(days = offset) }}
    
    - repeat:
        for_each: "{{ weekly_list_entities }}"
        
        sequence:
          - if:
              - "{{ states(repeat.item) in ['unknown', 'unavailable'] }}"
            
            then:
              - variables:
                  type: "{{ repeat.item.split('sensor.mini_todo_weekly_')[-1] | replace('_list', '') }}"
              
              - action: script.generate_periodic_lists
                data:
                  type: "{{ type }}"
                  start_date: "{{ start_date }}"
    
    # Get the weather metrics, which are then input to the Outdoor Work Friendly binary sensor. This in turn is needed so we can know
    # whether or not to add outdoor tasks.
    - action: script.get_weather_metrics
    
    # Clear the todo list for today.
    - event: reset_mini_todo_items
    
    # Wait until the list is cleared before continuing.
    - wait_template: "{{ state_attr('sensor.daily_mini_todo_list', 'items') | count == 0 }}"
    
    - variables:
        
        # Calendar and processing variables.
        window_lower_bound: "{{ states('input_datetime.mini_todo_start_time') }}"
        window_upper_bound: "{{ states('input_datetime.mini_todo_end_time') }}"
        start_time: "{{ states('sensor.date') ~ ' ' ~ window_lower_bound }}"
        end_time: "{{ states('sensor.date') ~ ' ' ~ window_upper_bound }}"
        total_minutes: "{{ (((as_timestamp(end_time) - as_timestamp(start_time)) / 60) - states('input_number.mini_todo_downtime_minutes') | int(0)) }}"
        
    # Initialize the available minutes using the daily start and end times, minus down time (for lunch and breaks).
    - action: input_number.set_value
      target:
        entity_id: input_number.mini_todo_available_minutes
      data:
        value: "{{ total_minutes }}"
        
    # Initialize the number of tasks in the list. I tried to just use the length of the list but for some odd reason
    # that sometimes produces the wrong number.
    - action: counter.reset
      target:
        entity_id: counter.mini_todo_tasks
    
    # Initialize the major item added toggle. We only allow one major item per day.
    - action: input_boolean.turn_off
      data:
        entity_id: input_boolean.mini_todo_major_item_added
    
    # Add any calendar items for today first. These are important to know about, and the amount of time they consume must be
    # accounted for before we do anything else.
    - action: script.add_mini_todo_calendar_items
      data:
        window_lower_bound: "{{ window_lower_bound }}"
        window_upper_bound: "{{ window_upper_bound }}"
        start_time: "{{ start_time }}"
        end_time: "{{ end_time }}"
    
    # If this is a free time day, just add that to the list and go away. Weekly Free Time Days is a bitmask, where the 
    # least significant bit is Sunday.
    - if:
        - "{{ states('input_number.mini_todo_weekly_free_time_days') | int(0) | bitwise_and(2 ** now().isoweekday()) > 0 }}"
      
      then:
        - event: add_mini_todo_item
          event_data:
            value: 'ft:FREE TIME'
                    
        # Bump the tasks counter.
        - action: counter.increment
          target:
            entity_id: counter.mini_todo_tasks
        
        - stop: Free day
    
    # Initialize the attempts count. Since we're checking within the called scripts if the task to be added fits within the remaining
    # available time, we might not find anything that works, which could lead to a large or infinite loop. To avoid this, we only attempt
    # to find tasks a small finite number of times.
    - action: counter.reset
      target:
        entity_id: counter.mini_todo_attempts
    
    # I want to give priority to cleaning and yard work items, so do one of each of those (if any exist) before starting the loop below.
    - if:
        - "{{ state_attr('sensor.mini_todo_weekly_cleaning_list', 'items') | length > 0 }}"
      
      then:
        - action: script.add_mini_todo_periodic_item
          data:
            type: cleaning
    - if:
        - "{{ state_attr('sensor.mini_todo_weekly_yard_work_list', 'items') | length > 0 }}"
      
      then:
        - action: script.add_mini_todo_periodic_item
          data:
            type: yard_work
    
    # Now add other items until we've used up the available time or hit the max items or attempts. This is done with priority in mind, 
    # but is also subject to coin tosses.
    - variables:
        task_count: "{{ 5 - states('counter.mini_todo_tasks') | int(0) }}"
    
    - repeat:
        while: "{{ states('input_number.mini_todo_available_minutes') | int(total_minutes) > 0 and 
                   states('counter.mini_todo_tasks') | int(0) < task_count and
                   states('counter.mini_todo_attempts') | int(0) <= 10 }}"
        
        sequence:
          - variables:
              type: "{{ ['cleaning', 'other', 'yard_work', 'major', 'minor'] | random }}"
          
          # Log diagnostics.
          - action: system_log.write
            data:
              message: "{{ 'iteration ' ~ repeat.index ~ ': type=' ~ type ~ ', avail=' ~ states('input_number.mini_todo_available_minutes') ~ ', tasks=' ~ states('counter.mini_todo_tasks') ~ ', attempts=' ~ states('counter.mini_todo_attempts') }}"
              level: debug
          
          # Although we have code in Insert Mini ToDo Item to detect duplicate items, I have seen duplicates get added anyway. I'm guessing
          # that it must be a timing issue with the event to add to the Daily Mini ToDo List. So introduce a small delay. Doing so here also
          # covers the cleaning and yard work tasks that are potentially added before this loop.
          - delay:
              milliseconds: 500
          
          - choose:
          
            # Add a periodic task.
            - conditions: "{{ type in ['cleaning', 'other', 'yard_work'] }}"
              
              sequence:
                - if: "{{ range(2) | random > 0 }}"
                
                  then:
                    - action: script.add_mini_todo_periodic_item
                      data:
                        type: "{{ type }}"
            
            # Add a project task.
            - conditions: "{{ type in ['major', 'minor'] }}"
              
              sequence:
                - if: "{{ range(2) | random > 0 }}"
                
                  then:
                    - action: script.add_mini_todo_project_item
                      data:
                        type: "{{ type }}"

#===============================#
#     Integration Reloading     #
#===============================#

# Some integrations seem to go berserk sometimes. We watch for certain error messages or states, and reload the associated
# config entry to hopefully restore sanity.

- alias: Reload Unifi Integration
  id: reload_unifi_integration
  
  trigger:
    - platform: event
      event_type: system_log_event
      event_data:
        name: 'homeassistant.components.unifi'
        level: 'WARNING'
  
  condition: "{{ 'received 401 Unauthorized' in trigger.event.data.message[0] }}"
  
  action:
    - action: counter.increment
      target:
        entity_id: counter.unifi_integration_errors
    
    - if:
        - condition: numeric_state
          entity_id: counter.unifi_integration_errors
          above: 5
      
      then:     
        - action: homeassistant.reload_config_entry
          target:
            entity_id: sensor.udm_state
        
        - action: counter.reset
          target:
            entity_id: counter.unifi_integration_errors

# Reload Ecovacs if it goes unavailable. Also check at HA start because it might already be unavailable.
- alias: Reload Ecovacs Integration
  id: reload_ecovacs_integration
  
  triggers:
    - trigger: state
      entity_id: vacuum.ecovacs_deebot_none
      to: unavailable
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: state
      entity_id: vacuum.ecovacs_deebot_none
      state: unavailable
  
  actions:    
    - action: homeassistant.reload_config_entry
      target:
        entity_id: vacuum.ecovacs_deebot_none
