#===============================#
#     Device Initialization     #
#===============================#

# So this is cheating, and might not always work. I have a catch-22 during HA startup:
#
# 1) As zigbee or echo devices are initialized they change from 'unavailable' state
# 2) In parallel, the Current Zigbee/Echo Unavailable Devices sensor gets initialized
# 3) As a result, some zigbee/echo devices might still be unavailable when the sensor is ready, resulting in a bogus numerical state for the sensor
# 4) As the rest of the zigbee/echo devices come up, the state of the above sensor continues to change toward 0
# 5) About the same time, the Notify Zigbee/Echo Device Unavailable automation gets initialized and starts running, triggered by one of the above sensor changes
# 
# At this point, the automation may fail due to templates not resolving correctly, but even if there are no failures, the automation should not
# be running at all at this point, since it's just churn during startup. OK, I guess it's possible that a device could choose to really go unavailable
# at the same time, but oh well. I care less about that than seeing a bunch of errors in the log.
#
# So, the below automation runs at startup and sets a flag, which prevents Notify Zigbee/Echo Device Unavailable from running. It waits a bit, then resets the
# flag, so the automation can run for real if a zigbee/echo device becomes unavailable.
#
# So what was that about cheating? Automations are initialized in the order they are read from the files in the automations directory. This file is 'devices',
# which is alphabetically before 'notification'. Which gives me a VERY short amount of time to get this flag set before the notification automation runs.
# So yeah, super awesome stuff.
- alias: Handle Device Initialization Catch 22
  id: handle_device_initialization_catch_22
  
  trigger:
    - platform: homeassistant
      event: start
  
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.device_initialization_catch_22
    
    - delay: '00:01:30'
    
    - service: input_boolean.turn_off
      entity_id: input_boolean.device_initialization_catch_22


#=============#
#     UPS     #
#=============#

# Handle a power outage, preserving UPS time for critical resources (HA, NUT server & internet).
- alias: Handle Power Outage
  id: 'handle_power_outage'
  
  # Trigger if the battery is discharging for a short time. I want to ignore the frequent short power glitches,
  # but not leave the PC on too long.
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OB DISCHRG'
      for: '00:01:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OB DISCHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: power_out
        title: 'Warning:'
        message: Power is out, shutting down PC.
        channel: critical
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'auto', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'throttled': false, 'tag': tag} }}"
    
    # Save a timestamp for this event.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.ups_power_out
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
    
    # The recorder database lives on the PC, so disable it before we shutdown.
    - action: recorder.disable
    
    # Shut down the PC.
    - action: script.turn_off_pc
    
    # The vacuum bizarrely starts running if the power goes out, so stop it (unless it's already running).
    - if:  
        - condition: state
          entity_id: timer.vacuum
          state: 'idle'
      
      then:        
        - action: vacuum.stop
          entity_id: vacuum.ecovacs_deebot_none 

# Shut down the host if UPS runtime reaches critical level.
- alias: Handle UPS Critical
  id: 'handle_ups_critical'
  
  trigger:
    - platform: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
    - platform: homeassistant
      event: start
  
  condition:
    - condition: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: ups_battery
        title: 'Warning:'
        message: UPS battery is critical, shutting down RPi.
        channel: critical
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'auto', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'throttled': false, 'tag': tag} }}"
    
    # Save a timestamp for this event.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.ups_battery_critical
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
    
    # Goodbye.
    - delay: 3
    - action: hassio.host_shutdown

# Turn the PC back on if power is restored.
- alias: Handle Power Restoration
  id: 'handle_power_restoration'
  
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OL CHRG'
      for: '00:02:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OL CHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: power_restored
        title: 'Attention:'
        
        # The message indicates power is restored, but also includes the original outage time. If the UPS battery went critical it includes that time as well.
        message: >
          {% set var = namespace(outage = '', critical = '') %}
          {% set prefix = 'Power is restored, turning on the PC (' %}
          {% set keys = state_attr('sensor.mobile_tag_registry_keys', 'tags') %}
          {% set var.outage = 'outage: ' ~ state_attr('input_datetime.ups_power_out', 'timestamp') | timestamp_custom %}
          {% if 'ups_battery' in keys %}
            {% set var.critical = ', critical: ' ~ state_attr('input_datetime.ups_battery_critical', 'timestamp') | timestamp_custom %}
          {% endif %}
          
          {{ prefix ~ var.outage ~ var.critical ~ ')' }}
        
        channel: standard
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'manual', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'throttled': false, 'tag': tag} }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
      
    # Remove previous notifications and unregister the tags. We could have one or both of these but there's no need to check, since
    # nothing bad happens if a tag doesn't exist.
    - action: script.remove_mobile_notification
      data:
        tag: 'power_out'
    
    - action: script.remove_mobile_notification
      data:
        tag: 'ups_battery'
    
    # Send a magic packet to power on the PC.
    - action: wake_on_lan.send_magic_packet
      data:
        mac: 98-EE-CB-A6-80-EA
    
    # Enable the recorder after a short delay.
    - delay: '00:02:00'
    - action: recorder.enable
    
    # Instruct the vacuum to return home.
    - action: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot_none
    
    # The theater might have been on when power went out; reset the flag so it will open the next time.
    - action: input_boolean.turn_off
      entity_id: input_boolean.theater_open
    
    # Also, make sure the theater devices are turned off. The Activate Cinema script won't function properly
    # otherwise.
    - action: remote.turn_off
      entity_id: remote.harmony_hub

# Restart the NUT server service if it becomes unavailable.
- alias: Reboot NUT Service
  id: reboot_nut_service
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status
      to: 'unavailable'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status
      state: 'unavailable'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - service: shell_command.reboot_nut_service

#====================#
#     House: Jon     #
#====================#

# Open up the house when needed.
- alias: Open House
  id: 'open_house'
  
  triggers:
    
    # Jon arrives home.
    - trigger: state
      entity_id: person.jon
      from: 'not_home'
      to: 'home'
  
  conditions:
    
    # Make sure the Jon Away flag is on. This turns on when I leave home, so should be on now.
    - condition: state
      entity_id: input_boolean.jon_away
      state: 'on'
  
  actions:    
    
    # The Jon Away flag needs to get reset now that I'm home. Don't wait for the script, because it contains a several minute delay.
    - action: script.turn_on
      target:
        entity_id: script.reset_jon_away
    
    # Open garage door.
    - action: script.turn_on
      target:
        entity_id: script.open_garage_door_north
      data:
        variables:
          use_info_message: false
    
    # Turn off extended away mode (this should have happened above based on proximity ... this is a failsafe).
    - action: script.turn_off_extended_away_mode
    
    # Turn on appropriate lights if it's dark-ish.
    - if:
        - "{{ states('sensor.downstairs_sensor_ambient_light') | float(0) < states('input_number.family_room_ambient_min') | float(0) }}"
      
      then:
        - action: light.turn_on
          target:
            entity_id: light.office_lamp
        
        - if:
            - condition: state
              entity_id: input_boolean.christmas_mode
              state: 'off'
          
          then:        
            - action: light.turn_on
              target:
                entity_id: light.daytime_lights
          
          else:
            - action: script.turn_on_christmas_lights
              data:
                variables:
                  additional_lights: daytime

# Close up the house when needed.
- alias: Close House
  id: 'close_house'
  
  triggers:
    
    # Jon leaves home.
    - trigger: state
      entity_id: person.jon
      from: 'home'
      to: 'not_home'
      id: jon_left
    
    # The sun goes to bed.
    - trigger: state
      entity_id: sun.sun
      from: 'above_horizon'
      to: 'below_horizon'
      id: sunset
    
    # In case HA was rebooting when one of the above triggers would have happened.
    - trigger: homeassistant
      event: start
      id: start
  
  # These conditions cover the HA start trigger.
  conditions:
    - or:
      - condition: state
        entity_id: person.jon
        state: 'not_home'
      
      - condition: state
        entity_id: sun.sun
        state: 'below_horizon'
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Close garage doors ... run the scripts in parallel because they contain a several minute delay.
    - action: script.turn_on
      target:
        entity_id: script.close_garage_door_north
      data:
        variables:
          use_info_message: true
    
    - action:  script.turn_on
      target:
        entity_id: script.close_garage_door_south
      data:
        variables:
          use_info_message: true
    
    - if:
      
        # I just left home.
        - "{{ trigger.id != 'sunset' and not is_state('person.jon', 'home') }}"
        
      then:
    
        # Indicate I'm  away.
        - action: input_boolean.turn_on
          entity_id: input_boolean.jon_away
    
        # Lock the PC.
        - action: script.turn_on
          entity_id: script.lock_pc
    
        - if:
          
            # No one else is home.
            - "{{ is_state('binary_sensor.adults_home', 'off') }}"
        
          then:
        
            # Turn off all lights.
            - scene: scene.lights_out
        
            # Turn off all fans.
            - scene: scene.fans_off
      
    - if:
      
        # Must be sunset.
        - "{{ trigger.id != 'jon_left' and states('sun.sun') == 'below_horizon' }}"
        
      then:
         
         # Turn off certain light domains.
         - action: light.turn_off
           target:
             entity_id:
               - light.storage_lights
               - light.outdoor_lights

#=======================#
#     House: Family     #
#=======================#

# Open the house for family.
- alias: Open House For Family
  id: 'open_house_for_family'
  mode: queued
  
  trigger:
    
    # Adults arrive.
    - platform: state
      entity_id:
        - person.sarah
        - person.david
        - person.mike
        - person.maryam
      from: 'not_home'
      to: 'home'
      id: adults
    
    # Children arrive.
    - platform: state
      entity_id:
        - person.skylar
      from: 'not_home'
      to: 'home'
      id: children
  
  action:
    
    - variables:
        sarah_nor_skylar: "{{ not is_state('person.sarah', 'home') and not is_state('person.skylar', 'home') }}"
        sarah_nor_david: "{{ not is_state('person.sarah', 'home') and not is_state('person.david', 'home') }}"
    
    # Set the default occupied bedrooms.
    - choose:
      
      # Sarah with David = both.
      - conditions: "{{ (is_state('person.sarah', 'home') and is_state('person.david', 'home')) }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'Both'
      
      # David without Sarah nor Skylar = adult up.
      - conditions: "{{ sarah_nor_skylar and is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'AdultUp'
      
      # Sarah without David = adult down (it's assumed Skylar will sleep with Sarah if she's here).
      - conditions: "{{ is_state('person.sarah', 'home') and not is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'AdultDown'
      
      # Skylar with David = child down plus (plus meaning adult up).
      - conditions: "{{ is_state('person.skylar', 'home') and is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'ChildDownPlus'
      
      # Skylar alone = child down.
      - conditions: "{{ is_state('person.skylar', 'home') and sarah_nor_david }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'ChildDown'
    
    # Perform tasks for adults.
    - if:
        - "{{ trigger.id == 'adults' }}"
      
      then:
        
        # If sunset has already occurred, Close House won't be triggered to close the garage.
        # So start a timer to do that in a bit.
        # Also, since it's dark, turn on some outdoor lights.
        - if:
            - condition: state
              entity_id: sun.sun
              state: 'below_horizon'
        
          then:
            - service: timer.start
              data:
                entity_id: timer.garage_north_close
                duration: '00:30:00'
            
            - service: scene.apply
              data:
                entities:
                  light.driveway_light:   'on'
                  light.front_floodlight: 'on'
        
        # Open garage door.
        - service: script.turn_on
          target:
            entity_id: script.open_garage_door_north
          data:
            variables:
              use_info_message: true
    
    # Perform tasks for children.
    - if:
        - "{{ trigger.id == 'children' }}"
      
      then:
        
        # Turn on bedroom light if needed.
        - service: script.turn_on_lights_per_conditions
          data:
            light_entity: light.studio_lamp_2
            lux_entity: sensor.downstairs_sensor_ambient_light
            min_lux_value: "{{ states('input_number.studio_bedroom_ambient_min') | float(0) }}"

# Close house when all family members leave.
- alias: Close House For Family
  id: 'close_house_for_family'
  
  trigger:
    
    # Anyone leaves.
    - platform: state
      entity_id: binary_sensor.adults_home
      from: 'on'
      to: 'off'
  
    - platform: state
      entity_id: binary_sensor.children_home
      from: 'on'
      to: 'off'
  
  condition:
    
    # Everyone must be gone.
    - condition: state
      entity_id: binary_sensor.adults_home
      state: 'off'
    
    - condition: state
      entity_id: binary_sensor.children_home
      state: 'off'
  
  action:
    
    # Restore the upstairs bedroom to normal.
    - if:
        - condition: state
          entity_id: binary_sensor.penthouse_occupied
          state: 'on'
      
      then:
        - service: script.restore_normal_penthouse_bedroom
    
    # Reset occupied bedrooms.
    - service: input_select.select_option
      target:
        entity_id: input_select.occupied_bedrooms
      data:
        option: Empty
    
    # Turn off appropriate guest suite lights and fans.
    - service: homeassistant.turn_off
      target:
        label_id:
          - guest_suite_down
          - guest_suite_up
    
    # Reset Child Alone.
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.child_alone

#===================================#
#     Family Presence Detection     #
#===================================#
  
- alias: Handle Child Tag Scan
  id: handle_child_tag_scan
  
  triggers:
    - trigger: tag
      tag_id: 0c6d2dfd-4ad7-4281-9ec0-54756ed2d539
      id: skylar
        
  actions:
    - variables:
        tracker_entity: "{{ 'device_tracker.virtual_' ~ trigger.id }}"
        new_state: >
          {% if states(tracker_entity) != 'home' %}
            home
          {% else %}
            not_home
          {% endif %}
        topic_suffix: "{{ tracker_entity.split('.')[1] }}"
    
    - action: mqtt.publish
      data:
        topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
        payload: "{{ new_state }}"
    
    - action: notify.alexa_media
      data:
        message: >
          <speak>
            <amazon:emotion name="excited" intensity="medium">
            {{ iif(new_state == 'home', 'Hi Skylar! Hope you enjoy your stay!', 'Bye Slylar! Come visit again soon!') }}
            </amazon:emotion>
          </speak>
        target: media_player.office_echo
        data:
          type: tts

#=============================#
#     Penthouse Occupancy     #
#=============================#

# Set the penthouse devices appropriately when the occupied bedrooms change.
# Normally this only happens when family members arrive, but it could also be done manually via the UI.
- alias: Prepare Penthouse Bedroom For Family
  id: 'prepare_penthouse_bedroom_for_family'
  mode: queued
  
  # Trigger when the penthouse bedroom is occupied by an adult.
  triggers:
    - trigger: state
      entity_id: input_select.occupied_bedrooms
      not_from:
        - 'AdultUp'
        - 'ChildDownPlus'
        - 'Both'
      to:
        - 'AdultUp'
        - 'ChildDownPlus'
        - 'Both'
  
  actions:

    # Set a temporary temperature hold upstairs. Assume 7 days total.
    - action: script.set_temporary_thermostat_hold
      data:
        thermostat_entity: climate.upstairs
        heat_temp: "{{ state_attr('sensor.variables', 'variables').upstairs_home_heat_temp }}"
        cool_temp: "{{ state_attr('sensor.variables', 'variables').upstairs_home_cool_temp }}"
        days: 7
            
    # Turn off the vacuum automation.
    - action: script.toggle_vacuum_automation
      data:
        operation: 'off'

# If a child is home with parents, we don't have a way to determine if the parents leave (not a temporary leave),
# but the child stays home longer. So we use the Child Alone button triggered via the UI to indicate this.
- alias: Restore Normal Penthouse Bedroom
  id: 'restore_normal_penthouse_bedroom'
  
  # Trigger when the Child Alone button is pressed on the UI.
  trigger:
    - platform: state
      entity_id: input_boolean.child_alone
      to: 'on'
  
  action:
    
    # Restore the penthouse bedroom to normal.
    - service: script.restore_normal_penthouse_bedroom
    
    # Reset occupied bedrooms. For now this is ChildDown, until I figure out a more complete solution.
    - service: input_select.select_option
      target:
        entity_id: input_select.occupied_bedrooms
      data:
        option: ChildDown
    
    # Turn off penthouse lights and fans.
    - service: homeassistant.turn_off
      target:
        label_id: guest_suite_up
    
    # Reset Child Alone.
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.child_alone

#=================================#
#     House Open/Close Timing     #
#=================================#

# Deal with the open/close house timing issue. The problem is:
# 
# - One tracker changes to home or not_home state, which changes the person to home or not_home, driving Open House or Close House
# - A second tracker gets an attribute updated (but NOT the state), which changes the person back to not_home or home, driving Close House or Open House
# - The second tracker then changes to home or not_home state, which again drives Open House or Close House
#
# Note that nothing too terrible actually happens: I have seen the garage door get stuck partially open, and a notification that it can't be closed,
# both due to the garage door opener being triggered twice within 1 second. I can live with that, but stuff like this drives me bonkers.

# Handle the Open House variation.
- alias: Handle Open House Timing Issue
  id: 'handle_open_house_timing_issue'
  
  # Trigger on any of the GPS trackers changing from not_home to home.
  trigger:
    - platform: state
      entity_id:
        - device_tracker.jon_companion
      from: 'not_home'
      to: 'home'
  
  # We only need to trigger on one of the trackers, not all of them, so use the state of the Close House
  # automation to weed out all but the first.
  condition:
    - condition: state
      entity_id: automation.close_house
      state: 'on'
  
  action:
    
    # Temporarily turn off the Close House automation, then turn it back on.
    - service: automation.turn_off
      entity_id: automation.close_house
      
    - delay: "00:02:00"
    
    - service: automation.turn_on
      entity_id: automation.close_house

# Handle the Close House variation.
- alias: Handle Close House Timing Issue
  id: 'handle_close_house_timing_issue'
  
  # Trigger on any of the GPS trackers changing from home to not_home.
  trigger:
    - platform: state
      entity_id:
        - device_tracker.jon_companion
      from: 'home'
      to: 'not_home'
  
  # We only need to trigger on one of the trackers, not all of them, so use the state of the Open House
  # automation to weed out all but the first.
  condition:
    - condition: state
      entity_id: automation.open_house
      state: 'on'
  
  action:
    
    # Temporarily turn off the Open House automation, then turn it back on.
    - service: automation.turn_off
      entity_id: automation.open_house
      
    - delay: "00:02:00"
    
    - service: automation.turn_on
      entity_id: automation.open_house

#================#
#     Garage     #
#================#

# Close garage door north once a delay has occurred after family has arrived after sunset.
- alias: Close Garage North
  id: close_garage_north
  
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.garage_north_close
  
  action:
    - service: script.turn_on
      target:
        entity_id: script.close_garage_door_north
      data:
        variables:
          use_info_message: true

#========================#
#     Family Room AV     #
#========================#

# Turn on the Family Room AV and box 3 screen during the day, depending on the presence of a grandchild.
- alias: Enable Family Room AV
  id: 'enable_family_room_av'
  
  triggers:
    - trigger: time
      at: '07:00:00'
      id: 'morning'
    
    - trigger: time
      at: '16:00:00'
      id: 'afternoon'
  
  conditions:
    - or:
      - and:
        - condition: state
          entity_id: binary_sensor.children_home
          state: 'on'
        - condition: trigger
          id: 'morning'
      - condition: trigger
        id: 'afternoon'
  
  actions:
    - condition: state
      entity_id: input_boolean.extended_away_mode
      state: 'off'
    
    - action: script.enable_family_room_av

#================================#
#     Human Presence Sensors     #
#================================#

# The office has a human presence sensor to detect presence. I want to use that to control the ceiling fan.
# But what is needed is a delayed reaction after the human presence sensor turns off, so the fan doesn't go off until it's
# clear that the office is unoccupied. So we use an input boolean here that turns on quickly but only turns off 
# if the human presence sensor doesn't detect presence for a decent interval.
- alias: Turn On Office occupied
  id: turn_on_office_occupied
  
  trigger:
    - platform: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'off'
      to: 'on'
      for: '00:02:00'
  
  action:
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.office_occupied

- alias: Turn Off Office occupied
  id: turn_off_office_occupied
  
  trigger:
    - platform: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'on'
      to: 'off'
      for: '00:20:00'
  
  action:
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.office_occupied

#==============#
#     Fans     #
#==============#

# Operate the office fan when the office is occupied.
- alias: Operate Office Fan
  id: 'operate_office_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: input_boolean.office_occupied
      sensor_off_state: 'off'
      temperature_entity: sensor.office_sensor_temperature
      fan_entity: fan.office_fan
      thresholds: [80, 78, 75]

# Operate the family room fan when the AV system is on.
- alias: Operate Family Room Fan
  id: 'operate_family_room_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: binary_sensor.family_room_av_system
      sensor_off_state: 'off'
      temperature_entity: sensor.main_floor_temperature
      fan_entity: fan.family_room_fan
      thresholds: [80, 78.5, 74]

# Operate the theater fan when the AV system is on.
- alias: Operate Theater Fan
  id: 'operate_theater_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: sensor.harmony_hub
      sensor_off_state: 'PowerOff'
      temperature_entity: sensor.theater_temperature
      fan_entity: fan.theater_fan
      thresholds: [78, 76, 74]

# Turn off penthouse fan after a while.
- alias: Turn Off Penthouse Fan
  id: turn_off_penthouse_fan
  
  trigger:
    - platform: state
      entity_id: switch.penthouse_fan
      from: 'off'
      to: 'on'
      for: '00:40:00'
  
  action:
    - service: switch.turn_off
      entity_id: switch.penthouse_fan

#===================#
#     Treadmill     #
#===================#

# Treadmill start
- alias: Start Treadmill
  id: 'start_treadmill'
  
  # Trigger when the power usage of the treadmill rises above a threshold that indicates typical usage.
  trigger:
    - platform: numeric_state
      entity_id: sensor.treadmill_current_consumption
      above: 200
  
  # If the treadmill is paused during a workout, the power usage drops below the above threshold then rises again.
  # This re-triggers this automation, so this condition prevents overwriting the start time.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'off'
  
  action:
    
    # Set the treadmill start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.treadmill_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Set the flag used in the above condition that prevents re-triggers on pause.
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.treadmill_triggered

# Treadmill power interrupted ... unfortunately the power plug might become unavailable while in use.
# We handle this as follows:
#
# 1) This automation detects the unavailable state ... if we're not close to being done, set the Treadmill Power timer for the expected done time, otherwise trigger Stop Treadmill
# 2) If we set a timer in step 1, Handle Treadmill Power Timer triggers Stop Treadmill at the timer expiration
# 3) If the plug becomes available again, cancel the timer if it's still running
- alias: Detect Treadmill Power Unavailable
  id: detect_treadmill_power_unavailable
  
  # Trigger when the power plug becomes unavailable.
  trigger:
    - platform: state
      entity_id: sensor.treadmill_current_consumption
      to: 'unavailable'
  
  # Only continue if the start automation was previously triggered.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  action:
    - variables:
        minutes_since_start: >
          {% from 'utilities.jinja' import calc_time_diff %}
          {{ calc_time_diff('input_datetime.treadmill_start') | int(0) }}
        
        default_minutes: "{{ states('input_number.default_treadmill_minutes') | int(0) }}"
        
        offset_minutes: 2
    
    - if: 
        - "{{ minutes_since_start <= (default_minutes - offset_minutes) }}"
      
      then:    
        - service: timer.start
          data:
            entity_id: timer.treadmill_power
            duration: "{{ (default_minutes - minutes_since_start) * 60 }}"
      
      else:
        - service: automation.trigger
          data:
            entity_id: automation.stop_treadmill
            skip_condition: false

# Cancel the Treadmill Power timer if the power plug becomes available.
- alias: Detect Treadmill Power Available
  id: detect_treadmill_power_available
  
  # Trigger when the power plug becomes available.
  trigger:
    - platform: state
      entity_id: sensor.treadmill_current_consumption
      from: 'unavailable'
  
  action:
    
    # If the start automation was previously triggered, cancel the timer if it's running.
    - if:
        - condition: state
          entity_id: input_boolean.treadmill_triggered
          state: 'on'
      
      then:
        - if:
            - condition: state
              entity_id: timer.treadmill_power
              state: 'active'
          
          then:
            - service: timer.cancel
              entity_id: timer.treadmill_power
      
      # The treadmill is not currently in use.
      else:
    
        # Turn off the treadmill power to conserve energy. Normally this happens in Stop Treadmill,
        # but if the power plug was unavailable at that time, we do it here.
        - service: switch.turn_off
          target:
            entity_id: switch.treadmill

# Trigger Stop Treadmill when the Treadmill Power timer expires.
- alias: Handle Treadmill Power Timer
  id: handle_treadmill_power_timer
  
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.treadmill_power
  
  action:
    - service: automation.trigger
      data:
        entity_id: automation.stop_treadmill
        skip_condition: false

# Treadmill stop
- alias: Stop Treadmill
  id: 'stop_treadmill'
  
  # Trigger when the power usage of the treadmill indicates it's been turned off.
  trigger:
    - platform: numeric_state
      entity_id: sensor.treadmill_current_consumption
      below: 7
  
  # Only continue if the start automation was previously triggered.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  action:
    
    # Reset the triggered flag.
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.treadmill_triggered
    
    # Turn off the treadmill power to conserve energy (a few watts are used for an illuminated power toggle).
    - service: switch.turn_off
      target:
        entity_id: switch.treadmill
    
    # Indicate we used the treadmill today.   
    - service: script.modify_current_exercise_day
      data:
        exercise_types: ['treadmill']
        operation: true
    
    # Calculate the amount of time spent walking. I always walk some multiple of 5 minutes with a 1 minute cooldown, so round
    # down to the nearest 5 minutes (there could be an extra minute or two during a workout pause). The cooldown period
    # is accounted for in the next step.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_time
      data:
        value: >
          {% set start = as_timestamp(strptime(states('input_datetime.treadmill_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set num = (now().timestamp() - start) // 60 %}
          {% set minutes = (num - (num % 5)) %}
          {{ minutes }}
    
    # Calculate calories burned. This is stolen from shapesense.com ... the formula is (for example 0 degree incline):
    #   CB = [0.0215 x KPH³ - 0.1765 x KPH² + 0.8710 x KPH + 1.4577] x WKG x T
    #
    #     CB = Calorie burn (in calories)
    #     KPH = Walking speed (in kilometres per hour)
    #     WKG = Weight (in kilograms)
    #     T = Time (in hours)
    #
    # NOTES:
    #   - The above formula only works for 0-5 degree incline ... more work needed here if I ever do higher inclines.
    #   - My cooldown period is always 1 minute at 2.0 MPH (ctime and ckph variables).
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_calories
      data:
        value: >
          {% set weight  = states('sensor.smart_scale_p1_weight') | float(0) %}
          {% set speed   = states('input_number.treadmill_speed') | float(0) %}
          {% set incline = states('input_number.treadmill_incline') | int(0) %}
          {% set time    = states('input_number.treadmill_daily_time') | int(0) / 60 %}
          {% set ctime   = 1/60 %}
          {% set kph     = speed * 1.609344 %}
          {% set ckph    = 2.0   * 1.609344 %}
          {% set wkg     = weight * 0.45359237 %}
          {% if states('input_number.treadmill_incline') | int(0) == 0 %}
            {% set cooldown = (((ckph**3 * 0.0215) - (ckph**2 * 0.1765) + (ckph * 0.8710) + 1.4577) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0215) -  (kph**2 * 0.1765) +  (kph * 0.8710) + 1.4577) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 1 %}
            {% set cooldown = (((ckph**3 * 0.0171) - (ckph**2 * 0.1062) + (ckph * 0.6080) + 1.8600) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0171) -  (kph**2 * 0.1062) +  (kph * 0.6080) + 1.8600) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 2 %}
            {% set cooldown = (((ckph**3 * 0.0184) - (ckph**2 * 0.1134) + (ckph * 0.6566) + 1.9200) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0184) -  (kph**2 * 0.1134) +  (kph * 0.6566) + 1.9200) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 3 %}
            {% set cooldown = (((ckph**3 * 0.0196) - (ckph**2 * 0.1205) + (ckph * 0.7053) + 1.9800) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0196) -  (kph**2 * 0.1205) +  (kph * 0.7053) + 1.9800) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 4 %}
            {% set cooldown = (((ckph**3 * 0.0208) - (ckph**2 * 0.1277) + (ckph * 0.7539) + 2.0400) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0208) -  (kph**2 * 0.1277) +  (kph * 0.7539) + 2.0400) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 5 %}
            {% set cooldown = (((ckph**3 * 0.0221) - (ckph**2 * 0.1349) + (ckph * 0.8025) + 2.1000) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0221) -  (kph**2 * 0.1349) +  (kph * 0.8025) + 2.1000) * wkg *  time) | int(0) }}
          {% endif %}
    
    # Register weekly and monthly exercise metrics.
    - service: script.register_exercise_metrics
      data:
        exercise_type: treadmill
    
    # Update the current treadmill used minutes. We keep minutes because the treadmill time is likely to not be an even hour.
    # We convert the minutes to hours in order to determine if lubrication is needed.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_usage_minutes
      data:
        value: "{{ states('input_number.treadmill_usage_minutes') | int(0) + states('input_number.treadmill_daily_time') | int(0) }}"

#====================#
#     Appliances     #
#====================#

# Check if certain devices are somehow off.
- alias: Check Refrigerator Off
  id: check_refrigerator_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.refrigerator
      component_name: tplink
      device_name: Refrigerator

- alias: Check Microwave Off
  id: check_microwave_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.microwave
      component_name: tplink
      device_name: Microwave

- alias: Check Projector Off
  id: check_projector_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.projector
      component_name: sonoff
      device_name: Projector
      conditional_processing: "{{ states('input_boolean.projector_plug_powered_off') }}"

#======================#
#     Robot Vacuum     #
#======================#

# Launch the vacuum.
- alias: Start Vacuum
  id: 'start_vacuum'
  
  triggers:
    - trigger: time
      at: '03:00:00'
  
  conditions:
    - condition: time
      weekday:
        - mon
    
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
  
  actions:
    - action: input_boolean.turn_off
      entity_id: input_boolean.vacuum_kicked_off
    
    - action: vacuum.start
      entity_id: vacuum.ecovacs_deebot_none
    
    - action: timer.start
      data:
        entity_id: timer.vacuum
        duration: '01:30:00'

# Land the vacuum.
- alias: Stop Vacuum
  id: 'stop_vacuum'
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.vacuum
    
    - trigger: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 20
  
  conditions:
    - condition: time
      weekday:
        - mon
  
  actions:
    - action: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot_none

# Detect the vacuum running - we use the battery dropping below a threshold as the trigger.
- alias: Detect Vacuum Running
  id: 'detect_vacuum_running'
  trigger:
    - platform: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 90
  condition:
    - condition: time
      weekday:
        - mon
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.vacuum_kicked_off

#================#
#     Washer     #
#================#

# Set the washer start time, based on the power state changing from stop to fill (or a potential unknown to fill).
- alias: Start Washer
  id: 'start_washer'
  
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
      from:
        - 'stop'
        - 'unknown'
      to: 'fill'
  
  action:
    
    # Set the washer start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.washer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Indicate load size is sensing.
    - service: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: '*sensing*'
    
    # Remember to backup the log tomorrow morning.
    - service: input_boolean.turn_on
      entity_id: input_boolean.backup_laundry_log
    
    # Log the start in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Washer
        message: "starting: softener {{ states('input_boolean.washer_fabric_softener') }}"

# Set the washer load size, based on the amount of time spent on the initial fill. This is triggered only
# when the power state changes from fill to raise, and the washer state is Wash Fill.
- alias: Set Washer Load Size
  id: 'set_washer_load_size'
  
  triggers:
    - trigger: state
      entity_id: sensor.washer_power_state
      from: 'fill'
      to: 'raise'
  
  conditions:
    - condition: state
      entity_id: input_select.washer_state
      state: 'Wash Fill'
  
  actions:
    - variables:
        washer_fill_seconds: >
          {% set start = as_timestamp(strptime(states('input_datetime.washer_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set seconds = (now().timestamp() - start) | round(0) %}
          {{ seconds }}
    
    # Set the washer load size. Default to medium if the calculation for seconds is unreasonably small.
    - action: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: >
          {% if   washer_fill_seconds >= 180 and washer_fill_seconds < 450 %}
            Small
          {% elif washer_fill_seconds >= 450 and washer_fill_seconds < 650 %}
            Medium
          {% elif washer_fill_seconds >= 650  %}
            Large
          {% else %}
            Medium
          {% endif %}
    
    # Save the washer fill seconds for diagnosis/tweaking.
    - action: input_number.set_value
      target:
        entity_id: input_number.washer_fill_seconds
      data:
        value: "{{ washer_fill_seconds }}"
    
    # Log the event in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: fill_plus_load
        prefix: Washer
        message: fill time, load size
        entity_id_1: input_number.washer_fill_seconds
        entity_id_2: input_select.washer_load_size

# Start the washer wash blackout timer. This is used to ignore a potential early drop,
# which would shorten the wash cycle dramatically.
- alias: Start Washer Wash Blackout Timer
  id: 'start_washer_wash_blackout_timer'
  
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Wash Fill'
      to: 'Wash'
  
  action:
    - variables:
        duration: '00:01:00'
    
    - service: timer.start
      data:
        entity_id: timer.washer_wash_blackout
        duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_wash_blackout

# Start the washer rinse fill blackout timer. This is used to ignore the fabric softener injection
# during the rinse fill, which otherwise wreaks havoc on the operation control algorithm.
- alias: Start Washer Rinse Fill Blackout Timer
  id: 'start_washer_rinse_fill_blackout_timer'
  
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Wash Drain'
      to: 'Rinse Fill'
  
  condition:
    - condition: state
      entity_id: input_boolean.washer_fabric_softener
      state: 'on'
  
  action:
    - variables:
        
        # The timer amount is based on the washer load size. If it's invalid, use the medium value and hope for the best.
        duration: >
          {% set load_size = states('input_select.washer_load_size') %}
          {{ iif(load_size == 'Small', '00:03:00', iif(load_size == 'Large', '00:05:00', '00:04:00')) }}
    
    -  service: timer.start
       data:
         entity_id: timer.washer_rinse_fill_blackout
         duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_rinse_fill_blackout

# Start the washer rinse blackout timer. This is used to ignore a potential early drop,
# which would shorten the rinse cycle dramatically.
- alias: Start Washer Rinse Blackout Timer
  id: 'start_washer_rinse_blackout_timer'
  
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Rinse Fill'
      to: 'Rinse'
  
  action:
    - variables:
        duration: '00:01:00'
    
    - service: timer.start
      data:
        entity_id: timer.washer_rinse_blackout
        duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_rinse_blackout

# Washer operation control. This uses the washer power state sensor and other controls to step through the following washer states:
#
# - Off
# - Wash Fill
# - Wash
# - Wash Drain
# - Rinse Fill
# - Rinse
# - Rinse Drain
# - Off
- alias: Set Washer Operation
  id: 'set_washer_operation'
  
  trace:
    stored_traces: 20
  
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
  
  condition: "{{ trigger.from_state and trigger.from_state.state != 'unavailable' }}"
  
  action:
    
    # Delay one second so automations (above) that determine the load size have a chance to run before we do.
    - delay: '00:00:01'
    
    - variables:
        s: "{{ states('input_select.washer_state') }}"
    
    # Determine the washer state.
    - service: input_select.select_option
      data:
        entity_id: input_select.washer_state
        option: >
          {# --Set variables-- #}
          {% set fr = trigger.from_state.state %}
          {% set to = trigger.to_state.state %}
          {% set t1 = states('timer.washer_rinse_fill_blackout') %}
          {% set t2 = states('timer.washer_rinse_blackout') %}
          {% set t3 = states('timer.washer_wash_blackout') %}
          
          {# --Ignore everything if one of the timers is running-- #}
          {% if t1 == 'active' or t2 == 'active' or t3 == 'active' %} {{ s }}
          
          {# --Transition to new state based on current state and washer power state sensor change-- #}
          {% elif fr in ['stop', 'unknown'] and to == 'fill' %}                                    Wash Fill
          {% elif fr in ['fill', 'drop']    and to == 'raise'   and s == 'Wash Fill' %}            Wash
          {% elif fr == 'raise'             and to == 'drop'    and s in ['Wash', 'Wash Drain'] %} Wash Drain
          {% elif fr in ['drop', 'raise']   and to == 'fill'    and s == 'Wash Drain' %}           Rinse Fill
          {% elif fr in ['fill', 'drop']    and to == 'raise'   and s == 'Rinse Fill' %}           Rinse
          {% elif fr == 'raise'             and to == 'drop'    and s == 'Rinse' %}                Rinse Drain     
          
          {# --Some washer power state sensor changes just remain in the current state-- #}
          {% elif fr == 'drop'  and to in ['fill', 'raise'] %} {{ s }}
          {% elif fr == 'fill'  and to in ['drop', 'raise'] %} {{ s }}
          {% elif fr == 'raise' and to in ['fill', 'drop'] %}  {{ s }}
          
          {# --Catch-all, default to Off-- #}
          {% else %} Off
          {% endif %}
    
    # Continue if the state changed.
    - if:
        - "{{ s != states('input_select.washer_state') }}"
      
      then:
        
        # Log the state change in the laundry events log.
        - service: script.log_laundry_event
          data:
            event_type: basic
            prefix: Washer
            message: "state changed from {{ s }} to {{ states('input_select.washer_state') }}"
        
        # Perform washer stopped tasks.
        - if:
            - "{{ is_state('input_select.washer_state', 'Off') }}"
          
          then:
            
            # Log the washer stop event.
            - service: script.log_laundry_event
              data:
                event_type: basic
                prefix: Washer
                message: stopped
            
            # Update the washer history time ranges.
            - service: script.update_laundry_history_time_ranges
              data:
                is_washer: true
                start_time: "{{ state_attr('input_datetime.washer_start', 'timestamp') | int(0) }}"
                stop_time: "{{ as_timestamp(now()) | round(0) }}"

#===============#
#     Dryer     #
#===============#

- alias: Start Dryer
  id: start_dryer
  
  triggers:
    - trigger: state
      entity_id: binary_sensor.dryer_sensor_start_button
      from: 'off'
      to: 'on'
  
  actions:    
    
    # Indicate the dryer has started. This is the initial state before the temperature has been detected (in Turn On Dryer Running).
    - action: input_boolean.turn_on
      entity_id: input_boolean.dryer_started
    
    # Remember to backup the log tomorrow morning.
    - action: input_boolean.turn_on
      entity_id: input_boolean.backup_laundry_log
    
    # Log the start in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: >
          {% set intemp  = states('sensor.downstairs_temperature') %}
          {% set inhum   = states('sensor.downstairs_humidity') %}
          {% set outtemp = states('sensor.porch_sensor_temperature') %}
          {% set outhum  = states('sensor.porch_sensor_humidity') %}
          {% set drytemp = states('sensor.dryer_sensor_temperature') %}
          {% set dryhum  = states('sensor.dryer_sensor_humidity') %}
          
          starting: indoor ({{ intemp }}°, {{ inhum }}%); outdoor ({{ outtemp }}°, {{ outhum }}%); dryer ({{ drytemp }}°, {{ dryhum }}%)

- alias: Turn On Dryer Running
  id: turn_on_dryer_running
  
  triggers:

    # Trigger when the dryer temperature rises a bit above ambient.
    - trigger: template
      value_template: >
        {{ states('sensor.dryer_sensor_temperature') not in ['unavailable', 'unknown'] and states('sensor.downstairs_temperature') not in ['unavailable', 'unknown'] and
           states('sensor.dryer_sensor_temperature') | int(0) > (states('sensor.downstairs_temperature') | int(0) + 30) }}
      
  actions:
    
    # Set the dryer start time. Note that we delay this until we detect a rising temperature because nothing interesting
    # happens before then.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.dryer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

    # Initialize the temperature & humidity counts. This has the side effect of turning off the Dryer Done binary sensor.
    - action: counter.reset
      entity_id:
        - counter.dryer_temperature_count
        - counter.dryer_humidity_count
    
    # Indicate the dryer is running.
    - action: input_boolean.turn_on
      entity_id: input_boolean.dryer_running   
    
    # Turn off dryer started.
    - action: input_boolean.turn_off
      entity_id: input_boolean.dryer_started
    
    # Log temperature detected in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: metric
        prefix: Dryer
        message: temperature detected
        entity_id_1: sensor.dryer_sensor_temperature
    
    # Start a timer to ensure the Dryer Done binary sensor gets turned off at a failsafe time. This is accomplished
    # by resetting the temperature & humidity counts.
    - action: timer.start
      data:
        entity_id: timer.dryer_done_failsafe
        duration: '02:00:00'

# Ensure the Dryer Done binary sensor gets turned off at a failsafe time.
- alias: Reset Dryer Done Failsafe
  id: reset_dryer_done_failsafe
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.dryer_done_failsafe
  
  actions:
    - action: counter.reset
      entity_id:
        - counter.dryer_temperature_count
        - counter.dryer_humidity_count

- alias: Register Dryer Event
  id: register_dryer_event

  triggers:

    # Since our humidity trend sensor is looking for a drop of 30 points, only trigger if the current humidity is 70 or below.
    # This should weed out inaccurate trend sensor readings.
    # NOTE: The drop amount here must be kept in sync with the Dryer Humidity Falling trend sensor.
    - trigger: template
      value_template: "{{ states('binary_sensor.dryer_humidity_falling') == 'on' and states('sensor.dryer_sensor_humidity') | int(0) <= 70 }}"
      id: humidity

    # We don't bother doing the above for temperature. This would require saving the initial temperature when we detect the dryer is running, 
    # and I don't want to.
    - trigger: state
      entity_id: binary_sensor.dryer_temperature_falling
      to: 'on'
      id: temperature

  conditions:

    # Make sure the dryer is running ... we could easily detect changes at any time, since the sensor lives in the dryer vent connected to the outdoors.
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'

  actions: 

    # Bump the appropriate count. The dryer done binary sensor only turns on when both counts are above 0. We use counts in case we get 
    # spurious triggers, for example back to back humidity falling.
    - if:
        - "{{ trigger.id == 'temperature' }}"

      then:
        - action: counter.increment
          entity_id: counter.dryer_temperature_count

        # Log the event in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: metric
            prefix: Dryer
            message: temperature falling
            entity_id_1: sensor.dryer_sensor_temperature

      else:
        - action: counter.increment
          entity_id: counter.dryer_humidity_count

        # Log the event in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: metric
            prefix: Dryer
            message: humidity falling
            entity_id_1: sensor.dryer_sensor_humidity

- alias: Turn Off Dryer Running
  id: turn_off_dryer_running
  
  trigger:
    
    # Trigger when the dryer done binary sensor turns on, indicating that both temperature and humidity have fallen.
    - platform: state
      entity_id: binary_sensor.dryer_done
      to: 'on'

  condition:

    # Make sure the dryer is running.
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'
  
  action:
    
    # Turn off the dryer running flag.
    - service: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    
    # Log the stop in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: stopped
            
    # Update the dryer history time ranges.
    - service: script.update_laundry_history_time_ranges
      data:
        is_washer: false
        start_time: "{{ state_attr('input_datetime.dryer_start', 'timestamp') | int(0) }}"
        stop_time: "{{ as_timestamp(now()) | round(0) }}"

#=======================#
#     Treadmill Fan     #
#=======================#

# Control the treadmill fan based on temperature.
- alias: Turn On Treadmill Fan
  id: 'turn_on_treadmill_fan'
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'on'
  action:
    - choose:
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 70.0
        sequence:
          - delay: '00:10:00'
          - service: switch.turn_on
            entity_id: switch.treadmill_fan
      
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 75.0
        sequence:
          - delay: '00:05:00'
          - service: switch.turn_on
            entity_id: switch.treadmill_fan
      
      default:
        - service: switch.turn_on
          entity_id: switch.treadmill_fan

- alias: Turn Off Treadmill Fan
  id: 'turn_off_treadmill_fan'
  
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'off'
  
  action:
    
    # Allow a nice cooldown period.
    - delay: '00:02:00'
    
    # Turn off the treadmill fan.
    - service: switch.turn_off
      entity_id: switch.treadmill_fan
    
    # Now turn on the office fan so I can continue cooling down.
    - service: script.turn_on
      entity_id: script.control_fan_for_temperature
      data:
        variables:
          fan_entity_id: fan.office_fan
          temperature_entity_id: sensor.main_floor_temperature
          thresholds: [76, 74, 72]
          timeout: 360

#=========================#
#     Device Trackers     #
#=========================#

# Toggle virtual device trackers.
- alias: Toggle Virtual Device Tracker
  id: 'toggle_virtual_device_tracker'
  mode: queued
  
  trigger:
    - platform: state
      entity_id:
        - input_boolean.virtual_david
        - input_boolean.virtual_maryam
        - input_boolean.virtual_mike
        - input_boolean.virtual_sarah
        - input_boolean.virtual_skylar
      to:
  
  action:
    - variables:
        new_state: >
          {% if trigger.to_state.state == 'on' %}
            home
          {% else %}
            not_home
          {% endif %}
        
        topic_suffix: "{{ trigger.to_state.entity_id | replace('input_boolean.', '') }}"
    
    - service: mqtt.publish
      data:
        topic: "{{ 'homeassistant/device_tracker/' ~ topic_suffix }}"
        payload: "{{ new_state }}"

# Toggle phone stationary device trackers, based on the wifi SSID.
- alias: Toggle Jon Phone Stationary Tracker
  id: toggle_jon_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.jon_galaxy_wifi_connection
      ssid: White Rabbit
      topic_suffix: jon_phone_stationary

- alias: Toggle Mike Phone Stationary Tracker
  id: toggle_mike_phone_stationary_tracker
  
  use_blueprint:
    path: devices/update_phone_tracker.yaml
    input:
      wifi_entity: sensor.mike_galaxy_wifi_connection
      ssid: White Rabbit
      topic_suffix: mike_phone_stationary

#======================#
#     Echo Devices     #
#======================#

# Mute master bedroom echo.
- alias: Mute Master Bedroom Echo
  id: 'mute_master_bedroom_echo'
  
  trigger:
    - platform: state
      entity_id: input_boolean.sleeptime
      from: 'off'
      to: 'on'
  
  action:
    - service: script.turn_on
      entity_id: script.mute_master_bedroom_echo

# Unmute master bedroom echo.
- alias: Unmute Master Bedroom Echo
  id: 'unmute_master_bedroom_echo'
  
  trigger:
    - platform: state
      entity_id: input_boolean.sleeptime
      from: 'on'
      to: 'off'
  
  action:
    - service: switch.turn_off
      entity_id: switch.master_bedroom_echo_do_not_disturb_switch

# Guest bedroom echo devices might be muted at night. Unmute them at 9 AM. Note that the master bedroom echo is unmuted
# above at the end of nighttime.
- alias: Unmute Guest Bedroom Echoes
  id: 'unmute_guest_bedroom_echoes'
  
  trigger:
    - platform: time
      at: '09:00:00'
  
  action:
    - service: switch.turn_off
      entity_id:
        - switch.studio_echo_do_not_disturb_switch
        - switch.penthouse_echo_do_not_disturb_switch

#========================#
#     Legion T530 PC     #
#========================#

# HASS.Agent appears to only update sensors when they change. Since that happens infrequently for the last boot,
# the HASS.Agent sensor becomes unknown after some time (I'm guessing a bit here as to why this happens).
# So this automation saves the last boot time if it changes, and we use the saved value everywhere instead of
# the one from HASS.Agent.
- alias: Update PC Lastboot
  id: update_pc_lastboot
  
  trigger:
    - platform: state
      entity_id: sensor.legion_t530_lastboot
      to:
  
  condition: "{{ trigger.to_state.state not in ['unknown', 'unavailable'] }}"
  
  action:
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.pc_lastboot
      data:
        timestamp: "{{ as_timestamp(states('sensor.legion_t530_lastboot')) }}"
