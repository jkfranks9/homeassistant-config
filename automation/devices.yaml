#===============================#
#     Zigbee Initialization     #
#===============================#

# So this is cheating, and might not always work. I have a catch-22 during HA startup:
#
# 1) As zigbee devices are initialized by Zigbee2MQTT they change from 'unavailable' state
# 2) In parallel, the Current Zigbee Unavailable Devices sensor gets initialized
# 3) As a result, some zigbee devices might still be unavailable when the sensor is ready, resulting in a bogus numerical state for the sensor
# 4) As the rest of the zigbee devices come up, the state of the above sensor continues to change toward 0
# 5) About the same time, the Notify Zigbee Device Unavailable automation gets initialized and starts running, triggered by one of the above sensor changes
# 
# At this point, the automation will likely fail due to templates not resolving correctly, but even if there are no failures, the automation should not
# be running at all at this point, since it's just churn during startup. OK, I guess it's possible that a zigbee device could choose to really go unavailable
# at the same time, but oh well. I care less about that than seeing a bunch of errors in the log.
#
# So, the below automation runs at startup and sets a flag, which prevents Notify Zigbee Device Unavailable from running. It waits a bit, then resets the
# flag, so the automation can run for real if a zigbee device becomes unavailable.
#
# So what was that about cheating? Automations are initialized in the order they are read from the files in the automations directory. This file is 'devices',
# which is alphabetically before 'notification'. Which gives me a VERY short amount of time to get this flag set before the notification automation runs.
# So yeah, super awesome stuff.
- alias: Handle Zigbee Catch 22
  id: handle_zigbee_catch_22
  
  trigger:
    - platform: homeassistant
      event: start
  
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.zigbee_catch_22
    
    - delay: '00:01:00'
    
    - service: input_boolean.turn_off
      entity_id: input_boolean.zigbee_catch_22


#=============#
#     UPS     #
#=============#

# Handle a power outage, preserving UPS time for critical resources (HA, NUT server & internet).
- alias: Handle Power Outage
  id: 'handle_power_outage'
  
  # Trigger if the battery is discharging for a short time. I want to ignore the frequent short power glitches,
  # but not leave the PC on too long.
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OB DISCHRG'
      for: '00:01:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OB DISCHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.    
    - service: script.send_notification
      data:
        destination:
          - mobile
        title: 'Warning:'
        message: 'Power is out, shutting down PC.'
        channel: critical
        throttled: false
        tag: 'power_out'
        timeout: 0
    
    # The recorder database lives on the PC, so disable it before we shutdown.
    - service: recorder.disable
    
    # Shut down the PC.
    - service: script.turn_off_pc
    
    # The vacuum bizarrely starts running if the power goes out, so stop it (unless it's already running).   
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
    - service: vacuum.stop
      entity_id: vacuum.ecovacs_deebot 

# Shut down the host if UPS runtime reaches critical level.
- alias: Handle UPS Critical
  id: 'handle_ups_critical'
  
  trigger:
    - platform: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
    - platform: homeassistant
      event: start
  
  condition:
    - condition: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.    
    - service: script.send_notification
      data:
        destination:
          - mobile
        title: 'Warning:'
        message: 'UPS battery is critical, shutting down RPi.'
        channel: critical
        throttled: false
        tag: 'ups_battery'
        timeout: 0
    
    # Goodbye.
    - service: hassio.host_shutdown

# Turn the PC back on if power is restored.
- alias: Handle Power Restoration
  id: 'handle_power_restoration'
  
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OL CHRG'
      for: '00:02:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OL CHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.  
    - service: script.send_notification
      data:
        destination:
          - mobile
        title: 'Attention:'
        message: 'Power is restored, turning on the PC.'
        channel: critical
        throttled: false
        tag: 'power_restored'
        timeout: 0
    
    # Send a magic packet to power on the PC.
    - service: wake_on_lan.send_magic_packet
      data:
        mac: 98-EE-CB-A6-80-EA
    
    # Enable the recorder after a short delay.
    - delay: '00:02:00'
    - service: recorder.enable
    
    # Reset smart bulbs if needed.
    - service: script.reset_smart_bulbs
    
    # Instruct the vacuum to return home.
    - service: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot 

# Restart the NUT server service if it becomes unavailable.
- alias: Reboot NUT Service
  id: reboot_nut_service
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status
      to: 'unavailable'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status
      state: 'unavailable'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - service: shell_command.reboot_nut_service

#===============#
#     House     #
#===============#

# Open up the house when needed.
- alias: Open House
  id: 'open_house'
  
  trigger:
    
    # Jon arrives home.
    - platform: state
      entity_id: person.jon
      from: 'not_home'
      to: 'home'
  
  condition:
    
    # Make sure the Jon Away flag is on. This turns on when I leave home, so should be on now.
    - condition: state
      entity_id: input_boolean.jon_away
      state: 'on'
  
  action:    
    
    # The Jon Away flag needs to get reset now that I'm home. Don't wait for the script, because it contains a several minute delay.
    - service: script.turn_on
      target:
        entity_id: script.reset_jon_away
    
    # Open garage door.
    - service: input_boolean.turn_off
      entity_id: input_boolean.garage_door_info_message
    
    - service: script.turn_on
      target:
        entity_id: script.open_garage_door_north
    
    # Turn on automations that were possibly turned off by Leave Home, and trigger them.
    - service: automation.turn_on
      entity_id: automation.turn_on_christmas_lights
    
    - service: automation.turn_on
      entity_id: automation.turn_on_guest_lights_sunset
    
    - service: automation.trigger
      data:
        entity_id: automation.turn_on_guest_lights_sunset
        skip_condition: false
    
    - service: automation.turn_on
      entity_id: automation.turn_on_office_light
    
    - service: automation.trigger
      data:
        entity_id: automation.turn_on_office_light
        skip_condition: false
    
    # Turn off extended away mode (this should have happened above based on proximity ... this is a failsafe).
    - service: script.turn_off_extended_away_mode
    
    # Disarm Alexa Guard mode if armed.
    - if:
        - condition: state
          entity_id: alarm_control_panel.alexa_guard
          state: armed_away
      
      then:
        - service: alarm_control_panel.alarm_disarm
          entity_id: alarm_control_panel.alexa_guard
    
    # Turn on appropriate lights if it's dark-ish.
    - if:
        - "{{ state_attr('sun.sun', 'elevation') | float(0) <= states('input_number.min_elevation') | float(0) }}"
      
      then:        
        - service: light.turn_on
          entity_id: light.office_lamp
        
        - service: light.turn_on
          data_template:
            entity_id: "{{ iif(states('input_boolean.christmas_mode') == 'off', 'light.daytime_lights', 'light.daytime_christmas_lights') }}"

# Close up the house when needed.
- alias: Close House
  id: 'close_house'
  
  trigger:
    
    # Jon leaves home.
    - platform: state
      entity_id: person.jon
      from: 'home'
      to: 'not_home'
    
    # The sun goes to bed.
    - platform: state
      entity_id: sun.sun
      from: 'above_horizon'
      to: 'below_horizon'
    
    # In case HA was rebooting when one of the above triggers would have happened.
    - platform: homeassistant
      event: start
  
  # These conditions cover the HA start trigger.
  condition:
    - or:
      - condition: state
        entity_id: person.jon
        state: 'not_home'
      
      - condition: state
        entity_id: sun.sun
        state: 'below_horizon'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Close garage doors ... run the scripts in parallel because they contain a several minute delay.
    - service: input_boolean.turn_on
      entity_id: input_boolean.garage_door_info_message
    
    - service: script.turn_on
      target:
        entity_id: script.close_garage_door_north
    
    - service:  script.turn_on
      target:
        entity_id: script.close_garage_door_south
    
    - if:
      
        # I'm not home.
        - "{{ not is_state('person.jon', 'home') }}"
        
      then:
    
        # Indicate I'm  away.
        - service: input_boolean.turn_on
          entity_id: input_boolean.jon_away
    
        # Lock the PC.
        - service: script.turn_on
          entity_id: script.lock_pc
    
        - if:
          
            # No one else is home.
            - "{{ is_state('binary_sensor.adults_home', 'off') }}"
        
          then:
        
            # Turn off all lights.
            - scene: scene.lights_out
        
            # Turn off all fans.
            - scene: scene.fans_off
        
            # Close the upstairs guest bedroom vents.
            - service: script.close_upstairs_br_vents
            
            # Turn off automations that could turn on various lights.
            - service: automation.turn_off
              entity_id:
                - automation.turn_on_christmas_lights
                - automation.turn_on_guest_lights_sunset
                - automation.turn_on_office_light
            
            # Arm Alexa Guard mode.  
            - service: alarm_control_panel.alarm_arm_away
              entity_id: alarm_control_panel.alexa_guard
      
      # Must be sunset.
      else:
        
        # Turn off certain light domains.
        - service: scene.apply
          data:
            entities:
              light.storage_lights: 'off'
              light.outdoor_lights: 'off'

# Open the house for family.
- alias: Open House For Family
  id: 'open_house_for_family'
  mode: queued
  
  trigger:
    
    # Adults arrive.
    - platform: state
      entity_id:
        - person.sarah
        - person.david
        - person.mike
        - person.maryam
      from: 'not_home'
      to: 'home'
      id: adults
    
    # Children arrive.
    - platform: state
      entity_id:
        - person.skylar
      from: 'not_home'
      to: 'home'
      id: children
  
  action:
    
    - variables:
        sarah_nor_skylar: "{{ not is_state('person.sarah', 'home') and not is_state('person.skylar', 'home') }}"
        sarah_nor_david: "{{ not is_state('person.sarah', 'home') and not is_state('person.david', 'home') }}"
    
    # Set the default occupied bedrooms.
    - choose:
      
      # Sarah with David = both.
      - conditions: "{{ (is_state('person.sarah', 'home') and is_state('person.david', 'home')) }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'Both'
      
      # David without Sarah nor Skylar = adult up.
      - conditions: "{{ sarah_nor_skylar and is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'AdultUp'
      
      # Sarah without David = adult down (it's assumed Skylar will sleep with Sarah if she's here).
      - conditions: "{{ is_state('person.sarah', 'home') and not is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'AdultDown'
      
      # Skylar with David = child down plus (plus meaning adult up).
      - conditions: "{{ is_state('person.skylar', 'home') and is_state('person.david', 'home') }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'ChildDownPlus'
      
      # Skylar alone = child down.
      - conditions: "{{ is_state('person.skylar', 'home') and sarah_nor_david }}"
      
        sequence:
          - service: input_select.select_option
            target:
              entity_id: input_select.occupied_bedrooms
            data:
              option: 'ChildDown'
    
    # Perform tasks for adults.
    - if:
        - "{{ trigger.id == 'adults' }}"
      
      then:
        
        # If sunset has already occurred, Close House won't be triggered to close the garage.
        # So start a timer to do that in a bit.
        # Note that we're using the effective sun sensor, which allows us to do testing using the
        # testing infrastructure. If we're not testing the sensor reflects the real sun.
        - if:
            - condition: state
              entity_id: sensor.effective_sun
              state: 'below_horizon'
        
          then:
            - service: timer.start
              data:
                entity_id: timer.garage_north_close
                duration: '00:30:00'
        
        # Open garage door.
        - service: input_boolean.turn_on
          entity_id: input_boolean.garage_door_info_message
        
        - service: script.turn_on
          target:
            entity_id: script.open_garage_door_north
    
    # Perform tasks for children.
    - if:
        - "{{ trigger.id == 'children' }}"
      
      then:
        
        # Turn on bedroom light if needed.
        - service: script.change_lighting_per_weather_simple
          data:
            light_entity: light.guest_bedroom_lamp_2
            turn_on: true

# Close garage door north once a delay has occurred after family has arrived after sunset.
- alias: Close Garage North
  id: close_garage_north
  
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.garage_north_close
  
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.garage_door_info_message
    
    - service: script.turn_on
      target:
        entity_id: script.close_garage_door_north

# Close house when all family members leave.
- alias: Close House For Family
  id: 'close_house_for_family'
  
  trigger:
    
    # Anyone leaves.
    - platform: state
      entity_id: binary_sensor.adults_home
      from: 'on'
      to: 'off'
  
    - platform: state
      entity_id: binary_sensor.children_home
      from: 'on'
      to: 'off'
  
  condition:
    
    # Everyone must be gone.
    - condition: state
      entity_id: binary_sensor.adults_home
      state: 'off'
    
    - condition: state
      entity_id: binary_sensor.children_home
      state: 'off'
  
  action:
    
    # Remove upstairs thermostat hold.
    - service: script.remove_thermostat_hold
      data:
        thermostat_entity: climate.upstairs
        extended: false
    
    # Close the upstairs guest bedroom vents.
    - service: script.close_upstairs_br_vents
    
    # Turn off guest suite lights.
    - service: scene.apply
      data:
        entities:
          light.guest_bedroom_lamp:      'off'
          light.guest_bedroom_lamp_2:    'off'
          light.upstairs_bedroom_light:  'off'
          light.upstairs_bedroom_outlet: 'off'
    
    # Reset occupied bedrooms to none.
    - service: input_select.select_option
      target:
        entity_id: input_select.occupied_bedrooms
      data:
        option: 'None'
            
    # Turn on the vacuum automation.
    - service: script.toggle_vacuum_automation
      data:
        vacuum_name: "{{ state_attr('vacuum.ecovacs_deebot', 'friendly_name') }}"
        operation: 'on'

# Set the upstairs thermostat and bedroom vents appropriately when the occupied bedrooms change.
# Normally this only happens when family members arrive, but it could also be done manually via the UI.
- alias: Prepare Upstairs Bedroom For Family
  id: 'prepare_upstairs_bedroom_for_family'
  mode: queued
  
  # Trigger only on the state of occupied bedrooms.
  trigger:
    - platform: state
      entity_id: input_select.occupied_bedrooms
      not_from:
        - 'AdultUp'
        - 'ChildDownPlus'
        - 'Both'
      to:
        - 'AdultUp'
        - 'ChildDownPlus'
        - 'Both'
  
  # We only care if the upstairs bedroom is occupied by an adult.
  condition: "{{ states('input_select.occupied_bedrooms') in ['AdultUp', 'ChildDownPlus', 'Both'] }}"
  
  action:

    # Set a temporary temperature hold upstairs.
    - service: script.set_temporary_thermostat_hold
      data:
        thermostat_entity: climate.upstairs
        heat_temp: !secret constant_upstairs_home_heat_temp
        cool_temp: !secret constant_upstairs_home_cool_temp
            
    # Open the upstairs guest bedroom vents.
    - service: script.open_upstairs_br_vents
            
    # Turn off the vacuum automation.
    - service: script.toggle_vacuum_automation
      data:
        vacuum_name: "{{ state_attr('vacuum.ecovacs_deebot', 'friendly_name') }}"
        operation: 'off'

# Turn off extended away mode when Jon is nearing home (proximity is somewhat unreliable, so if this doesn't trigger we have a failsafe 
# below in Open House).
- alias: Turn Off Extended Away Mode
  id: 'turn_off_extended_away_mode'
  
  trigger:
    - platform: template
      value_template: "{{ is_state('proximity.jon_home') < 13000 if is_number('proximity.jon_home') }}"
      
  condition: "{{ is_state_attr('proximity.jon_home', 'dir_of_travel', 'towards') }}"
  
  action:
    - service: script.turn_off_extended_away_mode

#=================================#
#     House Open/Close Timing     #
#=================================#

# Deal with the open/close house timing issue. The problem is:
# 
# - One tracker changes to home or not_home state, which changes the person to home or not_home, driving Open House or Close House
# - A second tracker gets an attribute updated (but NOT the state), which changes the person back to not_home or home, driving Close House or Open House
# - The second tracker then changes to home or not_home state, which again drives Open House or Close House
#
# Note that nothing too terrible actually happens: I have seen the garage door get stuck partially open, and a notification that it can't be closed,
# both due to the garage door opener being triggered twice within 1 second. I can live with that, but stuff like this drives me bonkers.

# Handle the Open House variation.
- alias: Handle Open House Timing Issue
  id: 'handle_open_house_timing_issue'
  
  # Trigger on any of the GPS trackers changing from not_home to home.
  trigger:
    - platform: state
      entity_id:
        - device_tracker.jon_galaxy
        - device_tracker.life360_jon_franks
      from: 'not_home'
      to: 'home'
  
  # We only need to trigger on one of the trackers, not all of them, so use the state of the Close House
  # automation to weed out all but the first.
  condition:
    - condition: state
      entity_id: automation.close_house
      state: 'on'
  
  action:
    
    # Temporarily turn off the Close House automation, then turn it back on.
    - service: automation.turn_off
      entity_id: automation.close_house
      
    - delay: "00:02:00"
    
    - service: automation.turn_on
      entity_id: automation.close_house

# Handle the Close House variation.
- alias: Handle Close House Timing Issue
  id: 'handle_close_house_timing_issue'
  
  # Trigger on any of the GPS trackers changing from home to not_home.
  trigger:
    - platform: state
      entity_id:
        - device_tracker.jon_galaxy
        - device_tracker.life360_jon_franks
      from: 'home'
      to: 'not_home'
  
  # We only need to trigger on one of the trackers, not all of them, so use the state of the Open House
  # automation to weed out all but the first.
  condition:
    - condition: state
      entity_id: automation.open_house
      state: 'on'
  
  action:
    
    # Temporarily turn off the Open House automation, then turn it back on.
    - service: automation.turn_off
      entity_id: automation.open_house
      
    - delay: "00:02:00"
    
    - service: automation.turn_on
      entity_id: automation.open_house

#========================#
#     Family Room AV     #
#========================#

# Turn on the Family Room AV during the day, depending on the presence of a grandchild.
- alias: Enable Family Room AV
  id: 'enable_family_room_av'
  trigger:
    - platform: time
      at: '07:00:00'
      id: 'morning'
    - platform: time
      at: '16:00:00'
      id: 'afternoon'
  condition:
    - or:
      - and:
        - condition: state
          entity_id: binary_sensor.children_home
          state: 'on'
        - condition: trigger
          id: 'morning'
      - condition: trigger
        id: 'afternoon'
  action:
    - condition: state
      entity_id: input_boolean.extended_away_mode
      state: 'off'
    - service: script.enable_family_room_av

#================================#
#     Human Presence Sensors     #
#================================#

# The office has a human presence sensor to detect presence. I want to use that to control the ceiling fan.
# But what is needed is a delayed reaction after the human presence sensor turns off, so the fan doesn't go off until it's
# clear that the office is unoccupied. So we use an input boolean here that turns on quickly but only turns off 
# if the human presence sensor doesn't detect presence for a decent interval.
- alias: Turn On Office occupied
  id: turn_on_office_occupied
  
  trigger:
    - platform: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'off'
      to: 'on'
      for: '00:02:00'
  
  action:
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.office_occupied

- alias: Turn Off Office occupied
  id: turn_off_office_occupied
  
  trigger:
    - platform: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'on'
      to: 'off'
      for: '00:30:00'
  
  action:
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.office_occupied

#======================#
#     Ceiling Fans     #
#======================#

# Control office fan automation based on the AV system in use or not.
- alias: Control Office Fan Automation
  id: 'control_office_fan_automation'
  
  use_blueprint:
    path: devices/control_ceiling_fan_automations.yaml
    input:
      sensor_entity: input_boolean.office_occupied
      automation_entity: automation.operate_office_fan
      speed_entity: input_number.office_fan_speed
      fan_entity: fan.office_fan

# Control family room fan automation based on the AV system in use or not.
- alias: Control Family Room Fan Automation
  id: 'control_family_room_fan_automation'
  
  use_blueprint:
    path: devices/control_ceiling_fan_automations.yaml
    input:
      sensor_entity: binary_sensor.family_room_av_system
      automation_entity: automation.operate_family_room_fan
      speed_entity: input_number.family_room_fan_speed
      fan_entity: fan.family_room_fan

# Control theater fan automation based on the AV system in use or not.
- alias: Control Theater Fan Automation
  id: 'control_theater_fan_automation'
  
  use_blueprint:
    path: devices/control_ceiling_fan_automations.yaml
    input:
      sensor_entity: binary_sensor.theater_av_system
      automation_entity: automation.operate_theater_fan
      speed_entity: input_number.theater_fan_speed
      fan_entity: fan.theater_fan

# Operate the office fan when the AV system is on.
- alias: Operate Office Fan
  id: 'operate_office_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: input_boolean.office_occupied
      temperature_entity: sensor.office_temperature
      fan_entity: fan.office_fan
      thresholds: [79, 77, 75]

# Operate the family room fan when the AV system is on.
- alias: Operate Family Room Fan
  id: 'operate_family_room_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: binary_sensor.family_room_av_system
      temperature_entity: sensor.main_floor_temperature
      fan_entity: fan.family_room_fan
      thresholds: [80, 76, 73]

# Operate the theater fan when the AV system is on.
- alias: Operate Theater Fan
  id: 'operate_theater_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: binary_sensor.theater_av_system
      temperature_entity: sensor.theater_temperature
      fan_entity: fan.theater_fan
      thresholds: [79, 74, 72]

#===================#
#     Treadmill     #
#===================#

# Treadmill start
- alias: Start Treadmill
  id: 'start_treadmill'
  
  # Trigger when the power usage of the treadmill rises above a threshold that indicates typical usage.
  trigger:
    - platform: numeric_state
      entity_id: sensor.sonoff_treadmill_power
      above: 200
  
  # If the treadmill is paused during a workout, the power usage drops below the above threshold then rises again.
  # This re-triggers this automation, so this condition prevents overwriting the start time.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'off'
  
  action:
    
    # Set the treadmill start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.treadmill_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Set the flag used in the above condition that prevents re-triggers on pause.
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.treadmill_triggered

# Treadmill stop
- alias: Stop Treadmill
  id: 'stop_treadmill'
  
  # Trigger when the power usage of the treadmill indicates it's been turned off.
  trigger:
    - platform: numeric_state
      entity_id: sensor.sonoff_treadmill_power
      below: 7
  
  # Only continue if the start automation was previously triggered.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  action:
    
    # Reset the triggered flag.
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.treadmill_triggered
    
    # Turn off the treadmill power to conserve energy (a few watts are used for an illuminated power toggle).
    - service: switch.turn_off
      target:
        entity_id: switch.sonoff_treadmill
    
    # Indicate we used the treadmill today.
    - service: input_boolean.turn_on
      target:
        entity_id: "{{ 'input_boolean.treadmill_' ~ as_timestamp(now()) | timestamp_custom('%a') | lower() }}"
    
    # Calculate the amount of time spent walking. I always walk some multiple of 5 minutes with a 1 minute cooldown, so round
    # down to the nearest 5 minutes (there could be an extra minute or two during a workout pause). The cooldown period
    # is accounted for in the next step.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_time
      data:
        value: >
          {% set start = as_timestamp(strptime(states('input_datetime.treadmill_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set num = (now().timestamp() - start) // 60 %}
          {% set minutes = (num - (num % 5)) %}
          {{ minutes }}
    
    # Calculate calories burned. This is stolen from shapesense.com ... the formula is (for example 0 degree incline):
    #   CB = [0.0215 x KPH³ - 0.1765 x KPH² + 0.8710 x KPH + 1.4577] x WKG x T
    #
    #     CB = Calorie burn (in calories)
    #     KPH = Walking speed (in kilometres per hour)
    #     WKG = Weight (in kilograms)
    #     T = Time (in hours)
    #
    # NOTES:
    #   - The above formula only works for 0-5 degree incline ... more work needed here if I ever do higher inclines.
    #   - My cooldown period is always 1 minute at 2.0 MPH (ctime and ckph variables).
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_calories
      data:
        value: >
          {% set weight  = states('input_number.user_weight') | int(0) %}
          {% set speed   = states('input_number.treadmill_speed') | float(0) %}
          {% set incline = states('input_number.treadmill_incline') | int(0) %}
          {% set time    = states('input_number.treadmill_daily_time') | int(0) / 60 %}
          {% set ctime   = 1/60 %}
          {% set kph     = speed * 1.609344 %}
          {% set ckph    = 2.0   * 1.609344 %}
          {% set wkg     = weight * 0.45359237 %}
          {% if states('input_number.treadmill_incline') | int(0) == 0 %}
            {% set cooldown = (((ckph**3 * 0.0215) - (ckph**2 * 0.1765) + (ckph * 0.8710) + 1.4577) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0215) -  (kph**2 * 0.1765) +  (kph * 0.8710) + 1.4577) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 1 %}
            {% set cooldown = (((ckph**3 * 0.0171) - (ckph**2 * 0.1062) + (ckph * 0.6080) + 1.8600) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0171) -  (kph**2 * 0.1062) +  (kph * 0.6080) + 1.8600) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 2 %}
            {% set cooldown = (((ckph**3 * 0.0184) - (ckph**2 * 0.1134) + (ckph * 0.6566) + 1.9200) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0184) -  (kph**2 * 0.1134) +  (kph * 0.6566) + 1.9200) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 3 %}
            {% set cooldown = (((ckph**3 * 0.0196) - (ckph**2 * 0.1205) + (ckph * 0.7053) + 1.9800) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0196) -  (kph**2 * 0.1205) +  (kph * 0.7053) + 1.9800) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 4 %}
            {% set cooldown = (((ckph**3 * 0.0208) - (ckph**2 * 0.1277) + (ckph * 0.7539) + 2.0400) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0208) -  (kph**2 * 0.1277) +  (kph * 0.7539) + 2.0400) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 5 %}
            {% set cooldown = (((ckph**3 * 0.0221) - (ckph**2 * 0.1349) + (ckph * 0.8025) + 2.1000) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0221) -  (kph**2 * 0.1349) +  (kph * 0.8025) + 2.1000) * wkg *  time) | int(0) }}
          {% endif %}
    
    # Register weekly and monthly exercise metrics.
    - service: script.register_exercise_metrics
      data:
        exercise_type: treadmill
    
    # Update the current treadmill used minutes. We keep minutes because the treadmill time is likely to not be an even hour.
    # We convert the minutes to hours in order to determine if lubrication is needed.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_usage_minutes
      data:
        value: "{{ states('input_number.treadmill_usage_minutes') | int(0) + states('input_number.treadmill_daily_time') | int(0) }}"

#====================#
#     Appliances     #
#====================#

# Check if the refrigerator is somehow off.
- alias: Check Refrigerator Off
  id: check_refrigerator_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.sonoff_refrigerator
      component_name: sonoff
      device_name: Refrigerator

# Check if the microwave is somehow off.
- alias: Check Microwave Off
  id: check_microwave_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.sonoff_microwave
      component_name: sonoff
      device_name: Microwave

#======================#
#     Robot Vacuum     #
#======================#

# Launch the vacuum.
- alias: Start Vacuum
  id: 'start_vacuum'
  
  trigger:
    - platform: time
      at: '03:19:00'
  
  condition:
    - condition: time
      weekday:
        - mon
    
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
  
  action:
    - service: input_boolean.turn_off
      entity_id: input_boolean.vacuum_kicked_off
    
    - service: vacuum.turn_on
      entity_id: vacuum.ecovacs_deebot
    
    - service: timer.start
      data:
        entity_id: timer.vacuum
        duration: '01:00:00'

# Land the vacuum.
- alias: Stop Vacuum
  id: 'stop_vacuum'
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.vacuum
    - platform: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 20
  condition:
    - condition: time
      weekday:
        - mon
  action:
    - service: vacuum.turn_off
      entity_id: vacuum.ecovacs_deebot

# Detect the vacuum running - we use the battery dropping below a threshold as the trigger.
- alias: Detect Vacuum Running
  id: 'detect_vacuum_running'
  trigger:
    - platform: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 90
  condition:
    - condition: time
      weekday:
        - mon
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.vacuum_kicked_off

#================#
#     Washer     #
#================#

# Set the washer start time, based on the power state changing from stop to fill (or a potential unknown to fill).
- alias: Start Washer
  id: 'start_washer'
  
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
      from:
        - 'stop'
        - 'unknown'
      to: 'fill'
  
  action:
    
    # Set the washer start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.washer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Indicate load size is sensing.
    - service: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: '*sensing*'
    
    # Remember to backup the log tomorrow morning.
    - service: input_boolean.turn_on
      entity_id: input_boolean.backup_laundry_log
    
    # Log the start in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Washer
        message: starting

# Set the washer load size, based on the amount of time spent on the initial fill. This is triggered only
# when the power state changes from fill to raise, and the washer state is Wash Fill.
- alias: Set Washer Load Size
  id: 'set_washer_load_size'
  
  trigger:
    - platform: state
      entity_id: sensor.washer_power_state
      from: 'fill'
      to: 'raise'
  
  condition:
    - condition: state
      entity_id: input_select.washer_state
      state: 'Wash Fill'
  
  action:
    - variables:
        washer_fill_seconds: >
          {% set start = as_timestamp(strptime(states('input_datetime.washer_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set seconds = (now().timestamp() - start) | round(0) %}
          {{ seconds }}
    
    # Set the washer load size. Default to medium if the calculation for seconds is unreasonably small.
    - service: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: >
          {% if   washer_fill_seconds >= 180 and washer_fill_seconds < 350 %}
            Small
          {% elif washer_fill_seconds >= 350 and washer_fill_seconds < 450 %}
            Medium
          {% elif washer_fill_seconds >= 450  %}
            Large
          {% else %}
            Medium
          {% endif %}
    
    # Save the washer fill seconds for diagnosis/tweaking.
    - service: input_number.set_value
      target:
        entity_id: input_number.washer_fill_seconds
      data:
        value: "{{ washer_fill_seconds }}"
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: fill_plus_load
        prefix: Washer
        message: fill time, load size
        entity_id_1: input_number.washer_fill_seconds
        entity_id_2: input_select.washer_load_size

# Start the washer wash blackout timer. This is used to ignore a potential early drop,
# which would shorten the wash cycle dramatically.
- alias: Start Washer Wash Blackout Timer
  id: 'start_washer_wash_blackout_timer'
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Wash Fill'
      to: 'Wash'
  
  action:
    - service: timer.start
      data:
        entity_id: timer.washer_wash_blackout
        duration: '00:01:00'
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: timer started
        entity_id_1: timer.washer_wash_blackout

# Start the washer rinse fill blackout timer. This is used to ignore the fabric softener injection
# during the rinse fill, which otherwise wreaks havoc on the operation control algorithm.
- alias: Start Washer Rinse Fill Blackout Timer
  id: 'start_washer_rinse_fill_blackout_timer'
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Wash Drain'
      to: 'Rinse Fill'
  
  condition:
    - condition: state
      entity_id: input_boolean.washer_fabric_softener
      state: 'on'
  
  action:
    
    # The timer amount is based on the washer load size.
    - choose:
      
      # Small
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Small'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:03:00'
        
      # Medium
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Medium'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:04:00'
        
      # Large
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Large'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:05:00'
      
      # Invalid load size, log it. Then use the medium value and hope for the best.
      default:
        - service: system_log.write
          data:
            message: "Invalid washer load size {{ states('input_select.washer_load_size') }} specified"
            level: error
        - service: timer.start
          data:
            entity_id: timer.washer_rinse_fill_blackout
            duration: '00:04:00'
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: timer started
        entity_id_1: timer.washer_rinse_fill_blackout

# Start the washer rinse blackout timer. This is used to ignore a potential early drop,
# which would shorten the rinse cycle dramatically.
- alias: Start Washer Rinse Blackout Timer
  id: 'start_washer_rinse_blackout_timer'
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Rinse Fill'
      to: 'Rinse'
  
  action:
    - service: timer.start
      data:
        entity_id: timer.washer_rinse_blackout
        duration: '00:01:00'
    
    # Log the event in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: timer started
        entity_id_1: timer.washer_rinse_blackout

# Washer operation control. This uses the washer power state sensor and other controls to step through the following washer states:
#
# - Stop
# - Wash Fill
# - Wash
# - Wash Drain
# - Rinse Fill
# - Rinse
# - Rinse Drain
# - Stop
- alias: Set Washer Operation
  id: 'set_washer_operation'
  
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
  
  condition: "{{ trigger.from_state and trigger.from_state.state != 'unavailable' }}"
  
  action:
    
    # Delay one second so automations (above) that determine the load size have a chance to run before we do.
    - delay: '00:00:01'
    
    - variables:
        s: "{{ states('input_select.washer_state') }}"
    
    # Determine the washer state.
    - service: input_select.select_option
      data:
        entity_id: input_select.washer_state
        option: >
          {# --Set variables-- #}
          {% set fr = trigger.from_state.state %}
          {% set to = trigger.to_state.state %}
          {% set t1 = states('timer.washer_rinse_fill_blackout') %}
          {% set t2 = states('timer.washer_rinse_blackout') %}
          {% set t3 = states('timer.washer_wash_blackout') %}
          
          {# --Ignore everything if one of the timers is running-- #}
          {% if t1 == 'active' or t2 == 'active' or t3 == 'active' %} {{ s }}
          
          {# --Transition to new state based on current state and washer power state sensor change-- #}
          {% elif fr in ['stop', 'unknown'] and to == 'fill' %}                                    Wash Fill
          {% elif fr == 'fill'              and to == 'raise'   and s == 'Wash Fill' %}            Wash
          {% elif fr == 'raise'             and to == 'drop'    and s in ['Wash', 'Wash Drain'] %} Wash Drain
          {% elif fr in ['drop', 'raise']   and to == 'fill'    and s == 'Wash Drain' %}           Rinse Fill
          {% elif fr in ['fill', 'drop']    and to == 'raise'   and s == 'Rinse Fill' %}           Rinse
          {% elif fr == 'raise'             and to == 'drop'    and s == 'Rinse' %}                Rinse Drain     
          
          {# --Some washer power state sensor changes just remain in the current state-- #}
          {% elif fr == 'drop'  and to in ['fill', 'raise'] %} {{ s }}
          {% elif fr == 'fill'  and to in ['drop', 'raise'] %} {{ s }}
          {% elif fr == 'raise' and to in ['fill', 'drop'] %}  {{ s }}
          
          {# --Catch-all, default to Stop-- #}
          {% else %} Stop
          {% endif %}
    
    # Continue if the state changed.
    - if:
        - "{{ s != states('input_select.washer_state') }}"
      
      then:
        
        # Log the state change in the laundry events log.
        - service: script.log_laundry_event
          data:
            event_type: basic
            prefix: Washer
            message: "state changed from {{ s }} to {{ states('input_select.washer_state') }}"
        
        # If the washer just stopped, log that as well.
        - if:
            - "{{ is_state('input_select.washer_state', 'Stop') }}"
          
          then:
            - service: script.log_laundry_event
              data:
                event_type: basic
                prefix: Washer
                message: stopped

#===============#
#     Dryer     #
#===============#

- alias: Start Dryer
  id: start_dryer
  
  trigger:
    - platform: state
      entity_id: binary_sensor.dryer_start_button
      from: 'off'
      to: 'on'
  
  action:
    
    # Remember to backup the log tomorrow morning.
    - service: input_boolean.turn_on
      entity_id: input_boolean.backup_laundry_log
    
    # Log the start in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: >
          {% set intemp  = state_attr('climate.downstairs', 'current_temperature') %}
          {% set inhum   = state_attr('climate.downstairs', 'current_humidity') %}
          {% set outtemp = states('sensor.porch_temperature') %}
          {% set outhum  = states('sensor.porch_humidity') %}
          {% set drytemp = states('sensor.dryer_temperature') %}
          {% set dryhum  = states('sensor.dryer_humidity') %}
          
          starting: indoor ({{ intemp }}°, {{ inhum }}%); outdoor ({{ outtemp }}°, {{ outhum }}%); dryer ({{ drytemp }}°, {{ dryhum }}%)

- alias: Turn On Dryer Running
  id: turn_on_dryer_running
  
  trigger:
    
    # Trigger when the dryer vibration sensor activates.
    - platform: state
      entity_id: binary_sensor.dryer_vibration_sensor_vibration
      from: 'off'
      to: 'on'
      for: 30
      
  action:
    
    # Indicate the dryer is running.
    - service: input_boolean.turn_on
      entity_id: input_boolean.dryer_running
    
    # Log temperature detected in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: running

- alias: Turn Off Dryer Running
  id: turn_off_dryer_running
  
  trigger:
    
    # Trigger when the dryer vibration sensor deactivates.
    - platform: state
      entity_id: binary_sensor.dryer_vibration_sensor_vibration
      from: 'on'
      to: 'off'
      for: 30
  
  action:
    
    # Turn off the dryer running flag.
    - service: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    
    # Log the stop in the laundry events log.
    - service: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: stopped

#=======================#
#     General Plugs     #
#=======================#

# Control the treadmill fan based on temperature.
- alias: Turn On Treadmill Fan
  id: 'turn_on_treadmill_fan'
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'on'
  action:
    - choose:
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 70.0
        sequence:
          - delay: '00:10:00'
          - service: switch.turn_on
            entity_id: switch.general_plug_1
      
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 75.0
        sequence:
          - delay: '00:05:00'
          - service: switch.turn_on
            entity_id: switch.general_plug_1
      
      default:
        - service: switch.turn_on
          entity_id: switch.general_plug_1

- alias: Turn Off Treadmill Fan
  id: 'turn_off_treadmill_fan'
  
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'off'
  
  action:
    
    # Allow a nice cooldown period.
    - delay: '00:02:00'
    
    # Turn off the treadmill fan.
    - service: switch.turn_off
      entity_id: switch.general_plug_1
    
    # Now turn on the office fan so I can continue cooling down.
    - service: script.turn_on
      entity_id: script.control_fan_for_temperature
      data:
        variables:
          fan_entity_id: fan.office_fan
          temperature_entity_id: sensor.office_temperature
          thresholds: [76, 74, 72]
          timeout: 240

#=============================#
#     Tag/Beacon Presence     #
#=============================#

- alias: Log Blue Charm Presence
  id: log_blue_charm_presence
  mode: queued
  
  trigger:
    - platform: state
      entity_id: sensor.blue_charm_presence
  
  action:
    - service: system_log.write
      data:
        message: "Blue Charm from: {{ trigger.from_state.state }}, to: {{ trigger.to_state.state }}"
        level: debug

- alias: Log Garage Distance
  id: log_garage_distance
  mode: queued
  
  trigger:
    - platform: state
      entity_id: sensor.ble_garage_blue_charm_distance
  
  action:
    - service: system_log.write
      data:
        message: "Garage distance from: {{ trigger.from_state.state }}, to: {{ trigger.to_state.state }}"
        level: debug

- alias: Log House Distance
  id: log_house_distance
  mode: queued
  
  trigger:
    - platform: state
      entity_id: sensor.ble_house_blue_charm_distance
  
  action:
    - service: system_log.write
      data:
        message: "House distance from: {{ trigger.from_state.state }}, to: {{ trigger.to_state.state }}"
        level: debug

# Activate Blue Charm beacon device tracker.
- alias: Activate Beacon Device Tracker
  id: 'activate_beacon_device_tracker'
  trigger:
    - platform: state
      entity_id: sensor.blue_charm_presence
      from: 'Away'
      to:
        - 'Garage'
        - 'House'
  
  action:
    - service: mqtt.publish
      data:
        topic: "homeassistant/device_tracker/bluecharm_beacon"
        payload: "home"

# Deactivate Blue Charm beacon device tracker.
- alias: Deactivate Beacon Device Tracker
  id: 'deactivate_beacon_device_tracker'
  trigger:
    - platform: state
      entity_id: sensor.blue_charm_presence
      from:
        - 'Garage'
        - 'House'
      to: 'Away'
  
  # So we have a possible timing problem: during startup, the Blue Charm Presence sensor can change to Away if ESPHome has not had 
  # time to initialize the BLE readers (garage and house). We don't want to turn off children home in this case.
  # So we verify that the wifi sensors in both readers are in a good state before continuing. Yeah, I know.
  condition: "{{ states('sensor.ble_garage_wifi_signal') not in ['unknown', 'unavailable'] and states('sensor.ble_house_wifi_signal') not in ['unknown', 'unavailable'] }}"
  
  action:
    - service: mqtt.publish
      data:
        topic: "homeassistant/device_tracker/bluecharm_beacon"
        payload: "not_home"

#======================#
#     Echo Devices     #
#======================#

# Mute master bedroom echo.
- alias: Mute Master Bedroom Echo
  id: 'mute_master_bedroom_echo'
  
  trigger:
    - platform: state
      entity_id: input_boolean.sleeptime
      from: 'off'
      to: 'on'
  
  action:
    - service: switch.turn_on
      entity_id: switch.master_bedroom_echo_do_not_disturb_switch

# Unmute master bedroom echo.
- alias: Unmute Master Bedroom Echo
  id: 'unmute_master_bedroom_echo'
  
  trigger:
    - platform: state
      entity_id: input_boolean.sleeptime
      from: 'on'
      to: 'off'
  
  action:
    - service: switch.turn_off
      entity_id: switch.master_bedroom_echo_do_not_disturb_switch

# Guest bedroom echo devices might be muted at night. Unmute them at 9 AM. Note that the master bedroom echo is unmuted
# above at the end of nighttime.
- alias: Unmute Guest Bedroom Echoes
  id: 'unmute_guest_bedroom_echoes'
  
  trigger:
    - platform: time
      at: '09:00:00'
  
  action:
    - service: switch.turn_off
      entity_id:
        - switch.guest_bedroom_echo_do_not_disturb_switch
        - switch.upstairs_bedroom_echo_do_not_disturb_switch

#=====================#
#     Smart Vents     #
#=====================#

# Control upstairs bedroom vents based on HVAC fan (only) running. The fan runs a short period every hour to circulate air a bit,
# so I want the vents to be open when that happens, unless the bedroom is occupied.
- alias: Open Upstairs Bedroom Vents
  id: 'open_upstairs_bedroom_vents'
  
  trigger:
    - platform: state
      entity_id: climate.upstairs
      attribute: fan
      from: 'off'
      to: 'on'
  
  condition:
    
    # Ensure ONLY the fan is running.
    - condition: template
      value_template: "{{ state_attr('climate.upstairs', 'equipment_running') == 'fan' }}"
    
    # Ensure the upstairs bedroom is not occupied.
    -  "{{ is_state('binary_sensor.upstairs_bedroom_occupied', 'off') }}"
  
  action:
    - service: script.open_upstairs_br_vents

- alias: Close Upstairs Bedroom Vents
  id: 'close_upstairs_bedroom_vents'
  
  trigger:
    - platform: state
      entity_id: climate.upstairs
      attribute: fan
      from: 'on'
      to: 'off'
  
  condition:
    
    # Ensure the upstairs bedroom is not occupied.
    -  "{{ is_state('binary_sensor.upstairs_bedroom_occupied', 'off') }}"
  
  action:
    - service: script.close_upstairs_br_vents
