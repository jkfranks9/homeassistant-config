#===============================#
#     Device Initialization     #
#===============================#

# So this is cheating, and might not always work. I have a catch-22 during HA startup:
#
# 1) As zigbee or echo devices are initialized they change from 'unavailable' state
# 2) In parallel, the Current Zigbee/Echo Unavailable Devices sensor gets initialized
# 3) As a result, some zigbee/echo devices might still be unavailable when the sensor is ready, resulting in a bogus numerical state for the sensor
# 4) As the rest of the zigbee/echo devices come up, the state of the above sensor continues to change toward 0
# 5) About the same time, the Notify Zigbee/Echo Device Unavailable automation gets initialized and starts running, triggered by one of the above sensor changes
# 
# At this point, the automation may fail due to templates not resolving correctly, but even if there are no failures, the automation should not
# be running at all at this point, since it's just churn during startup. OK, I guess it's possible that a device could choose to really go unavailable
# at the same time, but oh well. I care less about that than seeing a bunch of errors in the log.
#
# So, the below automation runs at startup and sets a flag, which prevents Notify Zigbee/Echo Device Unavailable from running. It waits a bit, then resets the
# flag, so the automation can run for real if a zigbee/echo device becomes unavailable.
#
# So what was that about cheating? Automations are initialized in the order they are read from the files in the automations directory. This file is 'devices',
# which is alphabetically before 'notification'. Which gives me a VERY short amount of time to get this flag set before the notification automation runs.
# So yeah, super awesome stuff.
- alias: Handle Device Initialization Catch 22
  id: handle_device_initialization_catch_22
  
  triggers:
    - trigger: homeassistant
      event: start
  
  actions:
    - action: input_boolean.turn_on
      entity_id: input_boolean.device_initialization_catch_22
    
    - delay: '00:01:30'
    
    - action: input_boolean.turn_off
      entity_id: input_boolean.device_initialization_catch_22


#=============#
#     UPS     #
#=============#

# Handle a power outage, preserving UPS time for critical resources (HA, NUT server & internet).
- alias: Handle Power Outage
  id: 'handle_power_outage'
  
  # Trigger if the battery is discharging for a short time. I want to ignore the frequent short power glitches,
  # but not leave the PC on too long.
  triggers:
    - trigger: state
      entity_id: sensor.cyber1_status_data
      to: 'OB DISCHRG'
      for: '00:01:00'
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OB DISCHRG'
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: power_out
        title: 'Warning:'
        message: Power is out, shutting down PC.
        channel: critical
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'auto', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'tag': tag} }}"
    
    # Save a timestamp for this event.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.ups_power_out
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
    
    # The recorder database lives on the PC, so disable it before we shutdown.
    - action: recorder.disable
    
    # Shut down the PC.
    - action: script.turn_off_pc
    
    # The vacuum bizarrely starts running if the power goes out, so stop it (unless it's already running).
    - if:  
        - condition: state
          entity_id: timer.vacuum
          state: 'idle'
      
      then:        
        - action: vacuum.stop
          entity_id: vacuum.ecovacs_deebot_none 

# Shut down the host if UPS runtime reaches critical level.
- alias: Handle UPS Critical
  id: 'handle_ups_critical'
  
  triggers:
    - trigger: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: ups_battery
        title: 'Warning:'
        message: UPS battery is critical, shutting down RPi.
        channel: critical
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'auto', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'tag': tag} }}"
    
    # Save a timestamp for this event.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.ups_battery_critical
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
    
    # Goodbye.
    - delay: 3
    - action: hassio.host_shutdown

# Turn the PC back on if power is restored.
- alias: Handle Power Restoration
  id: 'handle_power_restoration'
  
  triggers:
    - trigger: state
      entity_id: sensor.cyber1_status_data
      to: 'OL CHRG'
      for: '00:02:00'
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OL CHRG'
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
       
    - variables:
        tag: power_restored
        title: 'Attention:'
        
        # The message indicates power is restored, but also includes the original outage time. If the UPS battery went critical it includes that time as well.
        message: >
          {% set var = namespace(outage = '', critical = '') %}
          {% set prefix = 'Power is restored, turning on the PC (' %}
          {% set keys = state_attr('sensor.mobile_tag_registry_keys', 'tags') %}
          {% set var.outage = 'outage: ' ~ state_attr('input_datetime.ups_power_out', 'timestamp') | timestamp_custom %}
          {% if 'ups_battery' in keys %}
            {% set var.critical = ', critical: ' ~ state_attr('input_datetime.ups_battery_critical', 'timestamp') | timestamp_custom %}
          {% endif %}
          
          {{ prefix ~ var.outage ~ var.critical ~ ')' }}
        
        channel: standard
        tag_registry_value: "{{ {'tag': tag, 'clear_type': 'manual', 'title': title, 'message': message, 'channel': channel, 'timeout': 0} }}"
        notification_data: "{{ {'destination': ['mobile'], 'title': title, 'message': message, 'channel': channel, 'timeout': 0, 'tag': tag} }}"
    
    # Register the tag.
    - action: script.register_mobile_notification
      data: "{{ tag_registry_value }}"
    
    # Send a notification.    
    - action: script.send_notification
      data: "{{ notification_data }}"
      
    # Remove previous notifications and unregister the tags. We could have one or both of these but there's no need to check, since
    # nothing bad happens if a tag doesn't exist.
    - action: script.remove_mobile_notification
      data:
        tag: 'power_out'
    
    - action: script.remove_mobile_notification
      data:
        tag: 'ups_battery'
    
    # Send a magic packet to power on the PC.
    - action: wake_on_lan.send_magic_packet
      data:
        mac: 98-EE-CB-A6-80-EA
    
    # Enable the recorder after a short delay.
    - delay: '00:02:00'
    - action: recorder.enable
    
    # Instruct the vacuum to return home.
    - action: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot_none
    
    # The theater might have been on when power went out; reset the flag so it will open the next time.
    - action: input_boolean.turn_off
      entity_id: input_boolean.theater_open
    
    # Also, make sure the theater devices are turned off. The Activate Cinema script won't function properly
    # otherwise.
    - action: remote.turn_off
      entity_id: remote.harmony_hub

# Restart the NUT server service if it becomes unavailable.
- alias: Reboot NUT Service
  id: reboot_nut_service
  triggers:
    - trigger: state
      entity_id: sensor.cyber1_status
      to: 'unavailable'
    
    - trigger: homeassistant
      event: start
  
  conditions:
    - condition: state
      entity_id: sensor.cyber1_status
      state: 'unavailable'
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - action: shell_command.reboot_nut_service

#====================#
#     House: Jon     #
#====================#

# Open up the house when needed.
- alias: Open House
  id: 'open_house'
  
  triggers:
    
    # Jon arrives home.
    - trigger: state
      entity_id: person.jon
      from: 'not_home'
      to: 'home'
      for: '00:00:05'
  
  actions: 
    
    # Open garage door.
    - action: script.turn_on
      target:
        entity_id: script.open_garage_door_north
      data:
        variables:
          use_info_message: false
    
    # Turn off extended away mode (this should have happened above based on proximity ... this is a failsafe).
    - action: script.turn_off_extended_away_mode
    
    # Turn on appropriate lights if it's dark-ish.
    - if:
        - "{{ states('sensor.downstairs_sensor_ambient_light') | float(0) < states('input_number.family_room_ambient_min') | float(0) }}"
      
      then:
        
        # Always turn on these.
        - action: light.turn_on
          target:
            entity_id:
              - light.office_lamp
              - light.driveway
              - light.front_floodlight
        
        # Daytime or Christmas lights.
        - if:
            - condition: state
              entity_id: input_boolean.christmas_mode
              state: 'off'
          
          then:        
            - action: light.turn_on
              target:
                entity_id:
                  - light.family_room_lamp
                  - light.hallway_lamp
          
          else:
            - action: script.turn_on_christmas_lights
              data:
                variables:
                  additional_lights: daytime
        
        # Studio lamp(s) if Skylar home alone.
        - if:
            - condition: state
              entity_id: person.skylar
              state: 'home'
          
          then:
            - action: script.operate_preferred_studio_lamps
              data:
                operation: 'on'
            
        # Start a timer to close the garage and turn off outdoor lights after a short period of time.
        - action: timer.start
          data:
            entity_id: timer.jon_arrival_cleanup
            duration: '00:15:00'

# Close up the house when needed.
- alias: Close House
  id: 'close_house'
  mode: queued
  
  triggers:
    
    # Jon leaves home.
    - trigger: state
      entity_id: person.jon
      from: 'home'
      to: 'not_home'
      for: '00:00:05'
      id: jon_left
    
    # The sun goes to bed.
    - trigger: state
      entity_id: sun.sun
      from: 'above_horizon'
      to: 'below_horizon'
      id: sunset
    
    # In case HA was rebooting when one of the above triggers would have happened.
    - trigger: homeassistant
      event: start
      id: start
  
  # These conditions cover the HA start trigger.
  conditions:
    - or:
      - condition: state
        entity_id: person.jon
        state: 'not_home'
      
      - condition: state
        entity_id: sun.sun
        state: 'below_horizon'
  
  actions:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Close garage doors ... run the scripts in parallel because they contain a several minute delay.
    - action: script.turn_on
      target:
        entity_id: script.close_garage_door_north
      data:
        variables:
          use_info_message: true
    
    - action:  script.turn_on
      target:
        entity_id: script.close_garage_door_south
      data:
        variables:
          use_info_message: true
    
    - if:
      
        # I just left home.
        - "{{ trigger.id != 'sunset' and not is_state('person.jon', 'home') }}"
        
      then:
    
        # Lock the PC.
        - action: script.turn_on
          entity_id: script.lock_pc
    
        - if:
          
            # No one else is home.
            - "{{ is_state('binary_sensor.adults_home', 'off') }}"
        
          then:
        
            # Turn off all lights and fans.
            - action: scene.turn_on
              target:
                entity_id:
                  - scene.lights_out
                  - scene.fans_off_downstairs
                  - scene.fans_off_upstairs
            
            # Fan lights are not included in light groups. They operate in optimistic mode and therefore use a script.
            - action: script.turn_off_fan_lights
              data:
                light_entity: "{{ expand(state_attr('light.ceiling_fan_lights', 'entity_id')) | map(attribute = 'entity_id') | list }}"
      
    - if:
      
        # Must be sunset.
        - "{{ trigger.id != 'jon_left' and states('sun.sun') == 'below_horizon' }}"
        
      then:
         
         # Turn off certain light domains.
         - action: light.turn_off
           target:
             entity_id:
               - light.storage_lights
               - light.outdoor_lights

#===============================#
#     Guest Arrival Cleanup     #
#===============================#

# Clean up stuff for arrivals after dark.
- alias: Handle Arrival Cleanup
  id: handle__arrival_cleanup
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.jon_arrival_cleanup
      id: jon
    
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.guest_arrival_cleanup
      id: guest
  
  actions:
    
    # This conditional is here in case I need to someday do different things per trigger.
    - if:
        - "{{ trigger.id in ['jon', 'guest'] }}"
      
      then:
        - action: script.turn_on
          target:
            entity_id: script.close_garage_door_north
          data:
            variables:
              use_info_message: true
            
        - action: light.turn_off
          target:
            entity_id:
              - light.driveway
              - light.front_floodlight

#========================#
#     Family Room AV     #
#========================#

# Turn on the Family Room AV during the day, depending on the presence of a grandchild.
- alias: Enable Family Room AV
  id: 'enable_family_room_av'
  
  triggers:
    - trigger: time
      at: '07:00:00'
      id: 'morning'
    
    - trigger: time
      at: '16:00:00'
      id: 'afternoon'
  
  conditions:
    - or:
      - and:
        - condition: state
          entity_id: binary_sensor.children_home
          state: 'on'
        - condition: trigger
          id: 'morning'
      - condition: trigger
        id: 'afternoon'
  
  actions:
    - condition: state
      entity_id: input_boolean.extended_away_mode
      state: 'off'
    
    - action: script.enable_family_room_av

#================================#
#     Human Presence Sensors     #
#================================#

# The office has a human presence sensor to detect presence. I want to use that to control the ceiling fan.
# But what is needed is a delayed reaction after the human presence sensor turns off, so the fan doesn't go off until it's
# clear that the office is unoccupied. So we use an input boolean here that turns on quickly but only turns off 
# if the human presence sensor doesn't detect presence for a decent interval.
- alias: Toggle Office occupied
  id: toggle_office_occupied
  
  triggers:
    - trigger: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'off'
      to: 'on'
      for: '00:02:00'
      id: 'on'
    
    - trigger: state
      entity_id: binary_sensor.office_human_sensor_presence
      from: 'on'
      to: 'off'
      for: '00:15:00'
      id: 'off'
  
  actions:
    - action: input_boolean.turn_{{ trigger.id }}
      target:
        entity_id: input_boolean.office_occupied

#==============#
#     Fans     #
#==============#

# Operate the office fan when the office is occupied.
- alias: Operate Office Fan
  id: 'operate_office_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: input_boolean.office_occupied
      sensor_off_state: 'off'
      temperature_entity: sensor.office_sensor_temperature
      fan_entity: fan.office_fan
      thresholds: [80, 78, 76]

# Operate the family room fan when the AV system is on.
- alias: Operate Family Room Fan
  id: 'operate_family_room_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: binary_sensor.family_room_av_system
      sensor_off_state: 'off'
      temperature_entity: sensor.main_floor_temperature
      fan_entity: fan.family_room_fan
      thresholds: [80, 78.5, 74]

# Operate the theater fan when the AV system is on.
- alias: Operate Theater Fan
  id: 'operate_theater_fan'
  
  use_blueprint:
    path: devices/operate_ceiling_fans.yaml
    input:
      sensor_entity: sensor.harmony_hub
      sensor_off_state: 'PowerOff'
      temperature_entity: sensor.theater_temperature
      fan_entity: fan.theater_fan
      thresholds: [78, 76, 74]

# Turn off penthouse fan after a while.
- alias: Turn Off Penthouse Fan
  id: turn_off_penthouse_fan
  
  triggers:
    - trigger: state
      entity_id: switch.penthouse_fan
      from: 'off'
      to: 'on'
      for: '00:40:00'
  
  actions:
    - action: switch.turn_off
      entity_id: switch.penthouse_fan

#===================#
#     Treadmill     #
#===================#

# Treadmill start
- alias: Start Treadmill
  id: 'start_treadmill'
  
  # Trigger when the power usage of the treadmill rises above a threshold that indicates typical usage.
  triggers:
    - trigger: numeric_state
      entity_id: sensor.treadmill_current_consumption
      above: 200
  
  # If the treadmill is paused during a workout, the power usage drops below the above threshold then rises again.
  # This re-triggers this automation, so this condition prevents overwriting the start time.
  conditions:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'off'
  
  actions:
    
    # Set the treadmill start time.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.treadmill_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Set the flag used in the above condition that prevents re-triggers on pause.
    - action: input_boolean.turn_on
      target:
        entity_id: input_boolean.treadmill_triggered

# Treadmill power interrupted ... unfortunately the power plug might become unavailable while in use.
# We handle this as follows:
#
# 1) This automation detects the unavailable state ... if we're not close to being done, set the Treadmill Power timer for the expected done time, otherwise trigger Stop Treadmill
# 2) If we set a timer in step 1, Handle Treadmill Power Timer triggers Stop Treadmill at the timer expiration
# 3) If the plug becomes available again, cancel the timer if it's still running
- alias: Detect Treadmill Power Unavailable
  id: detect_treadmill_power_unavailable
  
  # Trigger when the power plug becomes unavailable.
  triggers:
    - trigger: state
      entity_id: sensor.treadmill_current_consumption
      to: 'unavailable'
  
  # Only continue if the start automation was previously triggered.
  conditions:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  actions:
    - variables:
        minutes_since_start: >
          {% from 'utilities.jinja' import calc_time_diff %}
          {{ calc_time_diff('input_datetime.treadmill_start') | int(0) }}
        
        default_minutes: "{{ states('input_number.default_treadmill_minutes') | int(0) }}"
        
        offset_minutes: 2
    
    - if: 
        - "{{ minutes_since_start <= (default_minutes - offset_minutes) }}"
      
      then:    
        - action: timer.start
          data:
            entity_id: timer.treadmill_power
            duration: "{{ (default_minutes - minutes_since_start) * 60 }}"
      
      else:
        - action: automation.trigger
          data:
            entity_id: automation.stop_treadmill
            skip_condition: false

# Cancel the Treadmill Power timer if the power plug becomes available.
- alias: Detect Treadmill Power Available
  id: detect_treadmill_power_available
  
  # Trigger when the power plug becomes available.
  triggers:
    - trigger: state
      entity_id: sensor.treadmill_current_consumption
      from: 'unavailable'
  
  actions:
    
    # If the start automation was previously triggered, cancel the timer if it's running.
    - if:
        - condition: state
          entity_id: input_boolean.treadmill_triggered
          state: 'on'
      
      then:
        - if:
            - condition: state
              entity_id: timer.treadmill_power
              state: 'active'
          
          then:
            - action: timer.cancel
              entity_id: timer.treadmill_power
      
      # The treadmill is not currently in use.
      else:
    
        # Turn off the treadmill power to conserve energy. Normally this happens in Stop Treadmill,
        # but if the power plug was unavailable at that time, we do it here.
        - action: switch.turn_off
          target:
            entity_id: switch.treadmill

# Trigger Stop Treadmill when the Treadmill Power timer expires.
- alias: Handle Treadmill Power Timer
  id: handle_treadmill_power_timer
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.treadmill_power
  
  actions:
    - action: automation.trigger
      data:
        entity_id: automation.stop_treadmill
        skip_condition: false

# Treadmill stop
- alias: Stop Treadmill
  id: 'stop_treadmill'
  
  # Trigger when the power usage of the treadmill indicates it's been turned off.
  triggers:
    - trigger: numeric_state
      entity_id: sensor.treadmill_current_consumption
      below: 7
  
  # Only continue if the start automation was previously triggered.
  conditions:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  actions:
    
    # Reset the triggered flag.
    - action: input_boolean.turn_off
      target:
        entity_id: input_boolean.treadmill_triggered
    
    # Turn off the treadmill power to conserve energy (a few watts are used for an illuminated power toggle).
    - action: switch.turn_off
      target:
        entity_id: switch.treadmill
    
    # Calculate the amount of time spent walking. I always walk some multiple of 5 minutes with a 1 minute cooldown, so round
    # down to the nearest 5 minutes (there could be an extra minute or two during a workout pause). The cooldown period
    # is accounted for in the next step.
    - action: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_time
      data:
        value: >
          {% set start = as_timestamp(strptime(states('input_datetime.treadmill_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set num = (now().timestamp() - start) // 60 %}
          {% set minutes = (num - (num % 5)) %}
          {{ minutes }}
    
    # Calculate calories burned. This is stolen from shapesense.com ... the formula is (for example 0 degree incline):
    #   CB = [0.0215 x KPH³ - 0.1765 x KPH² + 0.8710 x KPH + 1.4577] x WKG x T
    #
    #     CB = Calorie burn (in calories)
    #     KPH = Walking speed (in kilometres per hour)
    #     WKG = Weight (in kilograms)
    #     T = Time (in hours)
    #
    # NOTES:
    #   - The above formula only works for 0-5 degree incline ... more work needed here if I ever do higher inclines.
    #   - My cooldown period is always 1 minute at 2.0 MPH (ctime and ckph variables).
    - variables:
        daily_calories: >
          {% set weight  = states('sensor.smart_scale_p1_weight') | float(0) %}
          {% set speed   = states('input_number.treadmill_speed') | float(0) %}
          {% set incline = states('input_number.treadmill_incline') | int(0) %}
          {% set time    = states('input_number.treadmill_daily_time') | int(0) / 60 %}
          {% set ctime   = 1/60 %}
          {% set kph     = speed * 1.609344 %}
          {% set ckph    = 2.0   * 1.609344 %}
          {% set wkg     = weight * 0.45359237 %}
          {% if states('input_number.treadmill_incline') | int(0) == 0 %}
            {% set cooldown = (((ckph**3 * 0.0215) - (ckph**2 * 0.1765) + (ckph * 0.8710) + 1.4577) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0215) -  (kph**2 * 0.1765) +  (kph * 0.8710) + 1.4577) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 1 %}
            {% set cooldown = (((ckph**3 * 0.0171) - (ckph**2 * 0.1062) + (ckph * 0.6080) + 1.8600) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0171) -  (kph**2 * 0.1062) +  (kph * 0.6080) + 1.8600) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 2 %}
            {% set cooldown = (((ckph**3 * 0.0184) - (ckph**2 * 0.1134) + (ckph * 0.6566) + 1.9200) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0184) -  (kph**2 * 0.1134) +  (kph * 0.6566) + 1.9200) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 3 %}
            {% set cooldown = (((ckph**3 * 0.0196) - (ckph**2 * 0.1205) + (ckph * 0.7053) + 1.9800) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0196) -  (kph**2 * 0.1205) +  (kph * 0.7053) + 1.9800) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 4 %}
            {% set cooldown = (((ckph**3 * 0.0208) - (ckph**2 * 0.1277) + (ckph * 0.7539) + 2.0400) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0208) -  (kph**2 * 0.1277) +  (kph * 0.7539) + 2.0400) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 5 %}
            {% set cooldown = (((ckph**3 * 0.0221) - (ckph**2 * 0.1349) + (ckph * 0.8025) + 2.1000) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0221) -  (kph**2 * 0.1349) +  (kph * 0.8025) + 2.1000) * wkg *  time) | int(0) }}
          {% endif %}
    
    - action: input_number.set_value
      target:
        entity_id: input_number.treadmill_daily_calories
      data:
        value: "{{ daily_calories }}"
    
    # Register treadmill metrics.
    - action: script.register_exercise_metrics
      data:
        exercise_type: treadmill
        daily_calories: "{{ daily_calories }}"
    
    # Update the current treadmill used minutes. We keep minutes because the treadmill time is likely to not be an even hour.
    # We convert the minutes to hours in order to determine if lubrication is needed.
    - action: input_number.set_value
      target:
        entity_id: input_number.treadmill_usage_minutes
      data:
        value: "{{ states('input_number.treadmill_usage_minutes') | int(0) + states('input_number.treadmill_daily_time') | int(0) }}"

#====================#
#     Appliances     #
#====================#

# Check if certain devices are somehow off.
- alias: Check Refrigerator Off
  id: check_refrigerator_off
  
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.refrigerator
      component_name: tplink
      device_name: Refrigerator

- alias: Check Microwave Off
  id: check_microwave_off
  
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.microwave
      component_name: tplink
      device_name: Microwave

- alias: Check Projector Off
  id: check_projector_off
  
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.projector
      component_name: sonoff
      device_name: Projector
      conditional_processing: "{{ states('input_boolean.projector_plug_powered_off') }}"

#======================#
#     Robot Vacuum     #
#======================#

# Launch the vacuum.
- alias: Start Vacuum
  id: 'start_vacuum'
  
  triggers:
    - trigger: time
      at: '03:00:00'
  
  conditions:
    - condition: time
      weekday:
        - mon
    
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
  
  actions:
    
    # Sometimes the Ecovacs integration needs to be reloaded to function properly. If the vacuum state isn't docked, try
    # reloading it, then wait for the state to change to docked.
    - if:
        - "{{ states('vacuum.ecovacs_deebot_none') != 'docked' }}"
      
      then:    
        - action: homeassistant.reload_config_entry
          target:
            entity_id: vacuum.ecovacs_deebot_none
        
        - wait_template: "{{ is_state('vacuum.ecovacs_deebot_none', 'docked') }}"
          timeout:
            seconds: 10
        
        # Still no good? We're done.
        - if:
            - "{{ states('vacuum.ecovacs_deebot_none') != 'docked' }}"
          
          then:
            - action: script.send_notification
              data:
                destination:
                  - persistent
                title: Device Alert
                message: Vacuum not functioning good.
                notification_id: 'vacuum_nfg'
            
            - stop: Vacuum not functioning good
    
    # Reset status toggles.
    - action: input_boolean.turn_off
      entity_id:
        - input_boolean.vacuum_kicked_off
        - input_boolean.vacuum_finished
    
    # Start the timer before starting the vacuum: we use the timer running as a condition in Detect Vacuum Running.
    - action: timer.start
      data:
        entity_id: timer.vacuum
        duration: '01:30:00'
    
    - delay:
        milliseconds: 100
    
    - action: vacuum.start
      entity_id: vacuum.ecovacs_deebot_none

# Land the vacuum.
- alias: Stop Vacuum
  id: 'stop_vacuum'
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.vacuum
    
    - trigger: numeric_state
      entity_id: sensor.ecovacs_deebot_battery
      below: 20
  
  conditions:
    - condition: time
      weekday:
        - mon
  
  actions:
    - action: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot_none

# Detect the vacuum running.
- alias: Detect Vacuum Running
  id: 'detect_vacuum_running'
  
  triggers:
    - trigger: state
      entity_id: vacuum.ecovacs_deebot_none
      to: 'cleaning'
  
  conditions:
    - condition: time
      weekday:
        - mon
    
    - condition: state
      entity_id: timer.vacuum
      state: 'active'
  
  actions:
    - action: input_boolean.turn_on
      entity_id: input_boolean.vacuum_kicked_off

# Detect the vacuum finished.
- alias: Detect Vacuum Finished
  id: 'detect_vacuum_finished'
  
  triggers:
    - trigger: state
      entity_id: vacuum.ecovacs_deebot_none
      to: 'docked'
  
  conditions:
    - condition: time
      weekday:
        - mon
    
    - condition: state
      entity_id: input_boolean.vacuum_kicked_off
      state: 'on'
  
  actions:
    - action: input_boolean.turn_on
      entity_id: input_boolean.vacuum_finished

#================#
#     Washer     #
#================#

# Set the washer start time, based on the power state changing from stop to fill (or a potential unknown to fill).
- alias: Start Washer
  id: 'start_washer'
  
  triggers:
    - trigger: state 
      entity_id: sensor.washer_power_state
      from:
        - 'stop'
        - 'unknown'
      to: 'fill'
  
  actions:
    
    # Set the washer start time.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.washer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Indicate load size is sensing.
    - action: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: '*sensing*'
    
    # Remember to backup the log tomorrow morning.
    - action: input_boolean.turn_on
      entity_id: input_boolean.backup_laundry_log
    
    # Log the start in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: basic
        prefix: Washer
        message: "starting: softener {{ states('input_boolean.washer_fabric_softener') }}"

# Set the washer load size, based on the amount of time spent on the initial fill. This is triggered only
# when the power state changes from fill to raise, and the washer state is Wash Fill.
- alias: Set Washer Load Size
  id: 'set_washer_load_size'
  
  triggers:
    - trigger: state
      entity_id: sensor.washer_power_state
      from: 'fill'
      to: 'raise'
  
  conditions:
    - condition: state
      entity_id: input_select.washer_state
      state: 'Wash Fill'
  
  actions:
    - variables:
        washer_fill_seconds: >
          {% set start = as_timestamp(strptime(states('input_datetime.washer_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set seconds = (now().timestamp() - start) | round(0) %}
          {{ seconds }}
    
    # Set the washer load size. Default to medium if the calculation for seconds is unreasonably small.
    - action: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: >
          {% if   washer_fill_seconds >= 180 and washer_fill_seconds < 450 %}
            Small
          {% elif washer_fill_seconds >= 450 and washer_fill_seconds < 650 %}
            Medium
          {% elif washer_fill_seconds >= 650  %}
            Large
          {% else %}
            Medium
          {% endif %}
    
    # Save the washer fill seconds for diagnosis/tweaking.
    - action: input_number.set_value
      target:
        entity_id: input_number.washer_fill_seconds
      data:
        value: "{{ washer_fill_seconds }}"
    
    # Log the event in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: fill_plus_load
        prefix: Washer
        message: fill time, load size
        entity_id_1: input_number.washer_fill_seconds
        entity_id_2: input_select.washer_load_size

# Start the washer wash blackout timer. This is used to ignore a potential early drop,
# which would shorten the wash cycle dramatically.
- alias: Start Washer Wash Blackout Timer
  id: 'start_washer_wash_blackout_timer'
  
  triggers:
    - trigger: state 
      entity_id: input_select.washer_state
      from: 'Wash Fill'
      to: 'Wash'
  
  actions:
    - variables:
        duration: '00:01:00'
    
    - action: timer.start
      data:
        entity_id: timer.washer_wash_blackout
        duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_wash_blackout

# Start the washer rinse fill blackout timer. This is used to ignore the fabric softener injection
# during the rinse fill, which otherwise wreaks havoc on the operation control algorithm.
- alias: Start Washer Rinse Fill Blackout Timer
  id: 'start_washer_rinse_fill_blackout_timer'
  
  triggers:
    - trigger: state 
      entity_id: input_select.washer_state
      from: 'Wash Drain'
      to: 'Rinse Fill'
  
  conditions:
    - condition: state
      entity_id: input_boolean.washer_fabric_softener
      state: 'on'
  
  actions:
    - variables:
        
        # The timer amount is based on the washer load size. If it's invalid, use the medium value and hope for the best.
        duration: >
          {% set load_size = states('input_select.washer_load_size') %}
          {{ iif(load_size == 'Small', '00:03:00', iif(load_size == 'Large', '00:05:00', '00:04:00')) }}
    
    - action: timer.start
      data:
        entity_id: timer.washer_rinse_fill_blackout
        duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_rinse_fill_blackout

# Start the washer rinse blackout timer. This is used to ignore a potential early drop,
# which would shorten the rinse cycle dramatically.
- alias: Start Washer Rinse Blackout Timer
  id: 'start_washer_rinse_blackout_timer'
  
  triggers:
    - trigger: state 
      entity_id: input_select.washer_state
      from: 'Rinse Fill'
      to: 'Rinse'
  
  actions:
    - variables:
        duration: '00:01:00'
    
    - action: timer.start
      data:
        entity_id: timer.washer_rinse_blackout
        duration: "{{ duration }}"
    
    # Log the event in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: timer
        prefix: Washer
        message: "timer started ({{ duration }})"
        entity_id_1: timer.washer_rinse_blackout

# Washer operation control. This uses the washer power state sensor and other controls to step through the following washer states:
#
# - Off
# - Wash Fill
# - Wash
# - Wash Drain
# - Rinse Fill
# - Rinse
# - Rinse Drain
# - Off
- alias: Set Washer Operation
  id: 'set_washer_operation'
  
  trace:
    stored_traces: 20
  
  triggers:
    - trigger: state 
      entity_id: sensor.washer_power_state
  
  conditions: "{{ trigger.from_state and trigger.from_state.state != 'unavailable' }}"
  
  actions:
    
    # Delay one second so automations (above) that determine the load size have a chance to run before we do.
    - delay: '00:00:01'
    
    - variables:
        s: "{{ states('input_select.washer_state') }}"
    
    # Determine the washer state.
    - action: input_select.select_option
      data:
        entity_id: input_select.washer_state
        option: >
          {# --Set variables-- #}
          {% set fr = trigger.from_state.state %}
          {% set to = trigger.to_state.state %}
          {% set t1 = states('timer.washer_rinse_fill_blackout') %}
          {% set t2 = states('timer.washer_rinse_blackout') %}
          {% set t3 = states('timer.washer_wash_blackout') %}
          
          {# --Ignore everything if one of the timers is running-- #}
          {% if t1 == 'active' or t2 == 'active' or t3 == 'active' %} {{ s }}
          
          {# --Transition to new state based on current state and washer power state sensor change-- #}
          {% elif fr in ['stop', 'unknown'] and to == 'fill' %}                                    Wash Fill
          {% elif fr in ['fill', 'drop']    and to == 'raise'   and s == 'Wash Fill' %}            Wash
          {% elif fr == 'raise'             and to == 'drop'    and s in ['Wash', 'Wash Drain'] %} Wash Drain
          {% elif fr in ['drop', 'raise']   and to == 'fill'    and s == 'Wash Drain' %}           Rinse Fill
          {% elif fr in ['fill', 'drop']    and to == 'raise'   and s == 'Rinse Fill' %}           Rinse
          {% elif fr == 'raise'             and to == 'drop'    and s == 'Rinse' %}                Rinse Drain     
          
          {# --Some washer power state sensor changes just remain in the current state-- #}
          {% elif fr == 'drop'  and to in ['fill', 'raise'] %} {{ s }}
          {% elif fr == 'fill'  and to in ['drop', 'raise'] %} {{ s }}
          {% elif fr == 'raise' and to in ['fill', 'drop'] %}  {{ s }}
          
          {# --Catch-all, default to Off-- #}
          {% else %} Off
          {% endif %}
    
    # Continue if the state changed.
    - if:
        - "{{ s != states('input_select.washer_state') }}"
      
      then:
        
        # Log the state change in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: basic
            prefix: Washer
            message: "state changed from {{ s }} to {{ states('input_select.washer_state') }}"
        
        # Perform washer stopped tasks.
        - if:
            - "{{ is_state('input_select.washer_state', 'Off') }}"
          
          then:
            
            # Log the washer stop event.
            - action: script.log_laundry_event
              data:
                event_type: basic
                prefix: Washer
                message: stopped
            
            # Update the washer history time ranges.
            - action: script.update_laundry_history_time_ranges
              data:
                is_washer: true
                start_time: "{{ state_attr('input_datetime.washer_start', 'timestamp') | int(0) }}"
                stop_time: "{{ as_timestamp(now()) | round(0) }}"

#===============#
#     Dryer     #
#===============#

- alias: Turn On Dryer Running
  id: turn_on_dryer_running
  
  triggers:

    # Trigger when the dryer temperature rises a bit above ambient.
    - trigger: template
      value_template: >
        {{ states('sensor.dryer_sensor_temperature') not in ['unavailable', 'unknown'] and states('sensor.downstairs_temperature') not in ['unavailable', 'unknown'] and
           states('sensor.dryer_sensor_temperature') | int(0) > (states('sensor.downstairs_temperature') | int(0) + 30) }}
      
  actions:
    
    # Set the dryer start time. Note that we delay this until we detect a rising temperature because nothing interesting
    # happens before then.
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.dryer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

    # Initialize the temperature & humidity counts. This has the side effect of turning off the Dryer Done binary sensor.
    - action: counter.reset
      entity_id:
        - counter.dryer_temperature_count
        - counter.dryer_humidity_count
    
    # Indicate the dryer is running.
    - action: input_boolean.turn_on
      entity_id: input_boolean.dryer_running

    # Normally, we use the laundry button to indicate the dryer has started, but that is an optional step. If it wasn't used,
    # do the initial logging here.
    - if:
        - condition: state
          entity_id: input_boolean.dryer_started
          state: 'on'
      
      then:
    
        # Turn off dryer started.
        - action: input_boolean.turn_off
          entity_id: input_boolean.dryer_started
      
      else:
    
        # Remember to backup the log tomorrow morning.
        - action: input_boolean.turn_on
          entity_id: input_boolean.backup_laundry_log
        
        # Log initial information in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: basic
            prefix: Dryer
            message: >
              {% set intemp  = states('sensor.downstairs_temperature') %}
              {% set inhum   = states('sensor.downstairs_humidity') %}
              {% set outtemp = states('sensor.porch_sensor_temperature') %}
              {% set outhum  = states('sensor.openweathermap_humidity') %}
              
              environment: indoor ({{ intemp }}°, {{ inhum }}%); outdoor ({{ outtemp }}°, {{ outhum }} %)
    
    # Log temperature detected in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: metric
        prefix: Dryer
        message: temperature detected
        entity_id_1: sensor.dryer_sensor_temperature
    
    # Start a timer to ensure the Dryer Done binary sensor gets turned off at a failsafe time. This is accomplished
    # by resetting the temperature & humidity counts.
    - action: timer.start
      data:
        entity_id: timer.dryer_done_failsafe
        duration: '02:00:00'

# Ensure the Dryer Done binary sensor gets turned off at a failsafe time.
- alias: Reset Dryer Done Failsafe
  id: reset_dryer_done_failsafe
  
  triggers:
    - trigger: event
      event_type: timer.finished
      event_data:
        entity_id: timer.dryer_done_failsafe
  
  actions:
    - action: counter.reset
      entity_id:
        - counter.dryer_temperature_count
        - counter.dryer_humidity_count

# This is the basic dryer control. We trigger on 2 trend sensors, counting each of them: when they are both above 0 we indicate the
# dryer is done. The trend sensors are defined in the UI, but here is the original YAML configuration for reference.
# Note that the humidity drop amount in the sensor must coordinate with the humidity value in the first trigger.
#
#    # Measures humidity falling by 30 over 25 minutes.
#    # NOTE: The drop amount here must be kept in sync with the Register Dryer Event automation.
#    dryer_humidity_falling:
#      entity_id: sensor.dryer_sensor_humidity
#      friendly_name: Dryer Humidity Falling
#      sample_duration: 1500   # 25m * 60s
#      max_samples: 330        # 1500 / 5 (sampling interval) + 10%
#      min_gradient: -0.02000  # -30 / 1500
#
#    # Measures temperature falling by 20 over 10 minutes.
#    dryer_temperature_falling:
#      entity_id: sensor.dryer_sensor_temperature
#      friendly_name: Dryer Temperature Falling
#      sample_duration: 600    # 10m * 60s
#      max_samples: 132        # 600 / 5 (sampling interval) + 10%
#      min_gradient: -0.03333  # -20 / 600
- alias: Register Dryer Event
  id: register_dryer_event

  triggers:

    # Since our humidity trend sensor is looking for a drop of 30 points, only trigger if the current humidity is 70 or below.
    # This should weed out inaccurate trend sensor readings.
    # NOTE: The drop amount here must be kept in sync with the Dryer Humidity Falling trend sensor.
    - trigger: template
      value_template: "{{ states('binary_sensor.dryer_humidity_falling') == 'on' and states('sensor.dryer_sensor_humidity') | int(0) <= 70 }}"
      id: humidity

    # We don't bother doing the above for temperature. This would require saving the initial temperature when we detect the dryer is running, 
    # and I don't want to.
    - trigger: state
      entity_id: binary_sensor.dryer_temperature_falling
      to: 'on'
      id: temperature

  conditions:

    # Make sure the dryer is running ... we could easily detect changes at any time, since the sensor lives in the dryer vent connected to the outdoors.
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'

  actions: 

    # Bump the appropriate count. The dryer done binary sensor only turns on when both counts are above 0. We use counts in case we get 
    # spurious triggers, for example back to back humidity falling.
    - if:
        - "{{ trigger.id == 'temperature' }}"

      then:
        - action: counter.increment
          entity_id: counter.dryer_temperature_count

        # Log the event in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: metric
            prefix: Dryer
            message: temperature falling
            entity_id_1: sensor.dryer_sensor_temperature

      else:
        - action: counter.increment
          entity_id: counter.dryer_humidity_count

        # Log the event in the laundry events log.
        - action: script.log_laundry_event
          data:
            event_type: metric
            prefix: Dryer
            message: humidity falling
            entity_id_1: sensor.dryer_sensor_humidity

- alias: Turn Off Dryer Running
  id: turn_off_dryer_running
  
  triggers:
    
    # Trigger when the dryer done binary sensor turns on, indicating that both temperature and humidity have fallen.
    - trigger: state
      entity_id: binary_sensor.dryer_done
      to: 'on'

  conditions:

    # Make sure the dryer is running.
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'
  
  actions:
    
    # Turn off the dryer running flag.
    - action: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    
    # Log the stop in the laundry events log.
    - action: script.log_laundry_event
      data:
        event_type: basic
        prefix: Dryer
        message: stopped
            
    # Update the dryer history time ranges.
    - action: script.update_laundry_history_time_ranges
      data:
        is_washer: false
        start_time: "{{ state_attr('input_datetime.dryer_start', 'timestamp') | int(0) }}"
        stop_time: "{{ as_timestamp(now()) | round(0) }}"

#=======================#
#     Treadmill Fan     #
#=======================#

# Control the treadmill fan based on temperature.
- alias: Turn On Treadmill Fan
  id: 'turn_on_treadmill_fan'
  triggers:
    - trigger: state
      entity_id: input_boolean.treadmill_triggered
      to: 'on'
  
  actions:
    - choose:
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 70.0
        
        sequence:
          - delay: '00:10:00'
          - action: switch.turn_on
            entity_id: switch.treadmill_fan
      
      - conditions:
        - condition: numeric_state
          entity_id: climate.downstairs
          attribute: current_temperature
          below: 75.0
        
        sequence:
          - delay: '00:05:00'
          - action: switch.turn_on
            entity_id: switch.treadmill_fan
      
      default:
        - action: switch.turn_on
          entity_id: switch.treadmill_fan

- alias: Turn Off Treadmill Fan
  id: 'turn_off_treadmill_fan'
  
  triggers:
    - trigger: state
      entity_id: input_boolean.treadmill_triggered
      to: 'off'
  
  actions:
    
    # Allow a nice cooldown period.
    - delay: '00:02:00'
    
    # Turn off the treadmill fan.
    - action: switch.turn_off
      entity_id: switch.treadmill_fan
    
    # Now turn on the office fan so I can continue cooling down.
    - action: script.turn_on
      entity_id: script.control_fan_for_temperature
      data:
        variables:
          fan_entity_id: fan.office_fan
          temperature_entity_id: sensor.main_floor_temperature
          thresholds: [76, 74, 72]
          timeout: 360

#======================#
#     Echo Devices     #
#======================#

# Echo devices have a do not disturb (DND) switch, which supposedly blocks unsolicited notifications from Amazon.
# Turn on DND in all occupied bedrooms when the Bedtime script is run. Note that the master bedroom is always occupied.
# Turn off DND when the Handle Jon Awake automation is run.
- alias: Manage Echo Do Not Disturb
  id: 'manage_echo_do_not_disturb'
  
  triggers:
    - trigger: state
      entity_id: input_boolean.nighttime
      from: 'off'
      to: 'on'
      id: 'on'
  
    - trigger: state
      entity_id: input_boolean.nighttime
      from: 'on'
      to: 'off'
      id: 'off'
  
  actions:
    - variables:
        
        # Since there are only 3 bedrooms in the house, now and forever, this is just hardcoded, rather than something more sophisticated.
        bedroom_echoes: "{{ ['switch.master_bedroom_echo_do_not_disturb_switch', 'switch.studio_echo_do_not_disturb_switch', 'switch.penthouse_echo_do_not_disturb_switch'] }}"
    
    # Process all bedroom echoes.
    - repeat:
        for_each: "{{ bedroom_echoes }}"
        
        sequence:
          - variables:
              name: "{{ repeat.item.split('.')[1].split('_')[0] }}"
              
              # Note that for the master bedroom, this resolves to a non-existent entity. But we don't care because it isn't used below.
              occupied_sensor: "{{ 'binary_sensor.' ~ name ~ '_occupied' }}"
          
          # Continue if we need to take action for this bedroom.
          - if:
              - "{{ iif(name == 'master' or states(occupied_sensor) == 'on') }}"
            
            then:
              - action: switch.turn_{{ trigger.id }}
                target:
                  entity_id: "{{ repeat.item }}"

#========================#
#     Legion T530 PC     #
#========================#

# HASS.Agent appears to only update sensors when they change. Since that happens infrequently for the last boot,
# the HASS.Agent sensor becomes unknown after some time (I'm guessing a bit here as to why this happens).
# So this automation saves the last boot time if it changes, and we use the saved value everywhere instead of
# the one from HASS.Agent.
- alias: Update PC Lastboot
  id: update_pc_lastboot
  
  triggers:
    - trigger: state
      entity_id: sensor.legion_t530_lastboot
      to:
  
  conditions: "{{ trigger.to_state.state not in ['unknown', 'unavailable'] }}"
  
  actions:
    - action: input_datetime.set_datetime
      target:
        entity_id: input_datetime.pc_lastboot
      data:
        timestamp: "{{ as_timestamp(states('sensor.legion_t530_lastboot')) }}"

#=========================#
#     Generic Buttons     #
#=========================#
  
# We have a laundry room button that supports single, double and long presses. Handle those here.
- alias: Handle Laundry Room Button Action
  id: handle_laundry_room_button_action
  
  triggers:
    - trigger: mqtt
      topic: zigbee2mqtt/Laundry Room Button/action
      payload: 'single'
      id: single
  
    - trigger: mqtt
      topic: zigbee2mqtt/Laundry Room Button/action
      payload: 'double'
      id: double
  
    - trigger: mqtt
      topic: zigbee2mqtt/Laundry Room Button/action
      payload: 'release'
      id: long
  
  actions:   
    
    # Handle different button actions.
    - choose:
      
        # For a single button push, turn off driveway area lights that might be on because I just arrived home after dark.
        # This is optional: an automation will turn them off after a delay.
        - conditions: "{{ trigger.id == 'single' }}"
        
          sequence:
            - action: light.turn_off
              target:
                entity_id:
                  - light.driveway
                  - light.front_floodlight
      
        # For a double button push, reset certain laundry controls. This is only needed if a cycle got stuck somehow.
        - conditions: "{{ trigger.id == 'double' }}"
        
          sequence:
            - action: input_boolean.turn_off
              target:
                entity_id:
                  - input_boolean.dryer_started
                  - input_boolean.dryer_running
            
            - action: counter.reset
              target:
                entity_id:
                  - counter.dryer_humidity_count
                  - counter.dryer_temperature_count
      
        # For a long button push, initiate a dryer cycle. This is optional, but helps with debugging.
        - conditions: "{{ trigger.id == 'long' }}"
        
          sequence:
    
            # Indicate the dryer has started. This is the initial state before the temperature has been detected (in Turn On Dryer Running).
            - action: input_boolean.turn_on
              entity_id: input_boolean.dryer_started
            
            # Remember to backup the log tomorrow morning.
            - action: input_boolean.turn_on
              entity_id: input_boolean.backup_laundry_log
            
            # Log the start in the laundry events log.
            - action: script.log_laundry_event
              data:
                event_type: basic
                prefix: Dryer
                message: >
                  {% set intemp  = states('sensor.downstairs_temperature') %}
                  {% set inhum   = states('sensor.downstairs_humidity') %}
                  {% set outtemp = states('sensor.porch_sensor_temperature') %}
                  {% set outhum  = states('sensor.porch_sensor_humidity') %}
                  {% set drytemp = states('sensor.dryer_sensor_temperature') %}
                  {% set dryhum  = states('sensor.dryer_sensor_humidity') %}
                  
                  environment: indoor ({{ intemp }}°, {{ inhum }}%); outdoor ({{ outtemp }}°, {{ outhum }}%); dryer ({{ drytemp }}°, {{ dryhum }}%)

# We have a 4-way button for the guest studio that supports single, double, triple and long presses for each button. Handle those here.
- alias: Handle Guest 4 Way Button
  id: handle_guest_4_way_button
  
  triggers:
    - trigger: mqtt
      topic: zigbee2mqtt/Guest 4 Way Button/action
  
  actions:
    - variables:
        payload: "{{ trigger.payload }}"
        action: "{{ payload.split('_')[0] }}"
        button: "{{ payload.split('_')[-1] }}"
        
        domain: ''
        name: ''
        operation: ''
    
    # Handle different button actions.
    - choose:
      
        # Button 1, single push...
        - conditions: "{{ button == 1 and action == 'single' }}"
        
          sequence:
            - variables:
                domain: light
                name: studio_side_window_lamp
                operation: toggle
      
        # Button 1, double push...
        - conditions: "{{ button == 1 and action == 'double' }}"
        
          sequence:
            - variables:
                domain: light
                name: studio_front_window_lamp
                operation: toggle
      
        # Button 1, triple push...
        - conditions: "{{ button == 1 and action == 'triple' }}"
        
          sequence:
            - variables:
                domain: light
                name: studio_night_light
                operation: toggle
      
        # Button 1, long push...
        - conditions: "{{ button == 1 and action == 'long' }}"
        
          sequence:
            - variables:
                domain: light
                name: hallway_lamp
                operation: toggle
      
        # Button 2, single push...
        - conditions: "{{ button == 2 and action == 'single' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 2, double push...
        - conditions: "{{ button == 2 and action == 'double' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 2, triple push...
        - conditions: "{{ button == 2 and action == 'triple' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 2, long push...
        - conditions: "{{ button == 2 and action == 'long' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 3, single push...
        - conditions: "{{ button == 3 and action == 'single' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 3, double push...
        - conditions: "{{ button == 3 and action == 'double' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 3, triple push...
        - conditions: "{{ button == 3 and action == 'triple' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 3, long push...
        - conditions: "{{ button == 3 and action == 'long' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 4, single push...
        - conditions: "{{ button == 4 and action == 'single' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 4, double push...
        - conditions: "{{ button == 4 and action == 'double' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 4, triple push...
        - conditions: "{{ button == 4 and action == 'triple' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
      
        # Button 4, long push...
        - conditions: "{{ button == 4 and action == 'long' }}"
        
          sequence:
            - action: system_log.write
              data:
                message: "{{ 'button ' ~ button ~ ', ' ~ action ~ ' press' }}"
                level: info
    
    - variables:
        entity: "{{ domain ~ '.' ~ name }}"
    
    - choose:
        - conditions: "{{ domain == 'light' and operation == 'toggle' }}"
          
          sequence:
            - action: light.toggle
              target:
                entity_id: "{{ entity }}"
