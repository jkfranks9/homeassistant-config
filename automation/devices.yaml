#=============#
#     UPS     #
#=============#

# Handle a power outage, preserving UPS time for critical resources (HA, NUT server & internet).
- alias: Handle Power Outage
  id: 'handle_power_outage'
  
  # Trigger if the battery is discharging for a short time. I want to ignore the frequent short power glitches,
  # but not leave the PC on too long.
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OB DISCHRG'
      for: '00:01:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OB DISCHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.
    - service: notify.mobile_app_jon_galaxy
      data:
        title: 'Action required:'
        message: 'Power is out, shutting down PC.'
        data:
          channel: Security
          importance: high
          persistent: true
          tag: 'persistent'
    
    # The recorder database lives on the PC, so disable it before we shutdown.
    - service: recorder.disable
    
    # Shut down the PC.
    - service: script.turn_off_pc
    
    # The vacuum bizarrely starts running if the power goes out, so stop it (unless it's already running).   
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
    - service: vacuum.stop
      entity_id: vacuum.ecovacs_deebot 

# Shut down the host if UPS runtime reaches critical level.
- alias: Handle UPS Critical
  id: 'handle_ups_critical'
  trigger:
    - platform: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
    - platform: homeassistant
      event: start
  
  condition:
    - condition: numeric_state
      entity_id: sensor.cyber1_battery_runtime
      below: 420
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.
    - service: notify.mobile_app_jon_galaxy
      data:
        title: 'Action required:'
        message: 'UPS battery is critical, shutting down RPi.'
        data:
          channel: Security
          importance: high
          persistent: true
          tag: 'persistent'
    
    # Goodbye.
    - service: hassio.host_shutdown

# Turn the PC back on if power is restored.
- alias: Handle Power Restoration
  id: 'handle_power_restoration'
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status_data
      to: 'OL CHRG'
      for: '00:02:00'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status_data
      state: 'OL CHRG'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Send a notification.
    - service: notify.mobile_app_jon_galaxy
      data:
        title: 'Action required:'
        message: 'Power is restored, turning on the PC.'
        data:
          channel: Security
          importance: high
          persistent: true
          tag: 'persistent'
    
    # Send a magic packet to power on the PC.
    - service: wake_on_lan.send_magic_packet
      data:
        mac: 98-EE-CB-A6-80-EA
    
    # Enable the recorder after a short delay.
    - delay: '00:02:00'
    - service: recorder.enable
    
    # Reset smart bulbs if needed.
    - service: script.reset_smart_bulbs
    
    # Instruct the vacuum to return home.
    - service: vacuum.return_to_base
      entity_id: vacuum.ecovacs_deebot 

# Restart the NUT server service if it becomes unavailable.
- alias: Reboot NUT Service
  id: reboot_nut_service
  trigger:
    - platform: state
      entity_id: sensor.cyber1_status
      to: 'unavailable'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.cyber1_status
      state: 'unavailable'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - service: shell_command.reboot_nut_service

#===============#
#     House     #
#===============#

# Close up the house when needed.
- alias: Close House
  id: 'close_house'
  
  trigger:
    
    # Jon leaves home.
    - platform: state
      entity_id: group.device_tracker_jon
      from: 'home'
      to: 'not_home'
    
    # The sun goes to bed.
    - platform: state
      entity_id: sun.sun
      from: 'above_horizon'
      to: 'below_horizon'
    
    # In case HA was rebooting when one of the above triggers would have happened.
    - platform: homeassistant
      event: start
  
  # These conditions cover the HA start trigger.
  condition:
    - or:
      - condition: state
        entity_id: sun.sun
        state: 'below_horizon'
      - condition: template
        value_template: >
          {{ is_state('group.device_tracker_jon', 'not_home') and
             is_state('group.family_members', 'not_home') }}
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    
    # Close garage doors ... run the scripts in parallel because they contain a several minute delay.
    - service: script.turn_on
      target:
        entity_id: script.close_garage_door_north
    - service:  script.turn_on
      target:
        entity_id: script.close_garage_door_south
    
    - choose:
      
      # No one is home.
      - conditions:
        - condition: template
          value_template: >
            {{ is_state('group.device_tracker_jon', 'not_home') and
               is_state('group.family_members', 'not_home') }}
        
        sequence:
    
          # Lock the PC.
          - service: script.turn_on
            entity_id: script.lock_pc
    
          # Turn off all lights.
          - scene: scene.lights_out
    
          # Turn off all fans.
          - scene: scene.fans_off
        
          # Turn off automations that could turn on various lights.
          - service: automation.turn_off
            entity_id: automation.turn_on_christmas_lights
          - service: automation.turn_off
            entity_id: automation.turn_on_guest_lights_sunset
          - service: automation.turn_off
            entity_id: automation.turn_on_office_light
      
      # Must be sunset.
      default:
        
        # Turn off certain light domains.
        - service: scene.apply
          data:
            entities:
              light.storage_lights: 'off'
              light.outdoor_lights: 'off'

# Open up the house when needed.
- alias: Open House
  id: 'open_house'
  trigger:
    
    # Jon arrives home.
    - platform: state
      entity_id: group.device_tracker_jon
      from: 'not_home'
      to: 'home'
  
  action:
    
    # Turn on automations that were possibly turned off by Leave Home, and trigger them.
    - service: automation.turn_on
      entity_id: automation.turn_on_christmas_lights
    
    - service: automation.turn_on
      entity_id: automation.turn_on_guest_lights_sunset
    
    - service: automation.trigger
      data:
        entity_id: automation.turn_on_guest_lights_sunset
        skip_condition: false
    
    - service: automation.turn_on
      entity_id: automation.turn_on_office_light
    
    - service: automation.trigger
      data:
        entity_id: automation.turn_on_office_light
        skip_condition: false
    
    # Continue only if it's dark-ish.
    - condition: numeric_state
      entity_id: sun.sun
      attribute: elevation
      below: 6.0
    
    # Turn on appropriate lights.
    - choose:
      
      # It's Christmas time!
      - conditions:
        - condition: template
          value_template: "{{ is_state('input_boolean.christmas_mode', 'on') }}"
        
        sequence:
          - service: homeassistant.turn_on
            entity_id: light.daytime_christmas_lights
          
          - service: light.turn_on
            entity_id: light.office_lamp
      
      # No it's not!
      default:
        - service: homeassistant.turn_on
          entity_id: light.daytime_lights
        
        - service: light.turn_on
          entity_id: light.office_lamp

#========================#
#     Family Room AV     #
#========================#

# Turn on the Family Room AV during the day, depending on the presence of a grandchild.
- alias: Enable Family Room AV
  id: 'enable_family_room_av'
  trigger:
    - platform: time
      at: '07:00:00'
      id: 'morning'
    - platform: time
      at: '16:00:00'
      id: 'afternoon'
  condition:
    - or:
      - and:
        - condition: state
          entity_id: input_boolean.grandchild_home
          state: 'on'
        - condition: trigger
          id: 'morning'
      - condition: trigger
        id: 'afternoon'
  action:
    - condition: state
      entity_id: input_boolean.extended_away_mode
      state: 'off'
    - service: script.enable_family_room_av

# Turn off the Family Room AV at night.
- alias: Disable Family Room AV
  id: 'disable_family_room_av'
  trigger:
    - platform: state
      entity_id: input_boolean.nighttime
      from: 'off'
      to: 'on'
  action:
    - service: script.disable_family_room_av

#===================#
#     Treadmill     #
#===================#

# Treadmill start
- alias: Start Treadmill
  id: 'start_treadmill'
  
  # Trigger when the power usage of the treadmill rises above a threshold that indicates typical usage.
  trigger:
    - platform: numeric_state
      entity_id: sensor.sonoff_treadmill_power
      above: 200
  
  # If the treadmill is paused during a workout, the power usage drops below the above threshold then rises again.
  # This re-triggers this automation, so this condition prevents overwriting the start time.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'off'
  
  action:
    
    # We use the utility meter to create different period sensors for the time and calories. Utility meter needs the values to 
    # change in order to set the sensors. So reset them to 0 before the workout in order to register value changes.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_time
      data:
        value: 0
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_calories
      data:
        value: 0
    
    # Set the treadmill start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.treadmill_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"
    
    # Set the flag used in the above condition that prevents re-triggers on pause.
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.treadmill_triggered

# Treadmill stop
- alias: Stop Treadmill
  id: 'stop_treadmill'
  
  # Trigger when the power usage of the treadmill indicates it's been turned off.
  trigger:
    - platform: numeric_state
      entity_id: sensor.sonoff_treadmill_power
      below: 7
  
  # Only continue if the start automation was previously triggered.
  condition:
    - condition: state
      entity_id: input_boolean.treadmill_triggered
      state: 'on'
  
  action:    
    
    # Reset the triggered flag.
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.treadmill_triggered
    
    # Turn off the treadmill power to conserve energy (a few watts are used for an illuminated power toggle).
    - service: switch.turn_off
      target:
        entity_id: switch.sonoff_treadmill
    
    # Calculate the amount of time spent walking. I always walk some multiple of 5 minutes with a 1 minute cooldown, so round
    # down to the nearest 5 minutes (there could be an extra minute or two during a workout pause). The cooldown period
    # is accounted for in the next step.
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_time
      data:
        value: >
          {% set start = as_timestamp(strptime(states('input_datetime.treadmill_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set num = (now().timestamp() - start) // 60 %}
          {% set minutes = (num - (num % 5)) %}
          {{ minutes }}
    
    # Calculate calories burned. This is stolen from shapesense.com ... the formula is (for example 0 degree incline):
    #   CB = [0.0215 x KPH³ - 0.1765 x KPH² + 0.8710 x KPH + 1.4577] x WKG x T
    #
    #     CB = Calorie burn (in calories)
    #     KPH = Walking speed (in kilometres per hour)
    #     WKG = Weight (in kilograms)
    #     T = Time (in hours)
    #
    # NOTES:
    #   - The above formula only works for 0-5 degree incline ... more work needed here if I ever do higher inclines.
    #   - My cooldown period is always 1 minute at 2.0 MPH (ctime and ckph variables).
    - service: input_number.set_value
      target:
        entity_id: input_number.treadmill_calories
      data:
        value: >
          {% set weight  = states('input_number.user_weight') | int(0) %}
          {% set speed   = states('input_number.treadmill_speed') | float(0) %}
          {% set incline = states('input_number.treadmill_incline') | int(0) %}
          {% set time    = states('input_number.treadmill_time')| int(0) / 60 %}
          {% set ctime   = 1/60 %}
          {% set kph     = speed * 1.609344 %}
          {% set ckph    = 2.0   * 1.609344 %}
          {% set wkg     = weight * 0.45359237 %}
          {% if states('input_number.treadmill_incline') | int(0) == 0 %}
            {% set cooldown = (((ckph**3 * 0.0215) - (ckph**2 * 0.1765) + (ckph * 0.8710) + 1.4577) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0215) -  (kph**2 * 0.1765) +  (kph * 0.8710) + 1.4577) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 1 %}
            {% set cooldown = (((ckph**3 * 0.0171) - (ckph**2 * 0.1062) + (ckph * 0.6080) + 1.8600) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0171) -  (kph**2 * 0.1062) +  (kph * 0.6080) + 1.8600) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 2 %}
            {% set cooldown = (((ckph**3 * 0.0184) - (ckph**2 * 0.1134) + (ckph * 0.6566) + 1.9200) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0184) -  (kph**2 * 0.1134) +  (kph * 0.6566) + 1.9200) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 3 %}
            {% set cooldown = (((ckph**3 * 0.0196) - (ckph**2 * 0.1205) + (ckph * 0.7053) + 1.9800) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0196) -  (kph**2 * 0.1205) +  (kph * 0.7053) + 1.9800) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 4 %}
            {% set cooldown = (((ckph**3 * 0.0208) - (ckph**2 * 0.1277) + (ckph * 0.7539) + 2.0400) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0208) -  (kph**2 * 0.1277) +  (kph * 0.7539) + 2.0400) * wkg *  time) | int(0) }}
          {% elif states('input_number.treadmill_incline') | int(0) == 5 %}
            {% set cooldown = (((ckph**3 * 0.0221) - (ckph**2 * 0.1349) + (ckph * 0.8025) + 2.1000) * wkg * ctime) | int(0) %}
            {{ cooldown     + (( (kph**3 * 0.0221) -  (kph**2 * 0.1349) +  (kph * 0.8025) + 2.1000) * wkg *  time) | int(0) }}
          {% endif %}

#======================#
#     Garage Doors     #
#======================#

# Open garage door when family member(s) arrive home, and I'm home.
- alias: Open Garage Door For Family
  id: 'open_garage_door_for_family'
  trigger:
    - platform: state
      entity_id: group.family_members
      from: 'not_home'
      to: 'home'
    #- platform: state
    #  entity_id: sensor.blue_charm_beacon
    #  from: 'not_home'
    #  to: 'garage'
    #- platform: state
    #  entity_id: sensor.blue_charm_beacon
    #  from: 'not_home'
    #  to: 'house'
  condition:
    - condition: state
      entity_id: group.device_tracker_jon
      state: 'home'
    - condition: template
      value_template: "{{ is_state('binary_sensor.shelly1_garage_north_contact', 'on') }}"
  action:
    - service: switch.turn_on
      target:
        entity_id: switch.shelly1_garage_north

#====================#
#     Appliances     #
#====================#

# Check if the refrigerator is somehow off.
- alias: Check Refrigerator Off
  id: check_refrigerator_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.sonoff_refrigerator
      notification_entity: notify.mobile_app_jon_galaxy
      component_name: sonoff
      device_name: Refrigerator

# Check if the microwave is somehow off.
- alias: Check Microwave Off
  id: check_microwave_off
  use_blueprint:
    path: devices/monitor_device.yaml
    input:
      device_entity: switch.sonoff_microwave
      notification_entity: notify.mobile_app_jon_galaxy
      component_name: sonoff
      device_name: Microwave

# Turn off washer plug early each day.
- alias: Turn Off Washer Plug
  id: 'turn_off_washer_plug'
  trigger:
    - platform:  time
      at: '01:01:01'
  action:
    - service: switch.turn_off
      entity_id: switch.sonoff_washer

#======================#
#     Robot Vacuum     #
#======================#

# Launch the vacuum.
- alias: Start Vacuum
  id: 'start_vacuum'
  trigger:
    - platform: time
      at: '03:19:00'
    - platform: homeassistant
      event: start
  condition:
    - condition: time
      after: '03:19:00'
    - condition: time
      before: '04:19:00'
    - condition: time
      weekday:
        - mon
    - condition: state
      entity_id: timer.vacuum
      state: 'idle'
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"
    - service: input_boolean.turn_off
      entity_id: input_boolean.vacuum_kicked_off
    - service: vacuum.turn_on
      entity_id: vacuum.ecovacs_deebot
    - service: timer.start
      data:
        entity_id: timer.vacuum
        duration: '01:00:00'

# Land the vacuum.
- alias: Stop Vacuum
  id: 'stop_vacuum'
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.vacuum
    - platform: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 20
  condition:
    - condition: time
      weekday:
        - mon
  action:
    - service: vacuum.turn_off
      entity_id: vacuum.ecovacs_deebot

# Detect the vacuum running - we use the battery dropping below a threshold as the trigger.
- alias: Detect Vacuum Running
  id: 'detect_vacuum_running'
  trigger:
    - platform: numeric_state
      entity_id: sensor.ecovacs_battery
      below: 90
  condition:
    - condition: time
      weekday:
        - mon
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.vacuum_kicked_off

#================#
#     Washer     #
#================#

# Set the washer start time, based on the power state changing from stop to fill (or a potential unknown to fill).
- alias: Start Washer
  id: 'start_washer'
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
      from: 'stop'
      to: 'fill'
    - platform: state 
      entity_id: sensor.washer_power_state
      from: 'unknown'
      to: 'fill'
  
  action:
    
    # Set the washer start time.
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.washer_start
      data_template:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

# Set the washer load size, based on the amount of time spent on the initial fill. This is triggered only
# when the power state changes from fill to raise, and the washer state is Wash Fill.
- alias: Set Washer Load Size
  id: 'set_washer_load_size'
  trigger:
    - platform: state
      entity_id: sensor.washer_power_state
      from: 'fill'
      to: 'raise'
  
  condition:
    - condition: state
      entity_id: input_select.washer_state
      state: 'Wash Fill'
  
  action:
    
    # Set the washer load size.
    - service: input_select.select_option
      target:
        entity_id: input_select.washer_load_size
      data:
        option: >
          {% set start = as_timestamp(strptime(states('input_datetime.washer_start'), '%Y-%m-%d %H:%M:%S')) %}
          {% set seconds = (now().timestamp() - start) %}
          {% if   seconds >= 240 and seconds < 350 %} Small
          {% elif seconds >= 350 and seconds < 500 %} Medium
          {% elif seconds >= 500  %}                  Large
          {% endif %}

# Start the washer rinse fill blackout timer. This is used to ignore the fabric softener injection
# during the rinse fill, which otherwise wreaks havoc on the operation control algorithm.
- alias: Start Washer Rinse Fill Blackout Timer
  id: 'start_washer_rinse_fill_blackout_timer'
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Wash Drain'
      to: 'Rinse Fill'
  
  action:
    
    # The timer amount is based on the washer load size.
    - choose:
      
      # Small
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Small'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:03:00'
        
      # Medium
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Medium'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:04:00'
        
      # Large
      - conditions:
        - condition: state
          entity_id: input_select.washer_load_size
          state: 'Large'
        sequence:
          - service: timer.start
            data:
              entity_id: timer.washer_rinse_fill_blackout
              duration: '00:05:00'
      
      # Invalid load size, log it. Then use the medium value and hope for the best.
      default:
        - service: system_log.write
          data:
            message: "Invalid washer load size {{ states('input_select.washer_load_size') }} specified"
            level: error
        - service: timer.start
          data:
            entity_id: timer.washer_rinse_fill_blackout
            duration: '00:04:00'

# Start the washer rinse blackout timer. This is used to ignore a potential early drop,
# which would shorten the rinse cycle dramatically.
- alias: Start Washer Rinse Blackout Timer
  id: 'start_washer_rinse_blackout_timer'
  trigger:
    - platform: state 
      entity_id: input_select.washer_state
      from: 'Rinse Fill'
      to: 'Rinse'
  
  action:
    - service: timer.start
      data:
        entity_id: timer.washer_rinse_blackout
        duration: '00:01:00'

# Washer operation control. This uses the washer power state sensor and other controls to step through the following washer states:
#
# - Stop
# - Wash Fill
# - Wash
# - Wash Drain
# - Rinse Fill
# - Rinse
# - Rinse Drain
# - Stop
- alias: Set Washer Operation
  id: 'set_washer_operation'
  trigger:
    - platform: state 
      entity_id: sensor.washer_power_state
  
  condition:
    - condition: template
      value_template: "{{ trigger.from_state and trigger.from_state.state != 'unavailable' }}"
  
  action:
    
    # Delay one second so automations (above) that determine the load size have a chance to run before we do.
    - delay: '00:00:01'
    
    # Determine the washer state.
    - service: input_select.select_option
      data:
        entity_id: input_select.washer_state
        option: >
          {# --Set variables-- #}
          {% set s = states('input_select.washer_state') %}
          {% set fr = trigger.from_state.state %}
          {% set to = trigger.to_state.state %}
          {% set t1 = states('timer.washer_rinse_fill_blackout') %}
          {% set t2 = states('timer.washer_rinse_blackout') %}
          
          {# --Ignore everything if one of the timers is running-- #}
          {% if t1 == 'active' or t2 == 'active'%} {{ s }}
          
          {# --Transition to new state based on current state and washer power state sensor change-- #}
          {% elif fr in ['stop', 'unknown']       and to in ['fill', 'pause'] %}                         Wash Fill
          {% elif fr in ['fill', 'pause']         and to == 'raise'   and s == 'Wash Fill' %}            Wash
          {% elif fr == 'raise'                   and to == 'drop'    and s in ['Wash', 'Wash Drain'] %} Wash Drain
          {% elif fr == 'pause'                   and to == 'fill' %}                                    Rinse Fill
          {% elif fr in ['fill', 'pause', 'drop'] and to == 'raise'   and s == 'Rinse Fill' %}           Rinse
          {% elif fr == 'raise'                   and to == 'drop'    and s == 'Rinse' %}                Rinse Drain     
          
          {# --Some washer power state sensor changes just remain in the current state-- #}
          {% elif fr == 'drop'  and to in ['fill', 'raise', 'pause'] %} {{ s }}
          {% elif fr == 'fill'  and to in ['pause', 'drop', 'raise'] %} {{ s }}
          {% elif fr == 'raise' and to in ['drop', 'pause'] %}          {{ s }}
          {% elif fr == 'pause' and to in ['drop', 'raise'] %}          {{ s }}
          
          {# --Catch-all, default to Stop-- #}
          {% else %} Stop
          {% endif %}

#===============#
#     Dryer     #
#===============#

- alias: Turn On Dryer Running
  id: turn_on_dryer_running
  trigger:
    - platform: template
      value_template: >
        {{ states('sensor.dryer_temperature') != 'unavailable' and states('sensor.office_temperature') != 'unavailable' and
           states('sensor.dryer_temperature') | int(0) > (states('sensor.office_temperature') | int(0) + 10) }}
  action:
    - service: input_boolean.turn_on
      entity_id: input_boolean.dryer_running

- alias: Turn On Dryer Almost Done
  id: turn_on_dryer_almost_done
  
  trigger:
    - platform: state
      entity_id: binary_sensor.dryer_humidity_falling
      to: 'on'
    - platform: state
      entity_id: binary_sensor.dryer_temperature_falling
      to: 'on'
  
  condition:
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'
  
  action:
    - delay: '00:00:01'
    - service: input_boolean.turn_on
      entity_id: input_boolean.dryer_almost_done

- alias: Turn Off Dryer Running
  id: turn_off_dryer_running
  
  trigger:
    - platform: state
      entity_id: binary_sensor.dryer_humidity_falling
      to: 'on'
    - platform: state
      entity_id: binary_sensor.dryer_temperature_falling
      to: 'on'
  
  condition:
    - condition: state
      entity_id: input_boolean.dryer_almost_done
      state: 'on'
  
  action:
    - service: input_boolean.turn_off
      entity_id: input_boolean.dryer_running
    - delay: '00:00:02'
    - service: input_boolean.turn_off
      entity_id: input_boolean.dryer_almost_done

# Log the dryer trend sensors for debugging purposes. I anticipate needing a lot of dryer runs in different seasons
# and conditions before settling on the final settings for the trend sensors that trigger the end of the cycle.
- alias: Log Dryer Trend Sensors
  id: log_dryer_trend_sensors
  mode: queued
  
  trigger:
    - platform: state
      entity_id: binary_sensor.dryer_humidity_falling
      attribute: gradient
      id: humidity
    - platform: state
      entity_id: binary_sensor.dryer_temperature_falling
      attribute: gradient
      id: temperature
  
  condition:
    - condition: state
      entity_id: input_boolean.dryer_running
      state: 'on'
  
  action:
    - if:
        - condition: trigger
          id: humidity
      then:
        - service: notify.dryer_trend_sensors
          data_template:
            message: >
             {{ as_timestamp(now()) | timestamp_custom('%b %d: %X') }}: Humidity {{ trigger.to_state.attributes.gradient }}
      else:
        - service: notify.dryer_trend_sensors
          data_template:
            message: >
             {{ as_timestamp(now()) | timestamp_custom('%b %d: %X') }}: Temperature {{ trigger.to_state.attributes.gradient }}

#=====================#
#     Zigbee2MQTT     #
#=====================#

# Send MQTT message to change log level in response to UI change.
- alias: Zigbee2MQTT Set Log Level
  id: 'zigbee2mqtt_set_log_level'
  trigger:
    platform: state
    entity_id: input_select.zigbee2mqtt_log_level
  action:
    - service: mqtt.publish
      data:
        payload_template: "{{ states('input_select.zigbee2mqtt_log_level') }}"
        topic: zigbee2mqtt/bridge/request/config/log_level

# Start timer when enable join is turned on in the UI.
- alias: Zigbee2MQTT Enable Join
  id: 'zigbee2mqtt_enable_join'
  trigger:
    platform: state
    entity_id: switch.zigbee2mqtt_permit_join
    to: 'on'
  action:
    - service: timer.start
      entity_id: timer.zigbee2mqtt_join_time_remaining
      data_template:
        duration: "{{ '00:0%i:00' % (states('input_number.zigbee2mqtt_join_minutes') | int(0) ) }}"

# Stop timer and turn off enable join when the timer is finished.
- alias: Zigbee2MQTT Disable Join
  id: 'zigbee2mqtt_disable_join'
  trigger:
    - platform: event
      event_type: timer.finished
      event_data:
        entity_id: timer.zigbee2mqtt_join_time_remaining
    - platform: state
      entity_id: switch.zigbee2mqtt_permit_join
      to: 'off'
  action:
    - service: timer.cancel
      data:
        entity_id: timer.zigbee2mqtt_join_time_remaining
    - service: switch.turn_off
      entity_id: switch.zigbee2mqtt_permit_join

#=======================#
#     General Plugs     #
#=======================#

# Control the treadmill fan based on temperature.
- alias: Turn On Treadmill Fan
  id: 'turn_on_treadmill_fan'
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'on'
  action:
    - choose:
      - conditions:
        - condition: numeric_state
          entity_id: sensor.office_temperature
          below: 70.0
        sequence:
          - delay: '00:10:00'
          - service: switch.turn_on
            entity_id: switch.general_plug_1
      
      - conditions:
        - condition: numeric_state
          entity_id: sensor.office_temperature
          below: 75.0
        sequence:
          - delay: '00:05:00'
          - service: switch.turn_on
            entity_id: switch.general_plug_1
      
      default:
        - service: switch.turn_on
          entity_id: switch.general_plug_1

- alias: Turn Off Treadmill Fan
  id: 'turn_off_treadmill_fan'
  trigger:
    - platform: state
      entity_id: input_boolean.treadmill_triggered
      to: 'off'
  action:
    - delay: '00:02:00'
    - service: switch.turn_off
      entity_id: switch.general_plug_1

#======================#
#     Tags/Beacons     #
#======================#

# Control grandchild home mode based on Nut Mini presence.
- alias: Turn On Grandchild Home
  id: 'turn_on_grandchild_home'
  trigger:
    - platform: state
      entity_id: sensor.nut_mini
      from: 'not_home'
      to:
        - 'garage'
        - 'house'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.nut_mini
      state:
        - 'garage'
        - 'house'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"    
    - service: input_boolean.turn_on
      entity_id: input_boolean.grandchild_home

- alias: Turn Off Grandchild Home
  id: 'turn_off_grandchild_home'
  trigger:
    - platform: state
      entity_id: sensor.nut_mini
      from:
        - 'garage'
        - 'house'
      to: 'not_home'
    - platform: homeassistant
      event: start
  
  condition:
    - condition: state
      entity_id: sensor.nut_mini
      state: 'not_home'
  
  action:
    - delay: 
        seconds: "{{ range(2, 15) | random }}"    
    - service: input_boolean.turn_off
      entity_id: input_boolean.grandchild_home
